<section>
<h2 id="ranges">Ranges</h2>

<h3 id="ranges-introduction-to-dom-ranges">Introduction to "DOM Ranges"</h3>

  A <code><a>Range</a></code> object (<a>range</a>) represents a sequence of content within a <a>node tree</a>. Each <a>range</a> has a <a>start</a> and an <a>end</a> which are <a>boundary points</a>. A <a>boundary point</a> is a tuple consisting of a <a>node</a> and a non-negative numeric <a>offset</a>. So in other words, a <a>range</a> represents a piece of content within a <a>node tree</a> between two <a>boundary points</a>.

  <a>Ranges</a> are frequently used in editing for selecting and copying content.

<ul class="domTree">
 <li class="t1"><a>Element</a>: <code>p</code>
  <ul>
   <li class="t1"><a>Element</a>: <code>img</code> <span class="t2"><code>src</code>="<code>insanity-wolf</code>"</span> <span><code>alt</code>="<code>Little-endian BOM; decode as big-endian!</code>"</span> 
   <li class="t3"><code><a>Text</a></code>: <span> CSS 2.1 syndata is </span>
   <li class="t1"><a>Element</a>: <code>em</code>
    <ul>
     <li class="t3"><code><a>Text</a></code>: <span>awesome</span>
    </ul>
   <li class="t3"><code><a>Text</a></code>: <span>!</span>
  </ul>
</ul>
<!-- http://w3cmemes.tumblr.com/post/35332222321/css-2-1-syndata-is-awesome -->

<p>In the <a>node tree</a> above, a <a>range</a> can be used to represent the sequence “syndata is awes”. Assuming <var>p</var> is assigned to the <code>p</code> <a>element</a>, and <var>em</var> to the <code>em</code> <a>element</a>, this would be done as follows:

<pre class='example'><code>var range = new Range(),
    firstText = p.childNodes[1],
    secondText = em.firstChild
range.setStart(firstText, 9) // do not forget the leading space
range.setEnd(secondText, 4)
// range now stringifies to the aforementioned quote</code></pre>

<p class="note">Note: <a>Attributes</a> such as <code>src</code> and <code>alt</code> in the <a>node tree</a> above cannot be represented by a <a>range</a>. The <a>ranges</a> concept is only useful for <a>nodes</a>.

<p><a>Ranges</a> are affected by mutations to the <a>node tree</a>. Such mutations will not invalidate a <a>range</a> and will try to ensure that the <a>range</a> still represents the same piece of content. Necessarily, a <a>range</a> might itself be modified as part of the mutation to the <a>node tree</a> when e.g. part of the content it represents is mutated.

<p class="note">Note: See the <a>insert</a> and <a>remove</a> algorithms, the <code><a>normalize()</a></code> method, and the <a>replace data</a> and <a>split</a> algorithms for the hairy details.

<h3 id="ranges-interface-range">Interface <code><a>Range</a></code></h3>

<pre class='idl'>
[Constructor,
 Exposed=Window]
interface Range {
  readonly attribute Node startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute Node endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute Node commonAncestorContainer;

  void setStart(Node node, unsigned long offset);
  void setEnd(Node node, unsigned long offset);
  void setStartBefore(Node node);
  void setStartAfter(Node node);
  void setEndBefore(Node node);
  void setEndAfter(Node node);
  void collapse(optional boolean toStart = false);
  void selectNode(Node node);
  void selectNodeContents(Node node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, Range sourceRange);

  void deleteContents();
  [NewObject] DocumentFragment extractContents();
  [NewObject] DocumentFragment cloneContents();
  void insertNode(Node node);
  void surroundContents(Node newParent);

  [NewObject] Range cloneRange();
  void detach();

  boolean isPointInRange(Node node, unsigned long offset);
  short comparePoint(Node node, unsigned long offset);

  boolean intersectsNode(Node node);

  stringifier;
};
</pre>

<p><code><a>Range</a></code> objects are simply known as <dfn lt="range|ranges">ranges</dfn>.

<p>A <dfn>boundary point</dfn> is a (<a>node</a>, <dfn lt="range boundary point offset|boundary point offset|offset">offset</dfn>) tuple, where <a>offset</a> is a non-negative integer.

<p class="note">Note: Generally speaking, a <a>boundary point</a>'s <a>offset</a> will be between zero and the <a>boundary point</a>'s <a>node</a> <a>length</a>, inclusive. Algorithms that modify a <a>tree</a> (in particular the <a>insert</a>, <a>remove</a>, <a>replace data</a>, and <a>split</a> algorithms) also modify <a>ranges</a> associated with that <a>tree</a>.

<p>If the two <a>nodes</a> of <a>boundary points</a> (<var>node A</var>, <var>offset A</var>) and (<var>node B</var>, <var>offset B</var>) have the same <a href="#tree-root">root</a>, the <dfn lt="range boundary point position|boundary point position|position">position</dfn> of the first relative to the second is either <dfn lt="range boundary point before|boundary point before|before">before</dfn>, <dfn lt="range boundary point equal|boundary point equal|equal">equal</dfn>, or <dfn lt="range boundary point after|boundary point after|after">after</dfn>, as returned by the following algorithm:

<ol>
  <li>If <var>node A</var> is the same as <var>node B</var>, return <a>equal</a> if <var>offset A</var> is the same as <var>offset B</var>, <a>before</a> if <var>offset A</var> is less than <var>offset B</var>, and <a>after</a> if <var>offset A</var> is greater than <var>offset B</var>.

  <li>If <var>node A</var> is <a>following</a> <var>node B</var>, compute the <a>position</a> of (<var>node B</var>, <var>offset B</var>) relative to (<var>node A</var>, <var>offset A</var>). If it is <a>before</a>, return <a>after</a>. If it is <a>after</a>, return <a>before</a>.

  <li>If <var>node A</var> is an <a>ancestor</a> of <var>node B</var>:

  <ol>
    1. Let <var>child</var> equal <var>node B</var>.

    2. While <var>child</var> is not a <a>child</a> of <var>node A</var>, set <var>child</var> to its <a>parent</a>.

    3. If the <a>index</a> of <var>child</var> is less than <var>offset A</var>, return <a>after</a>.

  </ol>

  <li>Return <a>before</a>.

</ol>

<p>Each <a>range</a> has two associated <a>boundary points</a> — a <dfn lt="range start|start">start</dfn> and <dfn lt="range end|end">end</dfn>.

<p>For convenience, <dfn lt="range start node|start node">start node</dfn> is <a>start</a>'s <a>node</a>, <dfn>start offset</dfn> is <a>start</a>'s <a>offset</a>, <dfn lt="range end node|end node">end node</dfn> is <a>end</a>'s <a>node</a>, and <dfn>end offset</dfn> is <a>end</a>'s <a>offset</a>.

<p>The <dfn id="range-root" for="range">root of a range</dfn> is the <a href="#tree-root">root</a> of its <a>start node</a>.
<!-- start and end have an identical root -->

<p>A <a>node</a> <var>node</var> is <dfn>contained</dfn> in a <a>range</a> <var>range</var> if <var>node</var>'s <a href="#tree-root">root</a> is the same as <var>range</var>'s <a href="#range-root">root</a>, and (<var>node</var>, 0) is <a>after</a> <var>range</var>'s <a>start</a>, and (<var>node</var>, <a>length</a> of <var>node</var>) is <a>before</a> <var>range</var>'s <a>end</a>.

<p>A <a>node</a> is <dfn>partially contained</dfn> in a <a>range</a> if it is an <a>inclusive ancestor</a> of the <a>range</a>'s <a>start node</a> but not its <a>end node</a>, or vice versa.

<div class="note">
 <p>Some facts to better understand these definitions:

 <ul>
  <li><p>The content that one would think of as being within the <a>range</a> consists of all <a>contained</a> <a>nodes</a>, plus possibly some of the contents of the <a>start node</a> and <a>end node</a> if those are <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>nodes</a>.

  <li><p>The <a>nodes</a> that are contained in a <a>range</a> will generally not be contiguous, because the <a>parent</a> of a <a>contained</a> <a>node</a> will not always be <a>contained</a>.

  <li><p>However, the <a>descendants</a> of a <a>contained</a> <a>node</a> are <a>contained</a>, and if two <a>siblings</a> are <a>contained</a>, so are any <a>siblings</a> that lie between them.

  <li><p>The first <a>contained</a> <a>node</a> (if there are any) will always be after the <a>start node</a>, and the last <a>contained</a> <a>node</a> will always be equal to or before the <a>end node</a>'s last <a>descendant</a>.

  <li><p>The <a>start node</a> and <a>end node</a> of a <a>range</a> are never <a>contained</a> within it.

  <li><p>There exists a partially contained <a>node</a> if and only if the <a>start node</a> and <a>end node</a> are different.

  <li><p>The <code><a>commonAncestorContainer</a></code> attribute value is neither <a>contained</a> nor <a>partially contained</a>.

  <li>If the <a>start node</a> is an <a>ancestor</a> of the <a>end node</a>, the common <a>inclusive ancestor</a> will be the <a>start node</a>. Exactly one of its <a>children</a> will be <a>partially contained</a>, and a <a>child</a> will be <a>contained</a> if and only if it <a>precedes</a> the <a>partially contained</a> <a>child</a>. If the <a>end node</a> is an <a>ancestor</a> of the <a>start node</a>, the opposite holds.

  <li><p>If the <a>start node</a> is not an <a>inclusive ancestor</a> of the <a>end node</a>, nor vice versa, the common <a>inclusive ancestor</a> will be distinct from both of them. Exactly two of its <a>children</a> will be <a>partially contained</a>, and a <a>child</a> will be contained if and only if it lies between those two.
 </ul>
</div>

<hr>

<dl>

  : <code><var>range</var> = new <a>Range</a>()</code>
  :: Returns a new <a>range</a>.

</dl>

<p>The <dfn><code>Range()</code></dfn> constructor must return a new <a>range</a> with (global object's associated <a>document</a>, 0) as its <a>start</a> and <a>end</a>.

<hr>

<dl>

  : <var>node</var> = <var>range</var> . <code><a>startContainer</a></code>
  :: Returns <var>range</var>'s <a>start node</a>.

  : <var>offset</var> = <var>range</var> . <code><a>startOffset</a></code>
  :: Returns <var>range</var>'s <a>start offset</a>.

  : <var>node</var> = <var>range</var> . <code><a>endContainer</a></code>
  :: Returns <var>range</var>'s <a>end node</a>.

  : <var>offset</var> = <var>range</var> . <code><a>endOffset</a></code>
  :: Returns <var>range</var>'s <a>end offset</a>.

  : <var>collapsed</var> = <var>range</var> . <code><a>collapsed</a></code>
  :: Returns true if <var>range</var>'s <a>start</a> and <a>end</a> are the same, and false otherwise.

  : <var>container</var> = <var>range</var> . <code><a>commonAncestorContainer</a></code>
  :: Returns the <a>node</a>, furthest away from the <a>document</a>, that is an <a>ancestor</a> of both <var>range</var>'s <a>start node</a> and <a>end node</a>.

</dl>

<p>The <dfn><code>startContainer</code></dfn> attribute must return the <a>start node</a>.

<p>The <dfn><code>startOffset</code></dfn> attribute must return the <a>start offset</a>.

<p>The <dfn><code>endContainer</code></dfn> attribute must return the <a>end node</a>.

<p>The <dfn><code>endOffset</code></dfn> attribute must return the <a>end offset</a>.

<p>The <dfn><code>collapsed</code></dfn> attribute must return true if <a>start</a> is the same as <a>end</a>, and false otherwise.

<p>The <dfn><code>commonAncestorContainer</code></dfn> attribute must run these steps:

<ol>
  1. Let <var>container</var> be <a>start node</a>.

  2. While <var>container</var> is not an <a>inclusive ancestor</a> of <a>end node</a>, let <var>container</var> be <var>container</var>'s <a>parent</a>.

  3. Return <var>container</var>.

</ol>

<hr>

<p>To <dfn lt="set the start|set the end">set the start or end</dfn> of a <var>range</var> to a <a>boundary point</a> (<var>node</var>, <var>offset</var>), run these steps:

<ol>
  <li>If <var>node</var> is a <a>doctype</a>, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]

  <li>If <var>offset</var> is greater than <var>node</var>'s <a>length</a>, <a>throw</a> an "<code>IndexSizeError</code>" exception. [[!WEBIDL]]

  <li>Let <var>bp</var> be the <a>boundary point</a> (<var>node</var>, <var>offset</var>).

  <li><dl class="switch"> 
  <dt>If these steps were invoked as "set the start"
   <dd>
    <ol>
     <li><p>If <var>bp</var> is <a>after</a> the <var>range</var>'s <a>end</a>, or if <var>range</var>'s <a href="#range-root">root</a> is not equal to <var>node</var>'s <a href="#tree-root">root</a>, set <var>range</var>'s <a>end</a> to <var>bp</var>.

     <li><p>Set <var>range</var>'s <a>start</a> to <var>bp</var>.
    </ol>
   <dt>If these steps were invoked as "set the end"
   <dd>
    <ol>
     <li><p>If <var>bp</var> is <a>before</a> the <var>range</var>'s <a>start</a>, or if <var>range</var>'s <a href="#range-root">root</a> is not equal to <var>node</var>'s <a href="#tree-root">root</a>, set <var>range</var>'s <a>start</a> to <var>bp</var>.

     <li><p>Set <var>range</var>'s <a>end</a> to <var>bp</var>.
    </ol>
  </dl>
</ol>

<p>The
<dfn><code>setStart(<var>node</var>, <var>offset</var>)</code></dfn> method must <a>set the start</a> of the <a>context object</a> to <a>boundary point</a> (<var>node</var>, <var>offset</var>).

<p>The <dfn><code>setEnd(<var>node</var>, <var>offset</var>)</code></dfn> method must <a>set the end</a> of the <a>context object</a> to <a>boundary point</a> (<var>node</var>, <var>offset</var>).

<p>The <dfn><code>setStartBefore(<var>node</var>)</code></dfn> method must run these steps:

<ol>
  1. Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

  2. If <var>parent</var> is null, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]

  3. <a>Set the start</a> of the <a>context object</a> to <a>boundary point</a> (<var>parent</var>, <var>node</var>'s <a>index</a>).

</ol>

<p>The <dfn><code>setStartAfter(<var>node</var>)</code></dfn> method must run these steps:

<ol>
  1. Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

  2. If <var>parent</var> is null, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]

  3. <a>Set the start</a> of the <a>context object</a> to <a>boundary point</a> (<var>parent</var>, <var>node</var>'s <a>index</a> plus one).

</ol>

<p>The <dfn><code>setEndBefore(<var>node</var>)</code></dfn> method must run these steps:

<ol>
  1. Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

  2. If <var>parent</var> is null, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]

  3. <a>Set the end</a> of the <a>context object</a> to <a>boundary point</a> (<var>parent</var>, <var>node</var>'s <a>index</a>).

</ol>

<p>The <dfn><code>setEndAfter(<var>node</var>)</code></dfn> method must run these steps:

<ol>
  1. Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

  2. If <var>parent</var> is null, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]

  3. <a>Set the end</a> of the <a>context object</a> to <a>boundary point</a> (<var>parent</var>, <var>node</var>'s <a>index</a> plus one).

</ol>

<p>The <dfn><code>collapse(<var>toStart</var>)</code></dfn> method, when invoked, must if <var>toStart</var> is true, set <a>end</a> to <a>start</a>, and set <a>start</a> to <a>end</a> otherwise.

<p>To <dfn lt="range select|select">select</dfn> a <a>node</a> <var>node</var> within a <a>range</a> <var>range</var>, run these steps:

<ol>
  1. Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

  2. If <var>parent</var> is null, <a>throw</a> an "<code>InvalidNodeTypeError</code>". [[!WEBIDL]]

  3. Let <var>index</var> be <var>node</var>'s <a>index</a>.

  4. Set <var>range</var>'s <a>start</a> to <a>boundary point</a> (<var>parent</var>, <var>index</var>).

  5. Set <var>range</var>'s <a>end</a> to <a>boundary point</a> (<var>parent</var>, <var>index</var> plus one).

</ol>

<p>The <dfn><code>selectNode(<var>node</var>)</code></dfn> method must <a>select</a> <var>node</var> within <a>context object</a>.

<p>The <dfn><code>selectNodeContents(<var>node</var>)</code></dfn> method must run these steps:

<ol>
  1. If <var>node</var> is a <a>doctype</a>, <a>throw</a> an "<code>InvalidNodeTypeError</code>". [[!WEBIDL]]

  2. Let <var>length</var> be the <a>length</a> of <var>node</var>.

  3. Set <a>start</a> to the <a>boundary point</a> (<var>node</var>, 0).

  4. Set <a>end</a> to the <a>boundary point</a> (<var>node</var>, <var>length</var>).

</ol>

<hr>

<p>The <dfn><code>compareBoundaryPoints(<var>how</var>, <var>sourceRange</var>)</code></dfn> method must run these steps:

<ol>
  <li>If <var>how</var> is not one of <ul>
   <li><code><a>START_TO_START</a></code>,
   <li><code><a>START_TO_END</a></code>,
   <li><code><a>END_TO_END</a></code>, and
   <li><code><a>END_TO_START</a></code>,
  </ul>
  <p><a>throw</a> a "<code>NotSupportedError</code>" exception. [[!WEBIDL]]
 <li><p>If <a>context object</a>'s <a href="#range-root">root</a> is not the same as <var>sourceRange</var>'s <a href="#range-root">root</a>, <a>throw</a> a "<code>WrongDocumentError</code>" exception. [[!WEBIDL]]

 <li>
  <p>If <var>how</var> is:
  <dl class="switch">
   <dt><code><a>START_TO_START</a></code>:
   <dd>
    <p>Let <var>this point</var> be the <a>context object</a>'s <a>start</a>.
    <p>Let <var>other point</var> be <var>sourceRange</var>'s <a>start</a>.

   <dt><code><a>START_TO_END</a></code>:
   <dd>
    <p>Let <var>this point</var> be the <a>context object</a>'s <a>end</a>.
    <p>Let <var>other point</var> be <var>sourceRange</var>'s <a>start</a>.

    <dt><code><a>END_TO_END</a></code>:
    <dd>
     <p>Let <var>this point</var> be the <a>context object</a>'s <a>end</a>.
     <p>Let <var>other point</var> be <var>sourceRange</var>'s <a>end</a>.

    <dt><code><a>END_TO_START</a></code>:
    <dd>
     <p>Let <var>this point</var> be the <a>context object</a>'s <a>start</a>.
     <p>Let <var>other point</var> be <var>sourceRange</var>'s <a>end</a>.
   </dl>

  <li>
   <p>If the <a>position</a> of <var>this point</var> relative to <var>other point</var> is

   <dl class="switch">
    <dt><a>before</a>
    <dd>Return −1.

    <dt><a>equal</a>
    <dd>Return 0.

    <dt><a>after</a>
    <dd>Return 1.
   </dl>
</ol>

<p>The <dfn><code>deleteContents()</code></dfn>method must run these steps:

<ol>
 <li><p>If <a>start</a> is <a>end</a>, terminate these steps.
 <!-- This might actually make no difference, but it's not immediately
 obvious what would happen otherwise if the start/end were text/comment:
 are all the substeps of the next step actually no-ops, or could some have
 side effects? -->

 <li><p>Let <var>original start node</var>, <var>original start offset</var>, <var>original end node</var>, and <var>original end offset</var> be the <a>context object</a>'s <a>start node</a>, <a>start offset</a>, <a>end node</a>, and <a>end offset</a>, respectively.

 <li><p>If <var>original start node</var> and <var>original end node</var> are the same, and they are a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>, <a>replace data</a> with node <var>original start node</var>, offset <var>original start offset</var>, count <var>original end offset</var> minus <var>original start offset</var>, and data the empty string, and then terminate these steps.

 <li><p>Let <var>nodes to remove</var> be a list of all the <a>nodes</a> that are <a>contained</a> in the <a>context object</a>, in <a>tree order</a>, omitting any <a>node</a> whose <a>parent</a> is also <a>contained</a> in the <a>context object</a>.

 <li><p>If <var>original start node</var> is an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>new node</var> to <var>original start node</var> and <var>new offset</var> to <var>original start offset</var>.

 <li>
  <p>Otherwise:
  <ol>
   <li><p>Let <var>reference node</var> equal
   <var>original start node</var>.

   <li><p>While <var>reference node</var>'s <a>parent</a> is not null and is not an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>reference node</var> to its <a>parent</a>.

   <li>
    <p>Set <var>new node</var> to the <a>parent</a> of <var>reference node</var>, and <var>new offset</var> to one plus the <a>index</a> of <var>reference node</var>.

    <p class="note">Note: If <var>reference node</var>'s <a>parent</a> were null, it would be the <a href="#range-root">root</a> of the <a>context object</a>, so would be an <a>inclusive ancestor</a> of <var>original end node</var>, and we could not reach this point.
  </ol>

 <li><p>If <var>original start node</var> is a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>, <a>replace data</a> with node <var>original start node</var>, offset <var>original start offset</var>, count <var>original start node</var>'s <a>length</a> minus <var>original start offset</var>, data the empty string.

 <li><p>For each <var>node</var> in <var>nodes to remove</var>, in <a>tree order</a>, <a>remove</a> <var>node</var> from its <a>parent</a>.

 <li><p>If <var>original end node</var> is a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>, <a>replace data</a> with node <var>original end node</var>, offset 0, count <var>original end offset</var> and data the empty string.

 <li><p>Set <a>start</a> and <a>end</a> to (<var>new node</var>, <var>new offset</var>).
</ol>

<p>To <dfn lt="range extract|extract">extract</dfn> a <a>range</a> <var>range</var>, run these steps:

<ol>
 <li><p>Let <var>fragment</var> be a new <code><a>DocumentFragment</a></code> <a>node</a> whose <a>node document</a> is <var>range</var>'s <a>start node</a>'s <a>node document</a>.

 <li><p>If <var>range</var>'s <a>start</a> is its <a>end</a>, return <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li><p>Let <var>original start node</var>, <var>original start offset</var>, <var>original end node</var>, and <var>original end offset</var> be <var>range</var>'s <a>start node</a>, <a>start offset</a>, <a>end node</a>, and <a>end offset</a>, respectively.

 <li>
  <p>If <var>original start node</var> is <var>original end node</var>, and they are a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>:

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>original start node</var>.

   <li><p>Set the <a>data</a> of <var>clone</var> to the result of <a>substringing data</a> with node <var>original start node</var>, offset <var>original start offset</var>, and count <var>original end offset</var> minus <var>original start offset</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p><a>Replace data</a> with node <var>original start node</var>, offset <var>original start offset</var>, count <var>original end offset</var> minus <var>original start offset</var>, and data the empty string.

   <li><p>Return <var>fragment</var>.
  </ol>

 <li><p>Let <var>common ancestor</var> be <var>original start node</var>.

 <li><p>While <var>common ancestor</var> is not an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>common ancestor</var> to its own <a>parent</a>.

 <li><p>Let <var>first partially contained child</var> be null.

 <li><p>If <var>original start node</var> is <em>not</em> an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>first partially contained child</var> to the first <a>child</a> of <var>common ancestor</var> that is <a>partially contained</a> in <var>range</var>.

 <li><p>Let <var>last partially contained child</var> be null.

 <li>
  <p>If <var>original end node</var> is <em>not</em> an <a>inclusive ancestor</a> of <var>original start node</var>, set <var>last partially contained child</var> to the last <a>child</a> of <var>common ancestor</var> that is <a>partially contained</a> in <var>range</var>.

  <p class="note">Note: These variable assignments do actually always make sense. For instance, if <var>original start node</var> is not an <a>inclusive ancestor</a> of <var>original end node</var>, <var>original start node</var> is itself <a>partially contained</a> in <var>range</var>, and so are all its <a>ancestors</a> up until a <a>child</a> of <var>common ancestor</var>. <var>common ancestor</var> cannot be <var>original start node</var>, because it has to be an <a>inclusive ancestor</a> of <var>original end node</var>. The other case is similar. Also, notice that the two <a>children</a> will never be equal if both are defined.

 <li><p>Let <var>contained children</var> be a list of all <a>children</a> of <var>common ancestor</var> that are <a>contained</a> in <var>range</var>, in <a>tree order</a>.

 <li>
  <p>If any member of <var>contained children</var> is a <a>doctype</a>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>" exception.
  <!-- Firefox 4.0 actually removes the non-DocumentType nodes before
  throwing the exception. Opera 11.00 removes the DocumentType too, and
  doesn't throw. I go with IE9 and Chrome 12 dev, which don't remove any
  nodes. DOM 2 Range doesn't specify what exactly happens here, except that
  an exception should be thrown. -->

  <p class="note">Note: We do not have to worry about the first or last partially contained node, because a <a>doctype</a> can never be partially contained. It cannot be a boundary point of a range, and it cannot be the ancestor of anything.

 <li><p>If <var>original start node</var> is an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>new node</var> to <var>original start node</var> and <var>new offset</var> to <var>original start offset</var>.

 <li>
  <p>Otherwise:
  <ol>
   <li><p>Let <var>reference node</var> equal <var>original start node</var>.

   <li><p>While <var>reference node</var>'s <a>parent</a> is not null and is not an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>reference node</var> to its <a>parent</a>.

   <li>
    <p>Set <var>new node</var> to the <a>parent</a> of <var>reference node</var>, and <var>new offset</var> to one plus <var>reference node</var>'s <a>index</a>.

    <p class="note">Note: If <var>reference node</var>'s <a>parent</a> is null, it would be the <a href="#range-root">root</a> of <var>range</var>, so would be an <a>inclusive ancestor</a> of <var>original end node</var>, and we could not reach this point.
  </ol>

  <!-- Now we start with mutations, so we can't refer to the context object
  anymore unless we carefully consider how it will have mutated. -->

 <li>
  <p>If <var>first partially contained child</var> is a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>:

  <p class="note">Note: In this case, <var>first partially contained child</var> is <var>original start node</var>.

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>original start node</var>.

   <li><p>Set the <a>data</a> of <var>clone</var> to the result of <a>substringing data</a> with node <var>original start node</var>, offset <var>original start offset</var>, and count <var>original start node</var>'s <a>length</a> minus <var>original start offset</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p><a>Replace data</a> with node <var>original start node</var>, offset <var>original start offset</var>, count <var>original start node</var>'s <a>length</a> minus <var>original start offset</var>, and data the empty string.
  </ol>

 <li>
  <p>Otherwise, if <var>first partially contained child</var> is not null:

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>first partially contained child</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p>Let <var>subrange</var> be a new <a>range</a> whose <a>start</a> is (<var>original start node</var>, <var>original start offset</var>) and whose <a>end</a> is (<var>first partially contained child</var>, <var>first partially contained child</var>'s <a>length</a>).

   <li><p>Let <var>subfragment</var> be the result of <a>extracting</a> <var>subrange</var>.

   <li><p><a>Append</a> <var>subfragment</var> to <var>clone</var>.
  </ol>

 <li><p>For each <var>contained child</var> in <var>contained children</var>, <a>append</a> <var>contained child</var> to <var>fragment</var>.

 <li>
  <p>If <var>last partially contained child</var> is a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>:

  <p class="note">Note: In this case, <var>last partially contained child</var> is <var>original end node</var>.

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>original end node</var>.

   <li><p>Set the <a>data</a> of <var>clone</var> to the result of <a>substringing data</a> with node <var>original end node</var>, offset 0, and count <var>original end offset</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p><a>Replace data</a> with node <var>original end node</var>, offset 0, count <var>original end offset</var>, and data the empty string.
  </ol>

 <li>
  <p>Otherwise, if <var>last partially contained child</var> is not null:

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>last partially contained child</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p>Let <var>subrange</var> be a new <a>range</a> whose <a>start</a> is (<var>last partially contained child</var>, 0) and whose <a>end</a> is (<var>original end node</var>, <var>original end offset</var>).

   <li><p>Let <var>subfragment</var> be the result of <a>extracting</a> <var>subrange</var>.

   <li><p><a>Append</a> <var>subfragment</var> to <var>clone</var>.
  </ol>

 <li><p>Set <var>range</var>'s <a>start</a> and <a>end</a> to (<var>new node</var>, <var>new offset</var>).

 <li><p>Return <var>fragment</var>.
</ol>

<p>The <dfn><code>extractContents()</code></dfn> method must return the result of <a>extracting</a> <a>context object</a>.

<p>To <dfn lt="range clone|clone">clone</dfn> a <a>range</a> <var>range</var>, run these steps:

<ol>
 <li><p>Let <var>fragment</var> be a new <code><a>DocumentFragment</a></code> <a >node</a> whose <a>node document</a> is <var>range</var>'s <a>start node</a>'s <a>node document</a>.

 <li><p>If <var>range</var>'s <a>start</a> is its <a>end</a>, return <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li><p>Let <var>original start node</var>, <var>original start offset</var>, <var>original end node</var>, and <var>original end offset</var> be <var>range</var>'s <a>start node</a>, <a>start offset</a>, <a>end node</a>, and <a>end offset</a>, respectively.

 <li>
  <p>If <var>original start node</var> is <var>original end node</var>, and they are a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>:

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>original start node</var>.

   <li><p>Set the <a>data</a> of <var>clone</var> to the result of <a>substringing data</a> with node <var>original start node</var>, offset <var>original start offset</var>, and count <var>original end offset</var> minus <var>original start offset</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p>Return <var>fragment</var>.
  </ol>

 <li><p>Let <var>common ancestor</var> be <var>original start node</var>.

 <li><p>While <var>common ancestor</var> is not an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>common ancestor</var> to its own <a>parent</a>.

 <li><p>Let <var>first partially contained child</var> be null.

 <li><p>If <var>original start node</var> is <em>not</em> an <a>inclusive ancestor</a> of <var>original end node</var>, set <var>first partially contained child</var> to the first <a>child</a> of <var>common ancestor</var> that is <a>partially contained</a> in <var>range</var>.

 <li><p>Let <var>last partially contained child</var> be null.

 <li>
  <p>If <var>original end node</var> is <em>not</em> an <a>inclusive ancestor</a> of <var>original start node</var>, set <var>last partially contained child</var> to the last <a>child</a> of <var>common ancestor</var> that is <a>partially contained</a> in <var>range</var>.

  <p class="note">Note: These variable assignments do actually always make sense. For instance, if <var>original start node</var> is not an <a>inclusive ancestor</a> of <var>original end node</var>, <var>original start node</var> is itself <a>partially contained</a> in <var>range</var>, and so are all its <a>ancestors</a> up until a <a>child</a> of <var>common ancestor</var>. <var>common ancestor</var> cannot be <var>original start node</var>, because it has to be an <a>inclusive ancestor</a> of <var>original end node</var>. The other case is similar. Also, notice that the two <a>children</a> will never be equal if both are defined.

 <li><p>Let <var>contained children</var> be a list of all <a>children</a> of <var>common ancestor</var> that are <a>contained</a> in <var>range</var>, in <a>tree order</a>.

 <li>
  <p>If any member of <var>contained children</var> is a <a>doctype</a>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>" exception.

  <p class="note">Note: We do not have to worry about the first or last partially contained node, because a <a>doctype</a> can never be
  partially contained. It cannot be a boundary point of a range, and it
  cannot be the ancestor of anything.

 <li>
  <p>If <var>first partially contained child</var> is a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>:

  <p class="note">Note: In this case, <var>first partially contained child</var> is <var>original start node</var>.

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>original start node</var>.

   <li><p>Set the <a>data</a> of <var>clone</var> to the result of <a>substringing data</a> with node <var>original start node</var>, offset <var>original start offset</var>, and count <var>original start node</var>'s <a>length</a> minus <var>original start offset</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.
  </ol>

 <li>
  <p>Otherwise, if <var>first partially contained child</var> is not null:

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>first partially contained child</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p>Let <var>subrange</var> be a new <a>range</a> whose <a>start</a> is (<var>original start node</var>, <var>original start offset</var>) and whose <a>end</a> is (<var>first partially contained child</var>, <var>first partially contained child</var>'s <a>length</a>).

   <li><p>Let <var>subfragment</var> be the result of <a>cloning</a> <var>subrange</var>.

   <li><p><a>Append</a> <var>subfragment</var> to <var>clone</var>.
  </ol>

 <li>
  <p>For each <var>contained child</var> in <var>contained children</var>:

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>contained child</var> with the <i>clone children flag</i> set.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.
  </ol>

 <li>
  <p>If <var>last partially contained child</var> is a <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>:

  <p class="note">Note: In this case, <var>last partially contained child</var> is <var>original end node</var>.

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>original end node</var>.

   <li><p>Set the <a>data</a> of <var>clone</var> to the result of <a>substringing data</a> with node <var>original end node</var>, offset 0, and count <var>original end offset</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.
  </ol>

 <li>
  <p>Otherwise, if <var>last partially contained child</var> is not null:

  <ol>
   <li><p>Let <var>clone</var> be a <a>clone</a> of <var>last partially contained child</var>.

   <li><p><a>Append</a> <var>clone</var> to <var>fragment</var>.

   <li><p>Let <var>subrange</var> be a new <a>range</a> whose <a>start</a> is (<var>last partially contained child</var>, 0) and whose <a>end</a> is (<var>original end node</var>, <var>original end offset</var>).

   <li><p>Let <var>subfragment</var> be the result of <a>cloning</a> <var>subrange</var>.

   <li><p><a>Append</a> <var>subfragment</var> to <var>clone</var>.
  </ol>

 <li><p>Return <var>fragment</var>.
</ol>

<p>The <dfn><code>cloneContents()</code></dfn> method must return the result of <a>cloning</a> <a>context object</a>.

<p>To <dfn lt="range insert|insert">insert</dfn> a <a>node</a> <var>node</var> into a <a>range</a> <var>range</var>, run these steps:

<ol>
  <!-- Chrome 12 dev throws "HierarchyRequestError" if node is the same
  as the start node (at least for text nodes). This doesn't seem to make
  much sense, since insertBefore() works fine to move a node to its current
  position, and other browsers disagree, so the spec follows the majority.
  -->
 <li><p>If <var>range</var>'s <a>start node</a> is either a <code><a>ProcessingInstruction</a></code> or <code><a>Comment</a></code> <a>node</a>, or a <code><a>Text</a></code> <a>node</a> whose <a>parent</a> is null, <a>throw</a> an "<code><a>HierarchyRequestError</a></code>" exception. [[!WEBIDL]]

 <!--
 Behavior for Text node with null parent:

 IE9: Allows it to go through, resulting in the text/comment node having a non-null previousSibling but a null parentNode. (?!)
 Firefox 4.0: Throws non-standard exception
 Chrome 12 dev: Throws "HierarchyRequestError"
 Opera 11.00: Doesn't come up, doesn't allow ranges on detached nodes

 IE is clearly crazy, and non-standard exceptions are no good, so we go with
 WebKit.

 For a Comment node, see https://www.w3.org/Bugs/Public/show_bug.cgi?id=15350.
 IE9, Firefox 12.0a1, and Chrome 17 dev all agree on throwing a
 HierarchyRequestError.  Opera Next 12.00 alpha splits the comment, same as a
 text node.
 -->
 <li><p>Let <var>referenceNode</var> be null.

 <li><p>If <var>range</var>'s <a>start node</a> is a <code><a>Text</a></code> <a>node</a>, set <var>referenceNode</var> to that <code><a>Text</a></code> <a>node</a>. <!-- This will change when we split it. -->

 <li><p>Otherwise, set <var>referenceNode</var> to the <a>child</a> of <a>start node</a> whose <a>index</a> is <a>start offset</a>, and null if there is no such <a>child</a>.

 <li><p>Let <var>parent</var> be <var>range</var>'s <a>start node</a> if <var>referenceNode</var> is null, and <var>referenceNode</var>'s <a>parent</a> otherwise.

 <!-- IE9 and Chrome 12 dev throw an exception before splitting the text
 node if the insertBefore() is going to throw an exception (at least if the
 new node is the parent of the start node, for instance). Firefox 4.0 and
 Opera 11.00 don't.  Now that we have "ensure pre-insertion validity," we go
 with the IE/Chrome behavior because it's more correct.

 IE9 doesn't call splitText() if the offset is 0. This makes sense, but I go
 with what all other browsers do. -->
 <li><p><a>Ensure pre-insertion validity</a>of <var>node</var> into <var>parent</var> before <var>referenceNode</var>.

 <li><p>If <var>range</var>'s <a>start node</a> is a <code><a>Text</a></code> <a>node</a>, <a>split</a> it with offset <var>range</var>'s <a>start offset</a>, set <var>referenceNode</var> to the result, and set <var>parent</var> to <var>referenceNode</var>'s <a>parent</a>.

 <li><p>If <var>node</var> is <var>referenceNode</var>, set <var>referenceNode</var> to its <a>next sibling</a>. <!-- Because we're
 about to remove node from its parent. -->

 <li><p>If <var>node</var>'s <a>parent</a> is not null, <a>remove</a> <var>node</var> from its <a>parent</a>.

 <!-- Browsers disagree on how to handle the case where the range is
 collapsed: do you increment the end offset so the node is now included, or
 not?  DOM 2 Range says no, and Firefox 12.0a1 follows that, but IE9, Chrome
 17 dev, and Opera Next 12.00 alpha all do increment.  Apparently this
 traces back to Acid3 at one point requiring the non-standard behavior.
 Previously the spec matched DOM 2 Range, but it changed to match the
 majority of browsers.  See
 https://www.w3.org/Bugs/Public/show_bug.cgi?id=15297.

 We have to be careful here, because if node is a DocumentFragment, we might
 have inserted any number of nodes, including zero.  One corner case is if
 we insert an empty DocumentFragment and the range is collapsed in a text
 node.  In that case, the text node gets split, but browsers disagree on
 what to do with the range's end.  IE9 leaves it in place; Chrome 17 dev
 moves it to the parent element, before the reference node; Opera Next 12.00
 alpha moves it to the beginning of the new text node.  The spec follows
 WebKit just because it happens to be easier for me to spec.

 The logic for how much to increment the position by is copied from the
 "insert" algorithm.  Getting the new offset right was surprisingly tricky.
 -->
 <li><p>Let <var>newOffset</var> be <var>parent</var>'s <a>length</a> if <var>referenceNode</var> is null, and <var>referenceNode</var>'s <a>index</a> otherwise.

 <li><p>Increase <var>newOffset</var> by <var>node</var>'s <a>length</a> if <var>node</var> is a <code><a>DocumentFragment</a></code> <a>node</a>, and one otherwise.

 <li><p><a>Pre-insert</a> <var>node</var> into <var>parent</var> before <var>referenceNode</var>.

 <li><p>If <var>range</var>'s <a>start</a> and <a>end</a> are the same, set <var>range</var>'s <a>end</a> to (<var>parent</var>, <var>newOffset</var>).
</ol>

<p>The <dfn><code>insertNode(<var>node</var>)</code></dfn> method must <a>insert</a> <var>node</var> into <a>context object</a>.

<p>The <dfn><code>surroundContents(<var>newParent</var>)</code></dfn> method must run these steps:

<!--
IE9 and Chrome 12 dev throw exceptions before doing any DOM mutations in at
least some cases, so they don't wind up modifying the DOM halfway. Like if you
try surrounding a selection with an ancestor. As with insertNode(), this is
slightly nicer, but Firefox 4.0 and Opera 11.00 don't do this, and their
behavior is slightly easier to spec, so I go with them for exceptions that are
thrown by things we call, like insertNode(). However, for
BAD_BOUNDARYPOINTS_ERR/INVALID_NODE_TYPE_ERR that we throw ourselves, I do the
check first thing, which matches everyone but Firefox.
-->

<ol>
 <li><p>If a non-<code><a>Text</a></code> <a>node</a> is <a>partially contained</a> in the <a>context object</a>, <a>throw</a> an "<code><a>InvalidStateError</a></code>" exception. [[!WEBIDL]]
 <!-- Makes some sense: otherwise we'd clone a bunch of containers, which is
 unexpected. -->
 <!-- XXX Could we rephrase this condition to be more algorithmic and less
 declarative?-->

 <li><p>If <var>newParent</var> is a <code><a>Document</a></code>, <code><a>DocumentType</a></code>, or <code><a>DocumentFragment</a></code> <a>node</a>, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]
 <!-- But for Comment, Text, and ProcessingInstruction, we just fall through
 and throw a HIERARCHY_REQUEST_ERR when we try appendChild(). This makes
 absolutely no sense, but it's what DOM 2 Range specifies, and it's what
 IE9, Chrome 12 dev, and Opera 11.00 implement. Firefox 4.0 only throws
 INVALID_NODE_TYPE_ERR on DocumentFragments, it falls through to
 HIERARCHY_REQUEST_ERR for Documents and DocumentTypes.

 Firefox 4.0 does this check later on, so it will do DOM mutations of some
 type if passed a DocumentFragment. We match IE9, Chrome 12 dev, and Opera
 11.00 in doing the check early.

 If newParent is a Document/DocumentType/DocumentFragment, and some node is
 also partially contained, DOM 2 Range doesn't say whether to throw
 BAD_BOUNDARYPOINTS_ERR or INVALID_NODE_TYPE_ERR. IE9 and Chrome 12 dev
 throw INVALID_NODE_TYPE_ERR, while Firefox 4.0 and Opera 11.00 throw
 BAD_BOUNDARYPOINTS_ERR. I chose the latter because it's the first thing I
 happened to write down and it makes no real difference, with the even
 split. -->

 <li><p>Let <var>fragment</var> be the result of
 <a>extracting</a> <a>context object</a>.
 <!-- If the range contains a DocumentType, Firefox 4.0 and Opera 11.00 don't
 immediately throw here. Firefox removes the non-DocumentType nodes and
 throws, Opera removes all nodes and doesn't throw. This applies to
 extractContents() proper, and also affects surroundContents(). I match DOM 2
 Range, IE9, and Chrome 12 dev. -->

 <li><p>If <var>newParent</var> has <a>children</a>, <a>replace all</a> with null within <var>newParent</var>.

 <li><p><a>Insert</a> <var>newParent</var> into <a>context object</a>.

 <li><p><a>Append</a> <var>fragment</var> to <var>newParent</var>.

 <li><p><a>Select</a> <var>newParent</var> within <a>context object</a>.
 <!-- Generally this isn't needed, because insertNode() will already do it,
 but it makes a difference in at least one corner case (when the original
 range lies in a single text node). -->
</ol>

<p>The <dfn><code>cloneRange()</code></dfn> method must return a new <a>range</a> with the same <a>start</a> and <a>end</a> as the <a>context object</a>.

<p>The <dfn id="range-detach-func" for="range"><code>detach()</code></dfn> method must do nothing. <span class="note">Note: Its functionality (disabling a <code><a>Range</a></code> object) was removed, but the method itself is preserved for compatibility.</span>

<hr>

<dl>
 <dt><var>position</var> = <var>range</var> . <code><a>comparePoint</a></code>( <var>parent</var>, <var>offset</var> )
 <dd><p>Returns −1 if the point is before the range, 0 if the point is
 in the range, and 1 if the point is after the range.

 <dt><var>intersects</var> = <var>range</var> . <code><a>intersectsNode</a></code>( <var>node</var> )
 <dd><p>Returns whether <var>range</var> intersects
 <var>node</var>.
</dl>

<div>

<p>The <dfn><code>isPointInRange(<var>node</var>, <var>offset</var>)</code></dfn> must run these steps:
<!-- Tested October 2011 on Firefox 9.0a2 and Chrome 16 dev.  IE9 and Opera
11.50 don't support the method. -->

<ol>
 <li><p>If <var>node</var>'s <a href="#tree-root">root</a> is different from the <a>context object</a>'s <a href="#range-root">root</a>, return false.
 <!-- This happens even if the offset is negative or too large, or if the node
 is a doctype, in both Firefox 9.0a2 and Chrome 16 dev. -->

 <li><p>If <var>node</var> is a <a>doctype</a>, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]

 <li><p>If (<var>node</var>, <var>offset</var>) is <a>before</a> <a>start</a> or <a>after</a> <a>end</a>, return false.

 <li><p>Return true.
</ol>


<p>The <dfn><code>comparePoint(<var>node</var>, <var>offset</var>)</code></dfn> method must run these steps:
<!-- IE9 doesn't support this method at all.  Firefox 12.0a1, Chrome 17 dev,
and Opera Next 12.00 alpha all do. -->

<ol>
 <li><p>If <var>node</var>'s <a href="#tree-root">root</a> is different from the <a>context object</a>'s <a href="#range-root">root</a>, <a>throw</a> a "<code>WrongDocumentError</code>"
 exception. [[!WEBIDL]]
 <!-- Opera Next 12.00 alpha seems to return -1 in this case.  The spec matches
 Firefox 12.0a1 and Chrome 17 dev. -->

 <li><p>If <var>node</var> is a <a>doctype</a>, <a>throw</a> an "<code>InvalidNodeTypeError</code>" exception. [[!WEBIDL]]
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00 alpha, which don't throw and seem to just ignore the offset instead.  See
 comment for isPointInRange(). -->

 <li><p>If <var>offset</var> is greater than <var>node</var>'s <a>length</a>, <a>throw</a> an "<code><a>IndexSizeError</a></code>" exception. [[!WEBIDL]]
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00
 alpha, which don't throw.  See comment for isPointInRange(). -->

 <li><p>If (<var>node</var>, <var>offset</var>) is <a>before</a> <a>start</a>, return −1.

 <li><p>If (<var>node</var>, <var>offset</var>) is <a>after</a> <a>end</a>, return 1.

 <li><p>Return 0.
</ol>

<hr>

<p>The <dfn><code>intersectsNode(<var>node</var>)</code></dfn> method must run these steps:
<!-- Supported by Chrome 17 dev and Opera Next 12.00 alpha, but not IE9 or
Firefox 12.0a1. -->

<ol>
 <li><p>If <var>node</var>'s <a href="#tree-root">root</a> is different from the <a>context object</a>'s <a href="#range-root">root</a>, return false.
 <!-- It seems like for doctypes, Opera Next 12.00 alpha throws
 InvalidNodeTypeError instead of returning false.  The spec follows Chrome
 17 dev. -->

 <li><p>Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

 <li><p>If <var>parent</var> is null, return true.
 <!-- browsers currently throw, but are willing to change
      https://www.w3.org/Bugs/Public/show_bug.cgi?id=16759 -->

 <li><p>Let <var>offset</var> be <var>node</var>'s <a>index</a>.

 <li><p>If (<var>parent</var>, <var>offset</var>) is <a>before</a> <a>end</a> and (<var>parent</var>, <var>offset</var> + 1) is <a>after</a> <a>start</a>, return true.

 <li><p>Return false.
</ol>

</div>

<hr>

<p>The <dfn id="range-stringifier">stringifier</dfn> must run these steps:

<ol>
 <li><p>Let <var>s</var> be the empty string.

 <li><p>If <a>start node</a> is <a>end node</a>, and it is a <code><a>Text</a></code> <a>node</a>, return the substring of that <code><a>Text</a></code> <a>node</a>'s <a>data</a> beginning at <a>start offset</a> and ending at <a>end offset</a>.

 <li><p>If <a>start node</a> is a <code><a>Text</a></code> <a>node</a>, append to <var>s</var> the substring of that <a>node</a>'s <a>data</a> from the <a>start offset</a> until the end.

 <li><p>Append to <var>s</var> the concatenation, in <a>tree order</a>, of the <a>data</a> of all <code><a>Text</a></code> <a>nodes</a> that are <a>contained</a> in the <a>context object</a>.

 <li><p>If <a>end node</a> is a <code><a>node</a></code>, append to <var>s</var> the substring of that <a>node</a>'s <a>data</a> from its start until the <a>end offset</a>.

 <li><p>Return <var>s</var>.
</ol>

<hr>

<p class="note">Note: The <code><a href="http://www.w3.org/TR/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment">createContextualFragment()</a></code>, <code><a href="https://www.w3.org/TR/cssom-view-1/#dom-element-getclientrects">getClientRects()</a></code>, and <code><a href="https://www.w3.org/TR/cssom-view-1/#dom-element-getboundingclientrect">getBoundingClientRect()</a></code> methods are defined in other specifications.[[DOM-PARSING]][[CSSOM-VIEW-1]]

</section>
