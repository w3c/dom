<section>
<h2 id=events>Events</h2>

<h3 id=introduction-to-dom-events>Introduction to "DOM Events"</h3>

<p>Throughout the web platform <a>events</a> are <a>dispatched</a> to objects to signal an occurrence, such as network activity or user interaction. These objects implement the {{EventTarget}} interface and can therefore add <a>event listeners</a> to observe <a>events</a> by calling <a>addEventListener()</a>:

<pre class='example'><code>obj.addEventListener("load", imgFetched)

function imgFetched(ev) {
  // great success
  …
}</code></pre>

<p><a>Event listeners</a> can be removed by utilizing the <code><a>removeEventListener()</a></code> method, passing the same arguments.

<p><a>Events</a> are objects too and implement the <code><a>Event</a></code> interface (or a derived interface). In the example above <var ignore>ev</var> is the <a>event</a>. It is passed as argument to <a>event listener</a>'s <b>callback</b> (typically a JavaScript Function as shown above).

<a>Event listeners</a> key off the <a>event</a>'s {{Event/type}} attribute value ("<code>load</code>" in the above example). The <a>event</a>'s <code><a>target</a></code> attribute value returns the object to which the <a>event</a> was <a>dispatched</a> (<var ignore>obj</var> above).

<p>Now while typically <a>events</a> are <a>dispatched</a> by the user agent as the result of user interaction or the completion of some task, applications can <a>dispatch</a> <a>events</a> themselves, commonly known as synthetic events:

<pre class='example'><code>
// add an appropriate event listener
obj.addEventListener("cat", function(e) { process(e.detail) })

// create and dispatch the event
var event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
obj.dispatchEvent(event)</code></pre>

<p>Apart from signaling, <a>events</a> are sometimes also used to let an application control what happens next in an operation. For instance as part of form submission an <a>event</a> whose {{Event/type}} attribute value is "<code>submit</code>" is <a>dispatched</a>. If this <a>event</a>'s <code><a>preventDefault()</a></code> method is invoked, form submission will be terminated. Applications who wish to make use of this functionality through <a>events</a> <a>dispatched</a> by the application (synthetic events) can make use of the return value of the <code><a>dispatchEvent()</a></code> method:

<pre class='example'><code>
if(obj.dispatchEvent(event)) {
  // event was not canceled, time for some magic
  …
}</code></pre>

<p>When an <a>event</a> is <a>dispatched</a> to an object that <a>participates</a> in a <a>tree</a> (e.g. an <a href="#concept-element">element</a>), it can reach <a>event listeners</a> on that object's <a>ancestors</a> too. First all object's <a>ancestor</a> <a>event listeners</a> whose <b>capture</b> variable is set to true are invoked, in <a>tree order</a>. Second, object's own <a>event listeners</a> are invoked. And finally, and only if <a>event</a>'s {{Event/bubbles}} attribute value is true, object's  <a>ancestor</a> <a>event listeners</a> are invoked again, but now in reverse <a>tree order</a>.

<p>Lets look at an example of how <a>events</a> work in a <a>tree</a>:

<pre class='example'><code>&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Boring example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Hello &lt;span id=x&gt;world&lt;/span&gt;!&lt;/p&gt;
  &lt;script&gt;
   function test(e) {
     debug(e.target, e.currentTarget, e.eventPhase)
   }
   document.addEventListener("hey", test, {capture: true})
   document.body.addEventListener("hey", test)
   var ev = new Event("hey", {bubbles:true})
   document.getElementById("x").dispatchEvent(ev)
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>The <code>debug</code> function will be invoked twice. Each time the <a>event</a>'s <code><a>target</a></code> attribute value will be the <code>span</code> <a href="#concept-element">element</a>. The first time {{Event/currentTarget}} attribute's value will be the <a href="#concept-document">document</a>, the second time the <code>body</code> <a href="#concept-element">element</a>. {{Event/eventPhase}} attribute's value switches from {{Event/CAPTURING_PHASE}} to {{Event/BUBBLING_PHASE}}. If an <a>event listener</a> was registered for the <code>span</code> <a href="#concept-element">element</a>, {{Event/eventPhase}} attribute's value would have been {{Event/AT_TARGET}}.

<h3 id=interface-event>Interface {{Event}}</h3>
<pre class='idl'>
[Constructor(DOMString type, optional EventInit eventInitDict),
 Exposed=(Window,Worker)]

interface Event {
  readonly attribute DOMString type;
  readonly attribute EventTarget? target;
  readonly attribute EventTarget? currentTarget;
  sequence&lt;EventTarget> composedPath();

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  attribute boolean cancelBubble;
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;
  readonly attribute boolean composed;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute DOMHighResTimeStamp timeStamp;

  void initEvent(DOMString type, optional boolean bubbles, optional boolean cancelable); // historical
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
  boolean composed = false;
};
</pre>

<p>An {{Event}} object is simply named an <dfn export id=concept-event>event</dfn>. It allows for
signaling that something has occurred, e.g., that an image has completed downloading.</p>

<p>An <a>event</a> has an associated <dfn export for=Event>relatedTarget</dfn> (null or an
{{EventTarget}} object). Unless stated otherwise it is null.</p>

<p class="note">Note: Other specifications use <a>relatedTarget</a> to define a <code>relatedTarget</code>
attribute. [[UIEVENTS]]

<p>An <a>event</a> has an associated <dfn export for=Event>path</dfn>. A <a for=Event>path</a> is a
list of tuples, each of which consists of an <b>item</b> (an {{EventTarget}} object), <b>target</b>
(null or an {{EventTarget}} object), and a <b>relatedTarget</b> (null or an {{EventTarget}}
object). A tuple is formatted as (<b>item</b>, <b>target</b>, <b>relatedTarget</b>). A <a
for=Event>path</a> is initially the empty list.</p>

<p><a lt="Other applicable specifications">Specifications</a> may define
<dfn export for=Event>retargeting steps</dfn> for all or some <a>events</a>.
The algorithm is passed <var>event</var>, as indicated in the <a>dispatch</a>
algorithm below.

<dl>
  : <var ignore>event</var> = new <a>Event</a>(<var>type</var> [, <var>eventInitDict</var>])
  :: <p>Returns a new <var>event</var> whose {{Event/type}} attribute value is set to <var>type</var>. The optional <var>eventInitDict</var> argument allows for setting the {{Event/bubbles}} and {{Event/cancelable}} attributes via object members of the same name.

  : <var>event</var> . {{Event/type}}
  :: <p>Returns the type of <var>event</var>, e.g. "<code>click</code>", "<code>hashchange</code>", or "<code>submit</code>".

  : <var>event</var> . {{Event/target}}
  :: <p>Returns the object to which <var>event</var> is <a>dispatched</a>.

  : <var>event</var> . {{Event/currentTarget}}
  :: <p>Returns the object whose <a>event listener</a>'s <b>callback</b> is currently being invoked.

  : <code><var>event</var> . {{Event/composedPath()}}</code>
  :: Returns the <b>item</b> objects of <var>event</var>'s <a for=Event>path</a> (objects on which listeners will be invoked), except for any <a>nodes</a> in <a>shadow trees</a> of which the <a for=/>shadow root</a>'s <a for=ShadowRoot>mode</a> is "<code>closed</code>" that are not reachable from <var>event</var>'s {{Event/currentTarget}}.

  : <code><var>event</var> . {{Event/eventPhase}}</code>
  :: <p>Returns the <a>event</a>'s phase, which is one of <code>{{Event/NONE}}</code>, <code title="dom-Event-CAPTURING_PHASE">{{Event/CAPTURING_PHASE}}</code>, <code>{{Event/AT_TARGET}}</code>, and <code>{{Event/BUBBLING_PHASE}}</code>.

  : <var>event</var> . {{Event/stopPropagation()}}
  :: <p>When <a>dispatched</a> in a <a>tree</a>, invoking this method prevents <var>event</var> from reaching any objects other than the current object.

  : <var>event</var> . {{Event/stopImmediatePropagation()}}
  :: <p>Invoking this method prevents <var>event</var> from reaching any registered <a>event listeners</a> after the current one finishes running and, when <a>dispatched</a> in a <a>tree</a>, also prevents <var>event</var> from reaching any other objects.

  : <var>event</var> . {{Event/bubbles}}</a></code>
  :: <p>Returns true or false depending on how event was initialized. True if <var>event</var> goes through its <code><a>target</a></code> attribute value's <a>ancestors</a> in reverse <a>tree order</a>, and false otherwise.

  : <var>event</var> . {{Event/cancelable}}
  :: <p>Returns true or false depending on how <var>event</var> was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which <var>event</var> was <a>dispatched</a>, can be canceled by invoking the <code><a>preventDefault()</a></code> method.

  : <var>event</var> . {{Event/preventDefault()}}
  :: <p>If invoked when the {{Event/cancelable}} attribute value is true, and while executing a listener for the <var>event</var> with {{AddEventListenerOptions/passive}} set to false, signals to the operation that caused <var>event</var> to be <a>dispatched</a> that it needs to be canceled.

  : <var>event</var> . {{Event/defaultPrevented}}
  :: <p>Returns true if {{Event/preventDefault()}} was invoked successfully to indicate cancellation, and false otherwise.

  : <code><var>event</var> . {{Event/composed}}</code>
  :: Returns true or false depending on how <var>event</var> was initialized. True if <var>event</var> invokes listeners past a {{ShadowRoot}} <a>node</a> that is the <a for=tree>root</a> of its {{Event/target}} attribute value, and false otherwise.

  : <code><var>event</var> . {{Event/isTrusted}}</code>
  :: <p>Returns true if <var>event</var> was <a>dispatched</a> by the user agent, and false otherwise.

  : <var>event</var> . {{Event/timeStamp}}
  :: <p>Returns the <var>event</var>'s timestamp as the number of milliseconds that measured relative to the <a>time origin</a>.

</dl>

<p>The <dfn attribute for=Event><code>type</code></dfn> attribute's getter must return the value it was initialized to. When an <a>event</a> is created the attribute must be initialized to the empty string.

<p>The <dfn attribute for=Event><code>target</code></dfn> attribute's getter and <dfn attribute for=Event><code>currentTarget</code></dfn> attribute's getter must return the values they were initialized to. When an <a>event</a> is created the attributes must be initialized to null.

<p>The <dfn method for=Event><code>composedPath()</code></dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>composedPath</var> be a new empty list.

 <li><p>Let <var>currentTarget</var> be <a>context object</a>'s {{Event/currentTarget}} attribute value.

 <li>
  <p>For each <var>tuple</var> in <a>context object</a>'s <a for=Event>path</a>:

  <ol>
   <li>
    <p>If <var>currentTarget</var> is a {{Window}} object, then:

    <ol><li><p>If <var>tuple</var>'s <b>item</b> is not a <a>node</a>, or <var>tuple</var>'s
    <b>item</b> is not <a>closed-shadow-hidden</a> from <var>tuple</var>'s <b>item</b>'s
    <a>shadow-including root</a>, then append <var>tuple</var>'s <b>item</b> to
    <var>composedPath</var>.</p></li></ol>

   <li><p>Otherwise, if <var>currentTarget</var> is a <a>node</a> and <var>tuple</var>'s <b>item</b>
   is not <a>closed-shadow-hidden</a> from <var>currentTarget</var>, or <var>currentTarget</var> is
   not a <a>node</a>, then append <var>tuple</var>'s <b>item</b> to <var>composedPath</var>.
  </ol>

 <li><p>Return <var>composedPath</var>.
</ol>

<p class="note no-backref">Note: This algorithm assumes that when the <var>target</var> argument to the
<a>dispatch</a> algorithm is not a <a>node</a>, none of the tuples in <var>event</var> argument's
eventual <a for=Event>path</a> will contain a <a>node</a> either.

<p>The <dfn attribute for=Event lt="dom event eventPhase|event eventPhase|eventPhase"><code>eventPhase</code></dfn> attribute's getter must return the value it was initialized to, which must be one of the following:</p>
<dl>
  : <dfn const for=Event><code>NONE</code></dfn> (numeric value 0)
  :: <p><a>Events</a> not currently <a>dispatched</a> are in this phase.

  : <dfn const for=Event lt="CAPTURING_PHASE"><code>CAPTURING_PHASE</code></dfn> (numeric value 1)
  :: <p>When an <a>event</a> is <a>dispatched</a> to an object that <a>participates</a> in a <a>tree</a> it will be in this phase before it reaches its <code><a>target</a></code> attribute value.

  : <dfn const for=Event lt="AT_TARGET"><code>AT_TARGET</code></dfn> (numeric value 2)
  :: <p>When an <a>event</a> is <a>dispatched</a> it will be in this phase on its <code><a>target</a></code> attribute value.

  : <dfn const for=Event lt="BUBBLING_PHASE"><code>BUBBLING_PHASE</code></dfn> (numeric value 3)
  :: <p>When an <a>event</a> is <a>dispatched</a> to an object that <a>participates</a> in a <a>tree</a> it will be in this phase after it reaches its <code><a>target</a></code> attribute value.

  </dl>
<p>Initially the attribute must be initialized to {{Event/NONE}}.

<hr>

<p>Each <a>event</a> has the following associated flags that are all initially unset:</p>
<ul>
 <li><dfn>stop propagation flag</dfn>
 <li><dfn>stop immediate propagation flag</dfn>
 <li><dfn>canceled flag</dfn>
 <li><dfn>in passive listener flag</dfn>
 <li><dfn export for=Event id=composed-flag>composed flag</dfn>
 <li><dfn>initialized flag</dfn>
 <li><dfn>dispatch flag</dfn>
</ul>

<p>The <dfn method for=Event><code>stopPropagation()</code></dfn> method, when invoked, must set the <a>context object</a>'s <a>stop propagation flag</a>.

<p>The <dfn attribute for=Event><code>cancelBubble</code></dfn> attribute's getter must return true
if <a>context object</a>'s <a>stop propagation flag</a> is set, and false otherwise.

<p>The {{Event/cancelBubble}} attribute's setter must set <a>context object</a>'s
<a>stop propagation flag</a> if the given value is true, and do nothing otherwise.

<p>The <dfn method for=Event><code>stopImmediatePropagation()</code></dfn> method must set both the <a>stop propagation flag</a> and <a>stop immediate propagation flag</a>.

The <dfn attribute for=Event><code>bubbles</code></dfn> and <dfn attribute for=Event><code>cancelable</code></dfn> attributes must return the values they were initialized to.

<p>The <dfn method for=Event><code>preventDefault()</code></dfn> method, when invoked, must set the
<a>canceled flag</a> if the {{Event/cancelable}} attribute value is true and the
<a>in passive listener flag</a> is unset.

<p class="note no-backref">This means there are scenarios where invoking {{Event/preventDefault()}}
has no effect. User agents are encouraged to log the precise cause in a developer console, to aid
debugging.

<p>The <dfn attribute for=Event lt="dom event defaultPrevented|event defaultPrevented|defaultPrevented"><code>defaultPrevented</code></dfn> attribute must return true if the <a>canceled flag</a> is set and false otherwise.

<p>The <dfn attribute for=Event><code>composed</code></dfn> attribute's getter must return true if <a>context object</a>'s <a>composed flag</a> is set, and false otherwise.</p>

<hr>

<p>The <dfn attribute for=Event><code>isTrusted</code></dfn> attribute's getter must return the value it was initialized to. When an <a>event</a> is created the attribute must be
initialized to false.

<p class="note">Note: {{Event/isTrusted}} is a convenience that indicates whether an <a>event</a> is <a>dispatched</a> by the user agent
(as opposed to using <code><a>dispatchEvent()</a></code>). The sole legacy exception is {{HTMLElement/click()}}, which causes
the user agent to dispatch an <a>event</a> whose {{Event/isTrusted}} attribute is initialized to false.

<p>The <dfn attribute for=Event><code>timeStamp</code></dfn> attribute must return the value it was initialized to.

<hr>

To <dfn export for=Event id=concept-event-initialize>initialize</dfn> an
<var>event</var>, with <var>type</var>,
<var>bubbles</var>, and <var>cancelable</var>, run these steps:

<ol>
  1. Set the <a>initialized flag</a>.
  2. Unset the <a>stop propagation flag</a>, <a>stop immediate propagation flag</a>, and <a>canceled flag</a>.
  3. Set the {{Event/isTrusted}} attribute to false.
  4. Set the <code><a>target</a></code> attribute to null.
  5. Set the {{Event/type}} attribute to <var>type</var>.
  6. Set the {{Event/bubbles}} attribute to <var>bubbles</var>.
  7. Set the {{Event/cancelable}} attribute to <var>cancelable</var>.

</ol>

<p>The
<dfn method for=Event><code>initEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
  1. If <a>context object</a>'s <a>dispatch flag</a> is set, terminate these steps.

  2. <a>Initialize</a> the <a>context object</a> with <var>type</var>, <var>bubbles</var>, and <var>cancelable</var>.

</ol>

<p class="note no-backref">Note: As <a>events</a> have constructors {{Event/initEvent()}} is redundant and incapable of setting {{Event/composed}}. It has to be supported for legacy content.

<h3 id=interface-customevent>Interface {{CustomEvent}}</h3>

<pre class="idl">
[Constructor(DOMString type, optional CustomEventInit eventInitDict),
 Exposed=(Window,Worker)]
interface CustomEvent : Event {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, optional boolean bubbles = false, optional boolean cancelable = false, optional any detail = null);
};

dictionary CustomEventInit : EventInit {
  any detail = null;
};
</pre>

<p><a>Events</a> using the {{CustomEvent}} interface can be used to carry custom data.</p>

<dl class="domintro">
  : <var>event</var> = new <a constructor lt="CustomEvent()">CustomEvent</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
  :: <p>Works analogously to the constructor for <code><a>Event</a></code> except that the optional <var>eventInitDict</var> argument now allows for setting the <code title="dom-Event-detail">detail</code> attribute too.

  : <var>event</var> . {{CustomEvent/detail}}
  :: <p>Returns any custom data <var>event</var> was created with. Typically used for synthetic events.

</dl>

<p>The <dfn attribute for=CustomEvent lt="dom event customevent detail|event customevent detail|customevent detail|detail"><code>detail</code></dfn> attribute
must return the value it was initialized to.

<p>The
<dfn method for=CustomEvent><code>initCustomEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>, <var>detail</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
  <li>If <a>context object</a>'s <a>dispatch flag</a> is set, terminate these steps.

  <li><a>Initialize</a> the <a>context object</a> with <var>type</var>, <var>bubbles</var>, and <var>cancelable</var>.

  <li>Set <a>context object</a>'s {{CustomEvent/detail}} attribute to <var>detail</var>.

</ol>

<h3 id=constructing-events>Constructing events</h3>

<p>When a <dfn lt="dom event constructor|event constructor|constructor|constructors">constructor</dfn> of the <code><a>Event</a></code> interface, or of an interface that inherits from the <code><a>Event</a></code> interface, is invoked, these steps must be run:

<ol>
  <li><p> Create an <a>event</a> that uses the interface the constructor was invoked upon.

  <li><p> Set its <a>initialized flag</a>.

  <li><p> Initialize the {{Event/type}} attribute to the <var>type</var> argument.

  <li><p> Initialize <var>event</var>'s {{Event/timeStamp}} attribute to a {{DOMHighResTimeStamp}} representing the high resolution time from the <a>time origin</a> to the occurrence of the call to the <var>event</var>'s <a>constructor</a>.

  <li><p> If there is an <var>eventInitDict</var> argument then for each <a>dictionary member</a> present, find the attribute on <a>event</a> whose <a>identifier</a> matches the key of the <a>dictionary member</a> and then set the attribute to the value of that <a>dictionary member</a>.

  <li><p> Return the <a>event</a>.

</ol>

<p>To <dfn export id=concept-event-create lt="creating an event|create an event">create an event</dfn>
using <var>eventInterface</var>, which must be either {{Event}} or an interface that inherits from
it, and optionally given a <a>Realm</a> <var>realm</var>, run these steps:</p>

<ol>
 <li>
  <p>Create a new object <var>event</var> using <var>eventInterface</var>. If <var>realm</var>
  is given, use that Realm; otherwise, use the default behavior defined in Web IDL.

 <li><p>Set <var>event</var>'s <a>initialized flag</a>.

 <li><p>Let <var>defaultEventInitDict</var> be the result of
 <a lt="converted to an IDL value">converting</a> the JavaScript value undefined to the dictionary
 type accepted by <var>eventInterface</var>'s constructor. (This dictionary type will either be
 {{EventInit}} or a dictionary that inherits from it.)

 <li>For each <a>dictionary member</a> present in <var>defaultEventInitDict</var>, find the
 attribute on <var>event</var> whose <a spec=webidl>identifier</a> matches the key of the
 <a>dictionary member</a> and then set the attribute to the default value of that
 <a>dictionary member</a>.

 <li><p>Set <var>event</var>'s {{Event/timeStamp}} attribute to a {{DOMHighResTimeStamp}}
 representing the high resolution time from the <a>time origin</a> to the occurrence that the event is signaling.

 <li><p>Initialize <var>event</var>'s {{Event/isTrusted}} attribute to true.

 <li><p>Return <var>event</var>.
</ol>

<p class="note no-backref"><a>Create an event</a> is meant to be used by other specifications
which need to separately <a href="#concept-event-create">create</a> and <a>dispatch</a> events,
instead of simply <a href="#concept-event-fire">firing</a> them. It ensures the event's attributes
are initialized to the correct defaults.

<h3 id=defining-event-interfaces>Defining event interfaces</h3>

In general, when defining a new interface that inherits from <code><a>Event</a></code> please always ask feedback from the WHATWG or the
W3C www-dom@w3.org mailing list.

The {{CustomEvent}} interface can be used as starting point. However, do not introduce any <code>init<var ignore>*</var>Event()</code> methods as they are redundant with constructors. Interfaces that inherit from the <code><a>Event</a></code> interface that have such a method only have it for historical reasons.

<h3 id=interface-eventtarget>Interface {{EventTarget}}</h3>

<pre class="idl">
[Exposed=(Window,Worker)]
interface EventTarget {
  void addEventListener(DOMString type, EventListener? callback, optional (AddEventListenerOptions or boolean) options);
  void removeEventListener(DOMString type, EventListener? callback, optional (EventListenerOptions or boolean) options);
  boolean dispatchEvent(Event event);
};

callback interface EventListener {
  void handleEvent(Event event);
};

dictionary EventListenerOptions {
  boolean capture = false;
};

dictionary AddEventListenerOptions : EventListenerOptions {
  boolean passive = false;
  boolean once = false;
};
</pre>

<p>The {{EventTarget}} object represents the target to which an <a>event</a> is <a>dispatched</a>
when something has occurred.

<p>Each {{EventTarget}} object has an associated list of <a>event listeners</a>.

<p>An <dfn export id=concept-event-listener>event listener</dfn> can be used to observe a specific
<a>event</a>.

<p>An <a>event listener</a> consists of these fields:</p>

<ul class="brief">
 <li><dfn id="event-listener-type">type</dfn> (a string)
 <li><dfn id="event-listener-callback" for=EventListener>callback</dfn> (an {{EventListener}})
 <li><dfn id="event-listener-capture">capture</dfn> (a boolean, initially false)
 <li><dfn id="event-listener-passive">passive</dfn> (a boolean, initially false)
 <li><dfn id="event-listener-once">once</dfn> (a boolean, initially false)
 <li><dfn id="event-listener-removed">removed</dfn> (a boolean for bookkeeping purposes, initially false)
</ul>

<p class="note no-backref">Although <a href="#event-listener-callback">callback</a> is an {{EventListener}}, as can be seen from the
fields above, an <a>event listener</a> is a broader concept.

<p>Each {{EventTarget}} object also has an associated <dfn export>get the parent</dfn> algorithm,
which takes an <a>event</a> <var>event</var>, and returns an {{EventTarget}} object. Unless
specified otherwise it returns null.

<p class="note no-backref">Note: <a>Nodes</a>, <a for=/>shadow roots</a>, and <a href="#concept-document">documents</a> override the <a>get the parent</a> algorithm.

<p>Each {{EventTarget}} object can have an associated
<dfn export for=EventTarget>activation behavior</dfn> algorithm. The
<a for=EventTarget>activation behavior</a> algorithm is passed an <a>event</a>, as indicated in the
<a>dispatch</a> algorithm.</p>

<p class="note no-backref">This exists because user agents perform certain actions for certain
{{EventTarget}} objects, e.g., the <{area}> element, in response to synthetic {{MouseEvent}}
<a>events</a> whose {{Event/type}} attribute is <code>click</code>. Web compatibility prevented it
from being removed and it is now the enshrined way of defining an activation of something. [[!HTML51]]

<p>Each {{EventTarget}} object that has <a for=EventTarget>activation behavior</a>, can additionally
have both (not either) a <dfn export for=EventTarget>legacy-pre-activation behavior</dfn> algorithm
and a <dfn export for=EventTarget>legacy-canceled-activation behavior</dfn> algorithm.

<p class="note no-backref">These algorithms only exist for checkbox and radio <{input}> elements and
are not to be used for anything else. [[!HTML51]]

<dl>
  <dt><var>target</var> . <a method for=EventTarget lt=addEventListener()>addEventListener</a>(<var>type</var>, <var>callback</var> [, <var>options</var>])
  <dd>
  Appends an <a>event listener</a> for <a>events</a> whose {{Event/type}} attribute value
  is <var>type</var>. The <var>callback</var> argument sets the <b>callback</b> that will
  be invoked when the <a>event</a> is <a>dispatched</a>.

  The <var>options</var> argument sets listener-specific options. For compatibility this can be just
  a boolean, in which case the method behaves exactly as if the value was specified as
  <var>options</var>' <code>capture</code> member.

  When set to true, <var>options</var>' <code>capture</code> member prevents <b>callback</b> from
  being invoked when the <a>event</a>'s {{Event/eventPhase}} attribute value is
  {{Event/BUBBLING_PHASE}}. When false (or not present), <b>callback</b> will not be invoked when
  <a>event</a>'s {{Event/eventPhase}} attribute value is {{Event/CAPTURING_PHASE}}. Either way,
  <b>callback</b> will be invoked if <a>event</a>'s {{Event/eventPhase}} attribute value is
  {{Event/AT_TARGET}}.

  When set to true, <var>options</var>' <code>passive</code> member indicates that the
  <b>callback</b> will not cancel the event by invoking {{Event/preventDefault()}}. This is used to
  enable performance optimizations described in [[#observing-event-listeners]].

  When set to true, <var>options</var>'s <code>once</code> member indicates that the <b>callback</b>
  will only be invoked once after which the event listener will be removed.

  The <a>event listener</a> is appended to <var>target</var>'s list of <a>event listeners</a> and is
  not appended if it is a duplicate, i.e., having the same <b>type</b>, <b>callback</b>, and
  <b>capture</b> values.

  <dt><var>target</var> . <a method for=EventTarget lt=removeEventListener()>removeEventListener</a>(<var>type</var>, <var>callback</var> [, <var>options</var>])</code>
  <dd>Remove the <a>event listener</a> in <var>target</var>'s list of <a>event listeners</a> with the same <var>type</var>, <var>callback</var>, and <var>options</var>.

  <dt><var>target</var> . <a method for=EventTarget lt=dispatchEvent()>dispatchEvent</a>(<var>event</var>)
  <dd><a>Dispatches</a> a synthetic event <var>event</var> to <var>target</var> and returns true if either <var>event</var>'s {{Event/cancelable}} attribute value is false or its <code><a>preventDefault()</a></code> method was not invoked, and false otherwise.
</dl>


<p>To <dfn export for=Event id=concept-flatten-options>flatten</dfn> <var>options</var>, run these
steps:

<ol>
 <li><p>Let <var>capture</var> be false.

 <li><p>If <var>options</var> is a boolean, set <var>capture</var> to <var>options</var>.

 <li><p>If <var>options</var> is a dictionary, then set <var>capture</var> to <var>options</var>'s
 {{EventListenerOptions/capture}}.

 <li><p>Return <var>capture</var>.
</ol>

<p>To <dfn export for=Event>flatten more</dfn><!-- sorry --> <var>options</var>, run these
steps:

<ol>
 <li><p>Let <var>capture</var> be the result of <a>flattening</a> <var>options</var>.

 <li><p>Let <var>once</var> and <var>passive</var> be false.

 <li><p>If <var>options</var> is a dictionary, then set <var>passive</var> to <var>options</var>'s
 {{AddEventListenerOptions/passive}} and <var>once</var> to <var>options</var>'s
 {{AddEventListenerOptions/once}}.

 <li><p>Return <var>capture</var>, <var>passive</var>, and <var>once</var>.
</ol>

<p>The
<dfn method for=EventTarget>addEventListener(<var>type</var>, <var>callback</var>, <var>options</var>)</dfn>
method, when invoked, must run these steps:
<ol>
  <li><p>If <a>context object</a>'s <a>relevant global object</a> is a {{ServiceWorkerGlobalScope}}
  object and its associated <a>service worker</a>'s <a for="service worker">script resource</a>'s
  <a>has ever been evaluated flag</a> is set, then <a>throw</a> a
  <code>TypeError</code>.
  [[!SERVICE-WORKERS]]

  <p class="note no-backref">To optimize storing the event types allowed for the service worker and
  to avoid non-deterministic changes to the event listeners, invocation of the method is allowed
  only during the very first evaluation of the service worker script.

 <li><p>If <var>callback</var> is null, then return.

 <li><p>Let <var>capture</var>, <var>passive</var>, and <var>once</var> be the result of
 <a lt="flatten more">flattening more</a> <var>options</var>.

 <li><p>If <a>context object</a>'s associated list of <a>event listener</a> does not contain an
 <a>event listener</a> whose <a href="#event-listener-type">type</a> is <var>type</var>, <a href="#event-listener-callback">callback</a> is <var>callback</var>,
 and <a href="#event-listener-capture">capture</a> is <var>capture</var>, then append a new <a>event listener</a> to it, whose
 <a href="#event-listener-type">type</a> is <var>type</var>, <a href="#event-listener-callback">callback</a> is <var>callback</var>, <a href="#event-listener-capture">capture</a> is
 <var>capture</var>, <a href="#event-listener-passive">passive</a> is <var>passive</var>, and <a href="#event-listener-once">once</a> is <var>once</var>.
</ol>

<p>The
<dfn method for=EventTarget>removeEventListener(<var>type</var>, <var>callback</var>, <var>options</var>)</dfn> method, when invoked, must run these steps:
<ol>
 <li><p>If <a>context object</a>'s <a>relevant global object</a> is a {{ServiceWorkerGlobalScope}}
 object and its associated <a>service worker</a>'s <a for="service worker">script resource</a>'s
 <a>has ever been evaluated flag</a> is set, then <a>throw</a> a
 <code>TypeError</code>. [[!SERVICE-WORKERS]]

 <li><p>Let <var>capture</var> be the result of <a>flattening</a> <var>options</var>.

 <li><p>If there is an <a>event listener</a> in the associated list of <a>event listeners</a> whose
 <a href="#event-listener-type">type</a> is <var>type</var>, <a href="#event-listener-callback">callback</a> is <var>callback</var>, and <a href="#event-listener-capture">capture</a> is <var>capture</var>, then set that <a>event listener</a>'s <a href="#event-listener-removed">removed</a> to true and remove it from
 the associated list of <a>event listeners</a>.
</ol>

<p>The <dfn method for=EventTarget>dispatchEvent(<var>event</var>)</dfn> method, when invoked, must run these steps:
<ol>
  <li><p>If <var>event</var>'s <a>dispatch flag</a> is set, or if its <a>initialized flag</a> is not set, <a>throw</a> an "<code>InvalidStateError</code>" exception.[[!WEBIDL]]
  <li><p>Initialize <var>event</var>'s {{Event/isTrusted}} attribute to false.
  <li><p><a>Dispatch</a> the <var>event</var> and return the value that returns.

</ol>

<h3 id=observing-event-listeners>Observing event listeners</h3>

<p>In general, developers do not expect the presence of an <a>event listener</a> to be observable.
The impact of an <a>event listener</a> is determined by its <b>callback</b>. That is, a developer
adding a no-op <a>event listener</a> would not expect it to have any side effects.

<p>Unfortunately, some event APIs have been designed such that implementing them efficiently
requires observing <a>event listeners</a>. This can make the presence of listeners observable in
that even empty listeners can have a dramatic performance impact on the behavior of the application.
For example, touch and wheel events which can be used to block asynchronous scrolling. In some cases
this problem can be mitigated by specifying the event to be {{Event/cancelable}} only when there is
at least one non-{{AddEventListenerOptions/passive}} listener. For example,
non-{{AddEventListenerOptions/passive}} <a>TouchEvent</a> listeners must block scrolling, but if all
listeners are {{AddEventListenerOptions/passive}} then scrolling can be allowed to start
<a>in parallel</a> by making the <a>TouchEvent</a> uncancelable (so that calls to
{{Event/preventDefault()}} are ignored). So code dispatching an event is able to observe the absence
of non-{{AddEventListenerOptions/passive}} listeners, and use that to clear the {{Event/cancelable}}
property of the event being dispatched.

<p>Ideally, any new event APIs are defined such that they do not need this property (use
<a href="https://lists.w3.org/Archives/Public/public-script-coord/">public-script-coord@w3.org</a>
for discussion).

<h3 id=dispatching-events>Dispatching events</h3>

<p>To <dfn export id=concept-event-dispatch>dispatch</dfn> an <var>event</var> to a <var>target</var>, with an optional <var>legacy target override flag</var>, and an optional <var>legacyOutputDidListenersThrowFlag</var>, run these steps:

<ol>
 <li>Set <var>event</var>'s <a>dispatch flag</a>.

 <li>
 <p>Let <var>targetOverride</var> be <var>target</var>, if <var>legacy target override flag</var> is not given, and <var>target</var>'s <a>associated <code>Document</code></a> otherwise. [[!HTML]]

 <p class="note">Note: <var>legacy target override flag</var> is only used by HTML and only when <var>target</var> is a {{Window}} object.

 <li>Let <var>relatedTarget</var> be the result of invoking <a>retargeting</a> <var>event</var>'s
  <a>relatedTarget</a> against <var>target</var> if <var>event</var>'s <a>relatedTarget</a> is
  non-null, and null otherwise.

 <li><p>If <var>target</var> is <var>relatedTarget</var> and <var>target</var> is not
 <var>event</var>'s <a>relatedTarget</a>, then return true.

 <li><p>Append (<var>target</var>, <var>targetOverride</var>, <var>relatedTarget</var>) to <var>event</var>'s
  <a for=Event>path</a>.

 <li><p>Let <var>isActivationEvent</var> be true, if <var>event</var> is a {{MouseEvent}} object and
    <var>event</var>'s {{Event/type}} attribute is "<code>click</code>", and false otherwise.
 <li><p>Let <var>activationTarget</var> be <var>target</var>, if <var>isActivationEvent</var> is
    true and <var>target</var> has <a for=EventTarget>activation behavior</a>, and null otherwise.
 <li><p>Let <var>parent</var> be the result of invoking <var>target</var>'s <a>get the parent</a> with <var>event</var>.

 <li>
  <p>While <var>parent</var> is non-null:</p>
  <ol>
   <li><p>Let <var>relatedTarget</var> be the result of invoking <a>retargeting</a>
   <var>event</var>'s <a>relatedTarget</a> against <var>parent</var> if <var>event</var>'s
   <a>relatedTarget</a> is non-null, and null otherwise.

   <li>
    <p>If <var>target</var>'s <a for=tree>root</a> is a
    <a>shadow-including inclusive ancestor</a> of <var>parent</var>, then:

    <ol>
     <li><p>If <var>isActivationEvent</var> is true, <var>event</var>'s {{Event/bubbles}} attribute
     is true, <var>activationTarget</var> is null, and <var>parent</var> has
     <a>activation behavior</a>, then set <var>activationTarget</var> to <var>parent</var>.

     <li><p>Append (<var>parent</var>, null, <var>relatedTarget</var>) to <var>event</var>'s
     <a for=Event>path</a>.
    </ol>

   <li><p>Otherwise, if <var>parent</var> and <var>relatedTarget</var> are identical, then set
   <var>parent</var> to null.

   <li>
    <p>Otherwise, set <var>target</var> to <var>parent</var> and then:

    <ol>
     <li><p>If <var>isActivationEvent</var> is true, <var>activationTarget</var> is null, and
     <var>target</var> has <a>activation behavior</a>, then set <var>activationTarget</var> to
     <var>target</var>.

     <li><p>Append (<var>parent</var>, <var>target</var>, <var>relatedTarget</var>) to
     <var>event</var>'s <a for=Event>path</a>.
    </ol>

   <li><p>If <var>parent</var> is non-null, then set <var>parent</var> to the result of invoking
   <var>parent</var>'s <a>get the parent</a> with <var>event</var>.
  </ol>

 <li><p>Set <var>event</var>'s {{Event/eventPhase}} attribute to {{Event/CAPTURING_PHASE}}.

 <li><p>If <var>activationTarget</var> is non-null and <var>activationTarget</var> has
 <a for=EventTarget>legacy-pre-activation behavior</a>, then run <var>activationTarget</var>'s
 <a for=EventTarget>legacy-pre-activation behavior</a>.

 <li>
  <p>For each <var>tuple</var> in <var>event</var>'s <a for=Event>path</a>, in reverse order:
  <ol>
   <li><p>Set <var>event</var>'s {{Event/target}} attribute to the <b>target</b> of the last tuple in <var>event</var>'s <a for=Event>path</a>, that is either <var>tuple</var> or preceding <var>tuple</var>, whose <b>target</b> is non-null.

   <li><p>Set <var>event</var>'s <a>relatedTarget</a> to <var>tuple</var>'s <b>relatedTarget</b>.

   <li><p>Run the <a>retargeting steps</a> with <var>event</var>.

   <li><p>If <var>tuple</var>'s <b>target</b> is null, then <a>invoke</a> <var>tuple</var>'s <b>item</b> with <var>event</var> and <var>legacyOutputDidListenersThrowFlag</var> if given.
  </ol>

 <li>
  <p>For each <var>tuple</var> in <var>event</var>'s <a for=Event>path</a>, in order:
  <ol>
   <li><p>Set <var>event</var>'s {{Event/target}} attribute to the <b>target</b> of the last tuple in <var>event</var>'s <a for=Event>path</a>, that is either <var>tuple</var> or preceding <var>tuple</var>, whose <b>target</b> is non-null.

   <li><p>Set <var>event</var>'s <a>relatedTarget</a> to <var>tuple</var>'s <b>relatedTarget</b>.

   <li><p>Run the <a>retargeting steps</a> with <var>event</var>.

   <li><p>If <var>tuple</var>'s <b>target</b> is non-null, then set <var>event</var>'s {{Event/eventPhase}} attribute to {{Event/AT_TARGET}}.

   <li><p>Otherwise, set <var>event</var>'s {{Event/eventPhase}} attribute to {{Event/BUBBLING_PHASE}}.

   <li><p>If either <var>event</var>'s {{Event/eventPhase}} attribute is {{Event/BUBBLING_PHASE}} and <var>event</var>'s {{Event/bubbles}} attribute is true or <var>event</var>'s {{Event/eventPhase}} attribute is {{Event/AT_TARGET}}, then <a>invoke</a> <var>tuple</var>'s <b>item</b> with <var>event</var> and <var>legacyOutputDidListenersThrowFlag</var> if given.
  </ol>

 <li><p>Unset <var>event</var>'s <a>dispatch flag</a>, <a>stop propagation flag</a> and <a>stop immediate propagation flag</a>.

 <li><p>Set <var>event</var>'s {{Event/eventPhase}} attribute to {{Event/NONE}}.

 <li><p>If {{Event/target}}'s <a for=tree>root</a> is a <a for=/>shadow root</a>, then set <var>event</var>'s {{Event/target}} attribute to null.

 <li><p>Set <var>event</var>'s {{Event/currentTarget}} attribute to null.

 <li><p>Set <var>event</var>'s <a for=Event>path</a> to the empty list.

 <li>
  <p>If <var>activationTarget</var> is non-null, then:

  <ol>
   <li><p>If <var>event</var>'s <a>canceled flag</a> is unset, then run
   <var>activationTarget</var>'s <a>activation behavior</a> with <var>event</var>.

   <li><p>Otherwise, if <var>activationTarget</var> has
   <a for=EventTarget>legacy-canceled-activation behavior</a>, then run
   <var>activationTarget</var>'s <a for=EventTarget>legacy-canceled-activation behavior</a>.
  </ol>

 <li>Return false if <var>event</var>'s <a>canceled flag</a> is set, and true otherwise.

</ol>


<p>To <dfn lt="listener invoke|event listener invoke|invoke|invokes|invoked">invoke</dfn> an <var>object</var> with <var>event</var> and optional <var>legacyOutputDidListenersThrowFlag</var>, run these steps:</p>
<ol>
  <li><p>If <var>event</var>'s <a>stop propagation flag</a> is set, then return.
  <li>Let <var>listeners</var> be a copy of the <a>event listeners</a> associated with the <var>object</var>.
  <li>Initialize <var>event</var>'s {{Event/currentTarget}} attribute to the <var>object</var>.
  <li>For each <a>event listener</a> in <var>listeners</var>, whose <a href="#event-listener-removed">removed</a> is false:

  <ol>
   <li><p>Let <var>listener</var> be the <a>event listener</a>.
   <li><p>If <var>event</var>'s {{Event/type}} attribute value is not <var>listener</var>'s <b>type</b>, terminate these substeps (and run them for the next <a>event listener</a>).
   <li><p>If <var>event</var>'s {{Event/eventPhase}} attribute value is {{Event/CAPTURING_PHASE}} and <var>listener</var>'s <b>capture</b> is false, terminate these substeps (and run them for the next <a>event listener</a>).
   <li><p>If <var>event</var>'s {{Event/eventPhase}} attribute value is {{Event/BUBBLING_PHASE}} and <var>listener</var>'s <b>capture</b> is true, terminate these substeps (and run them for the next <a>event listener</a>).
   <li><p>If <var>listener</var>'s <a href="#event-listener-once">once</a> is true, then remove <var>listener</var> from    <var>object</var>'s associated list of <a>event listeners</a>.
   <li><p>If <var>listener</var>'s <a href="#event-listener-passive">passive</a> is true, then set <var>event</var>'s <a>in passive listener flag</a>.
   <li><p>Call <var>listener</var>'s <b>callback</b>'s <code>handleEvent</code>, with the event passed to this algorithm as the first argument and <var>event</var>'s {{Event/currentTarget}} attribute value as <a>callback this value</a>. If this throws any exception, then:
    <ol>
     <li><p><a>Report the exception</a>.

     <li>
      <p>Set <var>legacyOutputDidListenersThrowFlag</var> if given.

      <p class=note>The <var>legacyOutputDidListenersThrowFlag</var> is only used by Indexed
      Database API. [[INDEXEDDB]]
    </ol>

   <li><p>Unset <var>event</var>'s <a>in passive listener flag</a>.

   <li><p>If <var>event</var>'s <a>stop immediate propagation flag</a> is set, then return
   <var ignore>found</var>.

  </ol>
 </li>
</ol>


<h3 id="firing-events">Firing events</h3>

<p>To <dfn export id=concept-event-fire>fire an event</dfn> named <var>e</var> at <var>target</var>,
optionally using an <var>eventConstructor</var>, with a description of how IDL attributes are to be
initialized, and a <var>legacy target override flag</var>, run these steps:

<ol>
 <li><p>If <var>eventConstructor</var> is not given, then let <var>eventConstructor</var> be {{Event}}.

 <li><p>Let <var>event</var> be the result of <a for=Event lt=constructor>invoking</a> the initial value of <var>eventConstructor</var> with the argument <var>e</var>.

 <li><p>Initialize <var>event</var>'s {{Event/isTrusted}} attribute to true.

 <li>
  <p>Initialize any other IDL attributes of <var>event</var> as described in the invocation of this algorithm.

  <p class="note">This also allows for the {{Event/isTrusted}} attribute to be set to false.

 <li><p>Return the result of <a>dispatching</a> <var>event</var> at <var>target</var>, with <var>legacy target override flag</var> set if set.
</ol>

<p class="note no-backref">Note: Fire in the context of DOM is short for creating, initializing, and <a>dispatching</a> an <a>event</a>. <a>Fire an event</a> makes that process easier to write down.

<div class="example no-backref" id=firing-events-example>
 <p>If the <a>event</a> needs its {{Event/bubbles}} or {{Event/cancelable}} attribute initialized, one could write "<a>fire an event</a> named <code>submit</code> at <var>target</var> with its
 {{Event/cancelable}} attribute initialized to true".

 <p>Or, when a custom constructor is required, "<a>fire an event</a> named <code>click</code> at
 <var>target</var> using {{MouseEvent}} with its {{Event/isTrusted}} attribute initialized to
 false".

 <p>Ocassionally the return value is important:

 <ol>
  <li><p>Let <var>doAction</var> be the result of <a lt="fire an event">firing an event</a> named <code>like</code> at <var>target</var>.

  <li><p>If <var>doAction</var> is true, then &hellip;
 </ol>
</div>

<h3 id="action-versus-occurance">Action versus occurrence</h3>

<p>An <a>event</a> signifies an occurrence, not an action. Phrased differently, it
represents a notification from an algorithm and can be used to influence the future course
of that algorithm (e.g., through invoking <a>preventDefault()</a>). <a>Events</a> must not be
used as actions or initiators that cause some algorithm to start running. That is not what
they are for.

<p class="note no-backref">This is called out here specifically because previous
iterations of the DOM had a concept of "default actions" associated with <a>events</a>
that gave folks all the wrong ideas. <a>Events</a> do not represent or cause actions, they
can only be used to influence an ongoing one.

</section>
