<section>
<h2 id="events">Events</h2>

<h3 id="events-introduction-to-dom-events">Introduction to "DOM Events"</h3>

<p>Throughout the web platform <a>events</a> are <a>dispatched</a> to objects to signal an occurrence, such as network activity or user interaction. These objects implement the <code><a>EventTarget</a></code> interface and can therefore add <a>event listeners</a> to observe <a>events</a> by calling <a>addEventListener()</a>:

<pre class='example'><code>obj.addEventListener("load", imgFetched)

function imgFetched(ev) {
  // great success
  …
}</code></pre>

<p><a>Event listeners</a> can be removed by utilizing the <code><a>removeEventListener()</a></code> method, passing the same arguments.

<p><a>Events</a> are objects too and implement the <code><a>Event</a></code> interface (or a derived interface). In the example above <var>ev</var> is the <a>event</a>. It is passed as argument to <a>event listener</a>'s <b>callback</b> (typically a JavaScript Function as shown above).

<a>Event listeners</a> key off the <a>event</a>'s <code><a>type</a></code> attribute value ("<code>load</code>" in the above example). The <a>event</a>'s <code><a>target</a></code> attribute value returns the object to which the <a>event</a> was <a>dispatched</a> (<var>obj</var> above).

<p>Now while typically <a>events</a> are <a>dispatched</a> by the user agent as the result of user interaction or the completion of some task, applications can <a>dispatch</a> <a>events</a> themselves, commonly known as synthetic events:

<pre class='example'><code>// add an appropriate event listener
obj.addEventListener("cat", function(e) { process(e.detail) })

// create and dispatch the event
var event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
obj.dispatchEvent(event)</code></pre>

<p>Apart from signaling, <a>events</a> are sometimes also used to let an application control what happens next in an operation. For instance as part of form submission an <a>event</a> whose <code><a>type</a></code> attribute value is "<code>submit</code>" is <a>dispatched</a>. If this <a>event</a>'s <code><a>preventDefault()</a></code> method is invoked, form submission will be terminated. Applications who wish to make use of this functionality through <a>events</a> <a>dispatched</a> by the application (synthetic events) can make use of the return value of the <code><a>dispatchEvent()</a></code> method:

<pre class='example'><code>if(obj.dispatchEvent(event)) {
  // event was not canceled, time for some magic
  …
}</code></pre>

<p>When an <a>event</a> is <a>dispatched</a> to an object that <a>participates</a> in a <a>tree</a> (e.g. an <a>element</a>), it can reach <a>event listeners</a> on that object's <a>ancestors</a> too. First all object's <a>ancestor</a> <a>event listeners</a> whose <b>capture</b> variable is set to true are invoked, in <a>tree order</a>. Second, object's own <a>event listeners</a> are invoked. And finally, and only if <a>event</a>'s <a>bubbles</a> attribute value is true, object's  <a>ancestor</a> <a>event listeners</a> are invoked again, but now in reverse <a>tree order</a>.

<p>Lets look at an example of how <a>events</a> work in a <a>tree</a>:

<pre class='example'><code>&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Boring example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Hello &lt;span id=x&gt;world&lt;/span&gt;!&lt;/p&gt;
  &lt;script&gt;
   function test(e) {
     debug(e.target, e.currentTarget, e.eventPhase)
   }
   document.addEventListener("hey", test, true)
   document.body.addEventListener("hey", test)
   var ev = new Event("hey", {bubbles:true})
   document.getElementById("x").dispatchEvent(ev)
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>The <code>debug</code> function will be invoked twice. Each time the <a>events</a>'s <code><a>target</a></code> attribute value will be the <code>span</code> <a>element</a>. The first time <code><a>currentTarget</a></code> attribute's value will be the <a>document</a>, the second time the <code>body</code> <a>element</a>. <code><a>eventPhase</a></code> attribute's value switches from <code><a>CAPTURING_PHASE</a></code> to <code><a>BUBBLING_PHASE</a></code>. If an <a>event listener</a> was registered for the <code>span</code> <a>element</a>, <code><a>eventPhase</a></code> attribute's value would have been <code><a>AT_TARGET</a></code>.

<h3 id="events-interface-event">Interface <code><a>Event</a></code></h3>
<pre class='idl'>
[Constructor(DOMString type, optional EventInit eventInitDict),
 Exposed=(Window,Worker)]
interface Event {
  readonly attribute DOMString type;
  readonly attribute EventTarget? target;
  readonly attribute EventTarget? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute DOMTimeStamp timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};
</pre>

<p>An <dfn>event</dfn> allows for signaling that
something has occurred. e.g. that an image has completed downloading. It is
represented by the <code><a>Event</a></code> interface or an interface that
inherits from the <code><a>Event</a></code> interface.</p>

<dl>
  : <code><var>event</var> = new <a>Event</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
  :: <p>Returns a new <var>event</var> whose <code><a>type</a></code> attribute value is set to <var>type</var>. The optional <var>eventInitDict</var> argument allows for setting the <code><a>bubbles</a></code> and <code><a>cancelable</a></code> attributes via object members of the same name.

  : <code><var>event</var> . <a>type</a></code>
  :: <p>Returns the type of <var>event</var>, e.g. "<code>click</code>", "<code>hashchange</code>", or "<code>submit</code>".

  : <code><var>event</var> . <a>target</a></code>
  :: <p>Returns the object to which <var>event</var> is <a>dispatched</a>.

  : <code><var>event</var> . <a>currentTarget</a></code>
  :: <p>Returns the object whose <a>event listener</a>'s <b>callback</b> is currently being invoked.

  : <code><var>event</var> . <a>eventPhase</a></code>
  :: <p>Returns the <a>event</a>'s phase, which is one of <code><a>NONE</a></code>, <code title="dom-Event-CAPTURING_PHASE"><a>CAPTURING_PHASE</a></code>, <code><a>AT_TARGET</a></code>, and <code><a>BUBBLING_PHASE</a></code>.

  : <code><var>event</var> . <a>stopPropagation</a>()</code>
  :: <p>When <a>dispatched</a> in a <a>tree</a>, invoking this method prevents <var>event</var> from reaching any objects other than the current object.

  : <code><var>event</var> . <a>stopImmediatePropagation</a>()</code>
  :: <p>Invoking this method prevents <var>event</var> from reaching any registered <a>event listeners</a> after the current one finishes running and, when <a>dispatched</a> in a <a>tree</a>, also prevents <var>event</var> from reaching any other objects.

  : <code><var>event</var> . <a>bubbles</a></code>
  :: <p>Returns true or false depending on how event was initialized. True if <var>event</var> goes through its <code><a>target</a></code> attribute value's <a>ancestors</a> in reverse <a>tree order</a>, and false otherwise.

  : <code><var>event</var> . <a>cancelable</a></code>
  :: <p>Returns true or false depending on how <var>event</var> was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which <var>event</var> was <a>dispatched</a>, can be canceled by invoking the <code><a>preventDefault()</a></code> method.

  : <code><var>event</var> . <a>preventDefault</a>()</code>
  :: <p>If invoked when the <code><a>cancelable</a></code> attribute value is true, signals to the operation that caused <var>event</var> to be <a>dispatched</a> that it needs to be canceled.

  : <code><var>event</var> . <a>defaultPrevented</a></code>
  :: <p>Returns true if <code><a>preventDefault()</a></code> was invoked while the <code><a>cancelable</a></code> attribute value is true, and false otherwise.

  : <code><var>event</var> . <a>isTrusted</a></code>
  :: <p>Returns true if <var>event</var> was <a>dispatched</a> by the user agent, and false otherwise.

  : <code><var>event</var> . <a>timeStamp</a></code>
  :: <p>Returns the creation time of <var>event</var> as the number of milliseconds that passed since 00:00:00 UTC on 1 January 1970.

</dl>

<p>The <dfn lt="dom event type|event type|type"><code>type</code></dfn> attribute must return the value it was initialized to. When an <a>event</a> is created the attribute must be initialized to the empty string.

<p>The <dfn lt="dom event target|event target|target"><code>target</code></dfn> and <dfn lt="dom event currentTarget|event currentTarget|currentTarget"><code>currentTarget</code></dfn> attributes must return the values they were initialized to. When an <a>event</a> is created the attributes must be initialized to null.

<p>The <dfn lt="dom event eventPhase|event eventPhase|eventPhase"><code>eventPhase</code></dfn> attribute must return the value it was initialized to, which must be one of the following:</p>
<dl>
  : <dfn lt="dom event NONE|event NONE|NONE"><code>NONE</code></dfn> (numeric value 0)
  :: <p><a>Events</a> not currently <a>dispatched</a> are in this phase.

  : <dfn lt="dom event capturing_phase|event capturing_phase|capturing_phase"><code>CAPTURING_PHASE</code></dfn> (numeric value 1)</dt>
  :: <p>When an <a>event</a> is <a>dispatched</a> to an object that <a>participates</a> in a <a>tree</a> it will be in this phase before it reaches its <code><a>target</a></code> attribute value.

  : <dfn lt="dom event AT_TARGET|event AT_TARGET|AT_TARGET"><code>AT_TARGET</code></dfn> (numeric value 2)
  :: <p>When an <a>event</a> is <a>dispatched</a> it will be in this phase on its <code><a>target</a></code> attribute value.

  : <dfn lt="dom event BUBBLING_PHASE|event BUBBLING_PHASE|BUBBLING_PHASE"><code>BUBBLING_PHASE</code></dfn> (numeric value 3)
  :: <p>When an <a>event</a> is <a>dispatched</a> to an object that <a>participates</a> in a <a>tree</a> it will be in this phase after it reaches its <code><a>target</a></code> attribute value.

  </dl>
<p>Initially the attribute must be initialized to
<code><a>NONE</a></code>.

<hr>

<p>Each <a>event</a> has the following associated
flags that are all initially unset:</p>
<ul>
 <li><dfn>stop propagation flag</dfn>
 <li><dfn>stop immediate propagation flag</dfn>
 <li><dfn>canceled flag</dfn>
 <li><dfn>initialized flag</dfn>
 <li><dfn>dispatch flag</dfn>
</ul>

<p>The
<dfn><code>stopPropagation()</code></dfn>
method must set the <a>stop propagation flag</a>.

<p>The
<dfn><code>stopImmediatePropagation()</code></dfn> method must set both the <a>stop propagation flag</a> and <a>stop immediate propagation flag</a>.

<p>The <dfn lt="dom event bubble|event bubble|bubble|dom event bubbles|event bubbles|bubbles"><code>bubbles</code></dfn> and <dfn lt="dom event cancelable|event cancelable|cancelable"><code>cancelable</code></dfn> attributes must return the values they were initialized to.

<p>The <dfn><code>preventDefault()</code></dfn> method must set the <a>canceled flag</a> if the <code><a>cancelable</a></code> attribute value is true.

<p>The
<dfn lt="dom event defaultPrevented|event defaultPrevented|defaultPrevented"><code>defaultPrevented</code></dfn> attribute must return true if the <a>canceled flag</a> is set and false otherwise.

<hr>

<p>The <dfn lt="dom event isTrusted|event isTrusted|isTrusted"><code>isTrusted</code></dfn> attribute must return the value it was initialized to. When an <a>event</a> is created the attribute must be
initialized to false.

<p class="note">Note: <code><a>isTrusted</a></code> is a convenience that indicates whether an <a>event</a> is <a>dispatched</a> by the user agent
(as opposed to using <code><a>dispatchEvent()</a></code>). The sole legacy exception is {{HTMLElement/click()}}, which causes
the user agent to dispatch an <a>event</a> whose <code><a>isTrusted</a></code> attribute is initialized to false.

<p>The <dfn lt="dom event timeStamp|event timeStamp|timeStamp"><code>timeStamp</code></dfn> attribute must return the value it was initialized to. When an <a>event</a> is created the attribute must be initialized to the number of milliseconds that have passed since 00:00:00 UTC on 1 January 1970, ignoring leap seconds.
<!-- leap seconds are ignored by JavaScript too -->

<hr>

<p>To <dfn lt="dom event initialize|event initialize|initialize|initialized|initializes">initialize</dfn> an <var>event</var>, with <var>type</var>, <var>bubbles</var>, and <var>cancelable</var>, run these steps:

<ol>
  1. Set the <a>initialized flag</a>.
  2. Unset the <a>stop propagation flag</a>, <a>stop immediate propagation flag</a>, and <a>canceled flag</a>.
  3. Set the <code><a>isTrusted</a></code> attribute to false.
  4. Set the <code><a>target</a></code> attribute to null.
  5. Set the <code><a>type</a></code> attribute to <var>type</var>.
  6. Set the <code><a>bubbles</a></code> attribute to <var>bubbles</var>.
  7. Set the <code><a>cancelable</a></code> attribute to <var>cancelable</var>.

</ol>

<p>The
<dfn><code>initEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
  1. If <a>context object</a>'s <a>dispatch flag</a> is set, terminate these steps.

  2. <a>Initialize</a> the <a>context object</a> with <var>type</var>, <var>bubbles</var>, and <var>cancelable</var>.

</ol>

<p class="note">Note: As <a>events</a> have constructors <code><a>initEvent()</a></code> is superfluous. However, it has to be supported for legacy content.

<h3 id="events-interface-customevent">Interface <code><a>CustomEvent</a></code></h3>

<pre class="idl">
[Constructor(DOMString type, optional CustomEventInit eventInitDict),
 Exposed=(Window,Worker)]
interface CustomEvent : Event {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);
};

dictionary CustomEventInit : EventInit {
  any detail = null;
};
</pre>

<p><a>Events</a> using the <code><a>CustomEvent</a></code> interface can be used to carry custom data.</p>

<dl class="domintro">
  : <code><var>event</var> = new <a>CustomEvent</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
  :: <p>Works analogously to the constructor for <code><a>Event</a></code> except that the optional <var>eventInitDict</var> argument now allows for setting the <code title="dom-Event-detail">detail</code> attribute too.

  : <code><var>event</var> . <a>detail</a></code>
  :: <p>Returns any custom data <var>event</var> was created with. Typically used for synthetic events.

</dl>

<p>The <dfn lt="dom event customevent detail|event customevent detail|customevent detail|detail"><code>detail</code></dfn> attribute
must return the value it was initialized to.

<p>The
<dfn><code>initCustomEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>, <var>detail</var>)</code></dfn>
method must, when invoked, run these steps:

<ol>
  <li>If <a>context object</a>'s <a>dispatch flag</a> is set, terminate these steps.

  <li><a>Initialize</a> the <a>context object</a> with <var>type</var>, <var>bubbles</var>, and <var>cancelable</var>.

  <li>Set <a>context object</a>'s <code><a>detail</a></code> attribute to <var>detail</var>.

</ol>

<h3 id="events-constructing-events">Constructing events</h3>

<p>When a <dfn lt="dom event constructor|event constructor|constructor|constructors">constructor</dfn> of the <code><a>Event</a></code> interface, or of an interface that inherits from the <code><a>Event</a></code> interface, is invoked, these steps must be run:

<ol>
  <li><p> Create an <a>event</a> that uses the interface the constructor was invoked upon.

  <li><p> Set its <a>initialized flag</a>.

  <li><p> Initialize the <code><a>type</a></code> attribute to the <var>type</var> argument.

  <li><p> If there is an <var>eventInitDict</var> argument then for each <a>dictionary member</a> present, find the attribute on <a>event</a> whose <a>identifier</a> matches the key of the <a>dictionary member</a> and then set the attribute to the value of that <a>dictionary member</a>.

  <li><p> Return the <a>event</a>.

</ol>

<h3 id="events-defining-event-interfaces">Defining event interfaces</h3>

In general, when defining a new interface that inherits from <code><a>Event</a></code> please always ask feedback from the WHATWG or the
W3C www-dom@w3.org mailing list.

The <code><a>CustomEvent</a></code> interface can be used as starting point. However, do not introduce any <code>init<var>*</var>Event()</code> methods as they are redundant with constructors. Interfaces that inherit from the <code><a>Event</a></code> interface that have such a method only have it for historical reasons.

<h3 id="events-interface-eventtarget">Interface <code><a>EventTarget</a></code></h3>

<pre class="idl">
[Exposed=(Window,Worker)]
interface EventTarget {
  void addEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
  void removeEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
  boolean dispatchEvent(Event event);
};

callback interface EventListener {
  void handleEvent(Event event);
};
</pre>

<p><code><a>EventTarget</a></code> is an object to which an <a>event</a> is <a>dispatched</a> when something has occurred. Each <code><a>EventTarget</a></code> has an associated list of <a>event listeners</a>.

<p>An <dfn lt="DOM event listener|event listener">event listener</dfn> associates a callback with a specific <a>event</a>. Each <a>event listener</a> consists of a <b>type</b> (of the <a>event</a>), <b>callback</b>, and <b>capture</b> variable.

<p class="note">Note: The <b>callback</b> is named <code><dfn>EventListener</dfn></code> for historical reasons. As can be seen from the definition above, an <a>event listener</a> is a more broad concept.

<dl>
  <dt><code><var>target</var> . <a>addEventListener</a>(<var>type</var>, <var>callback</var> [, <var>capture</var> = false])</code>
  <dd>
  <p>Appends an <a>event listener</a> for <a>events</a> whose <code><a>type</a></code> attribute value is <var>type</var>. The <var>callback</var> argument sets the <b>callback</b> that will be invoked when the <a>event</a> is <a>dispatched</a>. When set to true, the <var>capture</var> argument prevents <b>callback</b> from being invoked if the <a>event</a>'s <code><a>eventPhase</a></code> attribute value is <code><a>BUBBLING_PHASE</a></code>. When false, <b>callback</b> will not be invoked when <a>event</a>'s <code><a>eventPhase</a></code> attribute value is <code><a>CAPTURING_PHASE</a></code>. Either way, <b>callback</b> will be invoked when <a>event</a>'s <code><a>eventPhase</a></code> attribute value is <code><a>AT_TARGET</a></code>.

  <p>The <a>event listener</a> is appended to <var>target</var>'s list of
  <a>event listeners</a> and is not appended if it is a duplicate, i.e. having the same <b>type</b>, <b>callback</b>, and <b>capture</b> values.

  <dt><var>target</var> . <a>removeEventListener</a>(<var>type</var>, <var>callback</var> [, <var>capture</var> = false])</code>
  <dd>Remove the <a>event listener</a> in <var>target</var>'s list of <a>event listeners</a> with the same <var>type</var>, <var>callback</var>, and <var>capture</var>.

  <dt><code><var>target</var> . <a>dispatchEvent</a>(<var>event</var>)</code>
  <dd><a>Dispatches</a> a synthetic event <var>event</var> to <var>target</var> and returns true if either <var>event</var>'s <code><a>cancelable</a></code> attribute value is false or its <code><a>preventDefault()</a></code> method was not invoked, and false otherwise.
</dl>

<p>The
<dfn><code>addEventListener(<var>type</var>, <var>callback</var>, <var>capture</var>)</code></dfn>
method must run these steps:
<ol>
  1. If <var>callback</var> is null, terminate these steps.
  2. Append an <a>event listener</a> to the associated list of <a>event listeners</a> with <b>type</b> set to <var>type</var>, <b>callback</b> set to <var>callback</var>, and <b>capture</b> set to <var>capture</var>, unless there already is an <a>event listener</a> in that list with the same <b>type</b>, <b>callback</b>, and <b>capture</b>.

</ol>

<p>The
<dfn><code>removeEventListener(<var>type</var>, <var>callback</var>, <var>capture</var>)</code></dfn>
method must run these steps:
<ol>
  1. Remove an <a>event listener</a> from the associated list of <a>event listeners</a>, whose <b>type</b> is <var>name</var>, <b>callback</b> is <var>callback</var>, and <b>capture</b> is <var>capture</var>.</p>

</ol>

<p>The
<dfn><code>dispatchEvent(<var>event</var>)</code></dfn>
method must run these steps:
<ol>
  1. If <var>event</var>'s <a>dispatch flag</a> is set, or if its <a>initialized flag</a> is not set, <a>throw</a> an "<code>InvalidStateError</code>".[[!WEBIDL]]
  2. Initialize <var>event</var>'s <code><a>isTrusted</a></code> attribute to false.
  3. <a>Dispatch</a> the <var>event</var> and return the value that returns.

</ol>

<h3 id="events-dispatching-events">Dispatching events</h3>

<p>To <dfn>dispatch</dfn> an <a>event</a> to a given object, with an optional <var>target override</var>, run these steps:

<ol>
  <li>Let <var>event</var> be the <a>event</a> that is dispatched.

  <li>Set <var>event</var>'s <a>dispatch flag</a>.

  <li>Initialize <var>event</var>'s <code><a>target</a></code> attribute to <var>target override</var>, if it is given, and the object to which <var>event</var> is dispatched otherwise.

  <li>If <var>event</var>'s <code><a>target</a></code> attribute value is <a>participating</a> in a <a>tree</a>, let <var>event path</var> be a static ordered list of all its <a>ancestors</a> in <a>tree order</a>, and let <var>event path</var> be the empty list otherwise.

  <li>Initialize <var>event</var>'s <code><a>eventPhase</a></code> attribute to <code><a>CAPTURING_PHASE</a></code>.

  <li>For each object in <var>event path</var>, <a>invoke</a> its <a>event listeners</a> with event <var>event</var>, as long as <var>event</var>'s <a>stop propagation flag</a> is unset.

  <li>Initialize <var>event</var>'s <code><a>eventPhase</a></code> attribute to <code><a>AT_TARGET</a></code>.

  <li><a>Invoke</a> the <a>event listeners</a> of <var>event</var>'s <code><a>target</a></code> attribute value with <var>event</var>, if <var>event</var>'s <a>stop propagation flag</a> is unset.

  <li>If <var>event</var>'s <code><a>bubbles</a></code> attribute value is true, run these substeps:

  <ol>
    1. Reverse the order of <var>event path</var>.

    2. Initialize <var>event</var>'s <code><a>eventPhase</a></code> attribute to <code><a>BUBBLING_PHASE</a></code>.

    3. For each object in <var>event path</var>, <a>invoke</a> its <a>event listeners</a>, with event <var>event</var> as long as <var>event</var>'s <a>stop propagation flag</a> is unset.

  </ol>

  <li>Unset <var>event</var>'s <a>dispatch flag</a>.

  <li>Initialize <var>event</var>'s <code><a>eventPhase</a></code> attribute to <code><a>NONE</a></code>.

  <li>Initialize <var>event</var>'s <code><a>currentTarget</a></code> attribute to null.

  <li>Return false if <var>event</var>'s <a>canceled flag</a> is set, and true otherwise.

</ol>


<p>To <dfn lt="listener invoke|event listener invoke|invoke|invokes|invoked">invoke</dfn> the <a>event listeners</a> for an object with an
event run these steps:</p>
<ol>
  <li>Let <var>event</var> be the <a>event</a> for which the <a>event listeners</a> are invoked.
  <li>Let <var>listeners</var> be a copy of the <a>event listeners</a> associated with the object for which these steps are run.
  <li>Initialize <var>event</var>'s <code><a>currentTarget</a></code> attribute to the object for which these steps are run.
  <li>Then run these substeps for each <a>event listener</a> in <var>listeners</var>:

  <ol>
    1. If <var>event</var>'s <a>stop immediate propagation flag</a> is set, terminate the <a>invoke</a> algorithm.
    2. Let <var>listener</var> be the <a>event listener</a>.
    3. If <var>event</var>'s <code><a>type</a></code> attribute value is not <var>listener</var>'s <b>type</b>, terminate these substeps (and run them for the next <a>event listener</a>).
    4. If <var>event</var>'s <code><a>eventPhase</a></code> attribute value is <code><a>CAPTURING_PHASE</a></code> and <var>listener</var>'s <b>capture</b> is false, terminate these substeps (and run them for the next <a>event listener</a>).
    5. If <var>event</var>'s <code><a>eventPhase</a></code> attribute value is <code><a>BUBBLING_PHASE</a></code> and <var>listener</var>'s <b>capture</b> is true, terminate these substeps (and run them for the next <a>event listener</a>).
    6. Call <var>listener</var>'s <b>callback</b>'s <code>handleEvent</code>, with the event passed to this algorithm as the first argument and <var>event</var>'s <code><a>currentTarget</a></code> attribute value as <a>callback this value</a>. If this throws any exception, <a>report the exception</a>.
  </ol>
 </li>
</ol>

<h3 id="action-versus-occurance">Action versus occurrence</h3>

<p>An <a>event</a> signifies an occurrence, not an action. Phrased differently, it
represents a notification from an algorithm and can be used to influence the future course
of that algorithm (e.g., through invoking <a>preventDefault()</a>). <a>Events</a> must not be
used as actions or initiators that cause some algorithm to start running. That is not what
they are for.

<p class="note no-backref">This is called out here specifically because previous
iterations of the DOM had a concept of "default actions" associated with <a>events</a>
that gave folks all the wrong ideas. <a>Events</a> do not represent or cause actions, they
can only be used to influence an ongoing one.

</section>
