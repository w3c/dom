<section>
<h2 id="nodes">Nodes</h2>

<h3 id="nodes-introduction-to-the-dom">Introduction to "The DOM"</h3>

<p>In its original sense, "The DOM" is an API for accessing and manipulating documents (in particular, HTML and XML documents). In this specification, the term "document" is used for any markup-based resource, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications.

<p>These documents are presented as a <a>node tree</a>. Some of the <a>nodes</a> in the <a>tree</a> can have <a>children</a>, while others are always leaves.

<p>To illustrate, consider this HTML document:

<pre class='example'><code>&lt;!DOCTYPE html&gt;
&lt;html class=e&gt;
 &lt;head&gt;&lt;title&gt;Aliens?&lt;/title&gt;&lt;/head&gt;
 &lt;body&gt;Why yes.&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>It is represented as follows:

<ul class="domTree">
 <li>
  <a>Document</a>
  <ul>
   <li class="t10"><a>Doctype</a>: <code>html</code></li>
   <li class="t1"><a>Element</a>: <code>html</code> <span class="t2"><code class="attribute name">class</code>="<code class="attribute value">e</code>"</span>
    <ul>
     <li class="t1">
      <a>Element</a>: <code>head</code>
      <ul>
       <li class="t1">
        <a>Element</a>: <code>title</code>
        <ul>
         <li class="t3"><code><a>Text</a></code>: <span>Aliens?</span></li>
        </ul>
       </li>
      </ul>
     </li>
     <li class="t3"><code><a>Text</a></code>: <span>⏎␣</span></li>
     <li class="t1">
      <a>Element</a>: <code>body</code>
      <ul>
       <li class="t3"><code><a>Text</a></code>: <span>Why yes.⏎</span></li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

<!--
http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0D%0A%3Chtml%20class%3De%3E%0D%0A%20%3Chead%3E%3Ctitle%3EAliens%3F%3C%2Ftitle%3E%3C%2Fhead%3E%0D%0A%20%3Cbody%3EWhy%20yes.%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E
-->

<p>Note that, due to the magic of <a>HTML parser</a>, not all <a>ASCII whitespace</a> were turned into <code><a>Text</a></code> <a>nodes</a>, but the general concept is clear. Markup goes in, a <a>tree</a> of <a>nodes</a> comes out.

<p class="note">Note: The most excellent <a href="http://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a> can be used to explore this matter in more detail.

<h3 id="nodes-node-tree">Node tree</h3>
<p>Objects implementing the <code><a>Document</a></code>, <code><a>DocumentFragment</a></code>, <code><a>DocumentType</a></code>, <code><a>Element</a></code>, <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> interface (simply called <dfn lt="node|nodes">nodes</dfn>) <a>participate</a> in a <a>tree</a>, simply named the <dfn>node tree</dfn>.

<p>A <a>node tree</a> is constrained as follows, expressed as a relationship between the type of <a>node</a> and its allowed <a>children</a>:
<dl>
 <dt><code><a>Document</a></code>
 <dd>
  <p>In <a>tree order</a>:
  <ol>
   <li><p>Zero or more nodes each of which is either <code><a>ProcessingInstruction</a></code> or <code><a href="#comment">Comment</a></code>.
   <li><p>Optionally one <code><a>DocumentType</a></code> node.
   <li><p>Zero or more nodes each of which is either <code><a>ProcessingInstruction</a></code> or <code><a>Comment</a></code>.
   <li><p>Optionally one <code><a>Element</a></code> node.
   <li><p>Zero or more nodes each of which is either <code><a>ProcessingInstruction</a></code> or <code><a>Comment</a></code>.
  </ol>
 <dt><code><a>DocumentFragment</a></code>
 <dt><code><a>Element</a></code>
 <dd><p>Zero or more nodes each of which is one of <code><a>Element</a></code>,
 <code><a>ProcessingInstruction</a></code>, <code><a>Comment</a></code>, or
 <code><a>Text</a></code>.
 <dt><code><a>DocumentType</a></code>
 <dt><code><a>Text</a></code>
 <dt><code><a>ProcessingInstruction</a></code>
 <dt><code><a>Comment</a></code>
 <dd><p>None.
</dl>
<!--AttrExodus -->

<p>The <dfn id="node-length" for="node">length</dfn> of a <a>node</a> <var>node</var> depends on <var>node</var>:
<dl class="switch">
 <dt><code><a>DocumentType</a></code>
 <dd><p>Zero.

 <dt><code><a>Text</a></code>
 <dt><code><a>ProcessingInstruction</a></code>
 <dt><code><a>Comment</a></code>
 <dd><p>Its <code><a href="#characterdata-length">length</a></code> attribute
 value.

 <dt>Any other node
 <dd><p>Its number of <a>children</a>.
</dl>

<p>A <a>node</a> is considered <dfn>empty</dfn> if its <a href="#node-length">length</a> is zero.

<h4 id="mutation-algorithms">Mutation algorithms</h4>

<p>To <dfn>ensure pre-insertion validity</dfn> of a <var>node</var> into a <var>parent</var> before a <var>child</var>, run these steps:

<ol>
 <li><p>If <var>parent</var> is not a <code><a>Document</a></code>, <code><a>DocumentFragment</a></code>, or <code><a>Element</a></code> <a>node</a>,
 <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

 <li><p>If <var>node</var> is a <a>host-including inclusive ancestor</a> of <var>parent</var>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

 <li><p>If <var>child</var> is not null and its <a>parent</a> is not <var>parent</var>, <a>throw</a> a "<code><a>NotFoundError</a></code>".

 <li><p>If <var>node</var> is not a <code><a>DocumentFragment</a></code>, <code><a>DocumentType</a></code>, <code><a>Element</a></code>, <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, or <code><a>Comment</a></code> <a>node</a>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

 <li><p>If either <var>node</var> is a <code><a>Text</a></code> <a>node</a> and <var>parent</var> is a <a>document</a>, or <var>node</var> is a <a>doctype</a> and <var>parent</var> is not a <a>document</a>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

 <li>
  <p>If <var>parent</var> is a <a>document</a>, and any of the statements below, switched on <var>node</var>, are true, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

  <dl class="switch">
   <dt><code><a>DocumentFragment</a></code> <a>node</a>
   <dd>
    <p>If <var>node</var> has more than one <a>element</a> <a>child</a> or has a <code><a>Text</a></code> <a>node</a> <a>child</a>.

    <p>Otherwise, if <var>node</var> has one <a>element</a> <a>child</a> and either <var>parent</var> has an <a>element</a> <a>child</a>, <var>child</var> is a <a>doctype</a>, or <var>child</var> is not null and a <a>doctype</a> is <a>following</a> <var>child</var>.

   <dt><a>element</a> <dd><p><var>parent</var> has an <a>element</a> <a>child</a>, <var>child</var> is a <a>doctype</a>, or <var>child</var> is not null and a <a>doctype</a> is <a>following</a> <var>child</var>.

   <dt><a>doctype</a> <dd><p><var>parent</var> has a <a>doctype</a> <a>child</a>, <var>child</var> is non-null and an <a>element</a> is <a>preceding</a> <var>child</var>, or <var>child</var> is null and <var>parent</var> has an <a>element</a> <a>child</a>.
  </dl>
</ol>

<p>To <dfn>pre-insert</dfn> a <var>node</var> into a <var>parent</var> before a <var>child</var>, run these steps:

<ol>
 <li><p><a>Ensure pre-insertion validity</a> of <var>node</var> into <var>parent</var> before <var>child</var>.

 <li><p>Let <var>reference child</var> be <var>child</var>.

 <li><p>If <var>reference child</var> is <var>node</var>, set it to <var>node</var>'s <a href="#tree-next-sibling">next sibling</a>.

 <li><p><a>Adopt</a> <var>node</var> into <var>parent</var>'s <a>node document</a>.

 <li><p><a>Insert</a> <var>node</var> into <var>parent</var> before <var>reference child</var>.

 <li><p>Return <var>node</var>.
</ol>

<p><a>Specifications</a> may define <dfn>insertion steps</dfn> for all or some <a>nodes</a>. The algorithm is passed <var>newNode</var>, as indicated in the <a href="#node-insert">insert</a> algorithm below.

<p>To <dfn id="node-insert" for="node">insert</dfn> a <var>node</var> into a <var>parent</var> before a <var>child</var> with an optional <i>suppress observers flag</i>, run these steps:

<ol>
 <li><p>Let <var>count</var> be the number of <a>children</a> of <var>node</var> if it is a <code><a>DocumentFragment</a></code> <a>node</a>, and one otherwise.

 <li>
  <p>If <var>child</var> is non-null, run these substeps:

  <ol>
   <li><p>For each <a>range</a> whose <a>start node</a> is <var>parent</var> and <a>start offset</a> is greater than <var>child</var>'s <a>index</a>, increase its <a>start offset</a> by <var>count</var>.

   <li><p>For each <a>range</a> whose <a>end node</a> is <var>parent</var> and <a>end offset</a> is greater than <var>child</var>'s <a>index</a>, increase its <a>end offset</a> by <var>count</var>.
  </ol>

 <li><p>Let <var>nodes</var> be <var>node</var>'s <a>children</a> if <var>node</var> is a <code><a>DocumentFragment</a></code> <a>node</a>, and a list containing solely <var>node</var> otherwise.

 <li><p>If <var>node</var> is a <code><a>DocumentFragment</a></code> <a>node</a>, <a href="#node-remove">remove</a> its <a>children</a> with the <i>suppress observers flag</i> set.
  <p>If <var>node</var> is a <code><a>DocumentFragment</a></code> <a>node</a>, <a>queue a mutation record</a> of "<code>childList</code>" for <var>node</var> with removedNodes <var>nodes</var>.

  <p class="note">Note: This step intentionally does not pay attention to the <i>suppress observers flag</i>.
 <li>
  <p>For each <var>newNode</var> in <var>nodes</var>, in <a>tree order</a>, run these substeps:

  <ol>
   <li><p>Insert <var>newNode</var> into <var>parent</var> before <var>child</var> or at the end of <var>parent</var> if <var>child</var> is null.

   <li><p>Run the <a>insertion steps</a> with <var>newNode</var>.
   <li><p>For each <a>inclusive descendant</a> <var>inclusiveDescendant</var> of <var>node</var>, in <a>tree order</a>, run the <a>insertion steps</a> with <var>inclusiveDescendant</var> and <var>parent</var>.
  </ol>
 <li><p>If <i>suppress observers flag</i> is unset, <a>queue a mutation record</a> of "<code>childList</code>" for <var>parent</var> with addedNodes <var>nodes</var>, nextSibling <var>child</var>, and previousSibling <var>child</var>'s <a href="#tree-previous-sibling">previous sibling</a> or <var>parent</var>'s <a>last child</a> if <var>child</var> is null.

</ol>


<p>To <dfn id="node-append" for="node">append</dfn> a <var>node</var> to a <var>parent</var>, <a>pre-insert</a> <var>node</var> into <var>parent</var> before null.

<p>To <dfn>replace</dfn> a <var>child</var> with <var>node</var> within a <var>parent</var>, run these steps:

<ol>
 <li><p>If <var>parent</var> is not a {{Document}}, {{DocumentFragment}}, or {{Element}} <a href="#concept-node">node</a>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

 <li><p>If <var>node</var> is a <a>host-including inclusive ancestor</a> of <var>parent</var>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

 <li><p>If <var>child</var>'s <a>parent</a> is not <var>parent</var>, <a>throw</a> a "<code><a>NotFoundError</a></code>".

 <li><p>If <var>node</var> is not a {{DocumentFragment}}, {{DocumentType}}, {{Element}}, {{Text}}, {{ProcessingInstruction}}, or {{Comment}} <a href="#concept-node">node</a>, <a>throw</a> a "{{HierarchyRequestError}}".

 <li><p>If either <var>node</var> is a {{Text}} <a href="#concept-node">node</a> and <var>parent</var> is a <a href="#concept-document">document</a>, or <var>node</var> is a <a href="#concept-doctype">doctype</a> and <var>parent</var> is not a <a href="#concept-document">document</a>, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

 <li>
  <p>If <var>parent</var> is a <a href="#concept-document">document</a>, and any of the statements below, switched on <var>node</var>, are true, <a>throw</a> a "<code><a>HierarchyRequestError</a></code>".

  <dl class="switch">
   <dt>{{{DocumentFragment}}} <a href="#concept-node">node</a>
   <dd>
    <p>If <var>node</var> has more than one <a href="#concept-element">element</a> <a>child</a> or has a {{Text}} <a href="#concept-node">node</a> <a>child</a>.

    <p>Otherwise, if <var>node</var> has one <a href="#concept-element">element</a> <a>child</a> and either <var>parent</var> has an <a href="#concept-element">element</a> <a>child</a> that is not <var>child</var> or a <a href="#concept-doctype">doctype</a> is <a>following</a> <var>child</var>.

   <dt><a href="#concept-element">element</a> <dd><p><var>parent</var> has an <a href="#concept-element">element</a> <a>child</a> that is not <var>child</var> or a <a href="#concept-doctype">doctype</a> is <a>following</a> <var>child</var>.

   <dt><a href="#concept-doctype">doctype</a> <dd><var>parent</var> has a <a href="#concept-doctype">doctype</a> <a>child</a> that is not <var>child</var>, or an <a href="#concept-element">element</a> is <a>preceding</a> <var>child</var>.
  </dl>

  <p class="note">Note: The above statements differ from the <a>pre-insert</a> algorithm.

 <li><p>Let <var>reference child</var> be <var>child</var>'s <a href="#tree-next-sibling">next sibling</a>.

 <li><p>If <var>reference child</var> is <var>node</var>, set it to <var>node</var>'s <a href="#tree-next-sibling">next sibling</a>.

 <li><p>Let <var>previousSibling</var> be <var>child</var>'s <a>previous sibling</a>.

 <li><p><a>Adopt</a> <var>node</var> into <var>parent</var>'s <a>node document</a>.

 <li>Let <var>removedNodes</var> be the empty list.

 <li>
  <p>If <var>child</var>'s <a>parent</a> is not null, run these substeps:

  <ol>
   <li><p>Set <var>removedNodes</var> to a list solely containing <var>child</var>.

   <li><p><a href="#node-remove">Remove</a> <var>child</var> from its <var>parent</var> with the
   <i>suppress observers flag</i> set.
  </ol>

  <p class="note no-backref">The above can only be false if <var>child</var> is <var>node</var>.

 <li>Let <var>nodes</var> be <var>node</var>'s <a>children</a> if <var>node</var> is a
 {{DocumentFragment}} <a href="#concept-node">node</a>, and a list containing solely <var>node</var> otherwise.

 <li><p><a href="#node-insert">Insert</a> <var>node</var> into <var>parent</var> before <var>reference child</var> with the <i>suppress observers flag</i> set.

 <li><p><a>Queue a mutation record</a> of "<code>childList</code>" for target <var>parent</var> with addedNodes <var>nodes</var>, removedNodes a list solely containing <var>child</var>, nextSibling <var>reference child</var>, and previousSibling <var>previousSibling</var>.

 <li><p>Return <var>child</var>.
</ol>


<p>To <dfn>replace all</dfn> with a <var>node</var> within a <var>parent</var>, run these steps:

<ol>
 <li><p>If <var>node</var> is not null, <a>adopt</a> <var>node</var> into <var>parent</var>'s <a>node document</a>.

 <li><p>Let <var>removedNodes</var> be <var>parent</var>'s <a>children</a>.

 <li><p>Let <var>addedNodes</var> be the empty list if <var>node</var> is null, <var>node</var>'s <a>children</a> if <var>node</var> is a <code><a>DocumentFragment</a></code> <a>node</a>, and a list containing <var>node</var> otherwise.

 <li><p><a href="#node-remove">Remove</a> all <var>parent</var>'s <a>children</a>, in <a>tree order</a>, with the <i>suppress observers flag</i> set.

 <li><p>If <var>node</var> is not null, <a href="#node-insert">insert</a> <var>node</var> into <var>parent</var> before null with the <i>suppress observers flag</i> set.

 <li><p><a>Queue a mutation record</a> of "<code>childList</code>" for <var>parent</var> with addedNodes <var>addedNodes</var> and removedNodes <var>removedNodes</var>.
</ol>

<p class="note">Note: This algorithm does not make any checks with regards to the <a>node tree</a> constraints. Specification authors need to use it wisely.


<p>To <dfn>pre-remove</dfn> a <var>child</var> from a <var>parent</var>, run these steps:</p>

<ol>
 <li><p>If <var>child</var>'s <a>parent</a> is not <var>parent</var>, <a>throw</a> a "<code><a>NotFoundError</a></code>".

 <li><p><a href="#node-remove">Remove</a> <var>child</var> from <var>parent</var>.

 <li><p>Return <var>child</var>.
</ol>


<p><a>Specifications</a> may define <dfn>removing steps</dfn> for all or some <a>nodes</a>. The algorithm is passed <var>removedNode</var>, <var>oldParent</var>, and <var>oldPreviousSibling</var>, as indicated in the <a href="#node-remove">remove</a> algorithm below.

<p>To <dfn id="node-remove" for="node">remove</dfn> a <var>node</var> from a <var>parent</var> with an optional <i>suppress observers flag</i> set, run these steps:

<ol>
 <li><p>Let <var>index</var> be <var>node</var>'s <a>index</a>.

 <li><p>For each <a>range</a> whose <a>start node</a> is an <a>inclusive descendant</a> of <var>node</var>, set its <a>start</a> to (<var>parent</var>, <var>index</var>).

 <li><p>For each <a>range</a> whose <a>end node</a> is an <a>inclusive descendant</a> of <var>node</var>, set its <a>end</a> to (<var>parent</var>, <var>index</var>).

 <li><p>For each <a>range</a> whose <a>start node</a> is <var>parent</var> and <a>start offset</a> is greater than <var>index</var>, decrease its <a>start offset</a> by one.

 <li><p>For each <a>range</a> whose <a>end node</a> is <var>parent</var> and <a>end offset</a> is greater than <var>index</var>, decrease its <a>end offset</a> by one.

 <li><p>Let <var>oldPreviousSibling</var> be <var>node</var>'s <a href="#tree-previous-sibling">previous sibling</a>.
 <li><p>Let <var>oldNextSibling</var> be <var>node</var>'s <a href="#tree-next-sibling">next sibling</a>.

 <li><p>Remove <var>node</var> from its <var>parent</var>.

 <li><p>For each <a>inclusive descendant</a> <var>inclusiveDescendant</var> of <var>node</var>, run the <a>removing steps</a> with <var>inclusiveDescendant</var> and <var>parent</var>.
 <li><p>For each <a>inclusive ancestor</a> <var>inclusiveAncestor</var> of <var>node</var>, if <var>inclusiveAncestor</var> has any <a>registered observers</a> whose <b>options</b>' <code>subtree</code> is true, then for each such <a>registered observer</a> <var>registered</var>, append a <a>transient registered observer</a> whose <b>observer</b> and <b>options</b> are identical to those of <var>registered</var> and <b>source</b> which is <var>registered</var> to <var>node</var>'s list of <a>registered observers</a>.

 <li><p>If <i>suppress observers flag</i> is unset, <a>queue a mutation record</a> of "<code>childList</code>" for <var>parent</var> with removedNodes a list solely containing <var>node</var>, nextSibling <var>oldNextSibling</var>, and previousSibling <var>oldPreviousSibling</var>.

</ol>

<h4 id="interface-nonelementparentnode">Interface <code><a>NonElementParentNode</a></code></h4>

<p class="note">Note: The <code><a>getElementById()</a></code> method is not on <a>elements</a> for compatibility with older versions of jQuery. If a time comes where that version of jQuery has disappeared, we might be able to support it.

<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface NonElementParentNode {
  Element? getElementById(DOMString elementId);
};
Document implements NonElementParentNode;
DocumentFragment implements NonElementParentNode;
</pre>

<dl>
 <dt><code><var>node</var> . <a>getElementById</a>(<var>elementId</var>)</code>
 <dd><p>Returns the first <a>element</a> within <var>node</var>'s <a>descendants</a> whose <a>ID</a> is <var>elementId</var>.
</dl>

<p>The <dfn><code>getElementById(<var>elementId</var>)</code></dfn> method must return the first <a>element</a>, in <a>tree order</a>, within <a>context object</a>'s <a>descendants</a>, whose <a>ID</a> is <var>elementId</var>, and null if there is no such <a>element</a> otherwise.

<h4 id="interface-parentnode">Interface <code><a>ParentNode</a></code></h4>

<p>The <dfn>mutation method macro</dfn>:

<ol>
 <li><p>Let <var>node</var> be null.

 <li><p>Replace each string in <var>nodes</var> with a <code><a>Text</a></code> <a>node</a> whose <a>data</a> is the string value.

 <li>
  <p>If <var>nodes</var> contains more than one <a>node</a>, set <var>node</var> to a new <code><a>DocumentFragment</a></code> and <a>append</a> each <a>node</a> in <var>nodes</var> to it. Rethrow any exceptions.

  <p>Otherwise, set <var>node</var> to the single <a>node</a> <var>nodes</var> contains.
</ol>

<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface ParentNode {
  [SameObject] readonly attribute HTMLCollection children;
  readonly attribute Element? firstElementChild;
  readonly attribute Element? lastElementChild;
  readonly attribute unsigned long childElementCount;

  Element? querySelector(DOMString selectors);
  [NewObject] NodeList querySelectorAll(DOMString selectors);
};
Document implements ParentNode;
DocumentFragment implements ParentNode;
Element implements ParentNode;
</pre>

<dl>
 <dt><code><var>collection</var> = <var>node</var> . <a href="#parentnode-children">children</a></code> 
 <dd><p>Returns the <a>child</a><a>elements</a>.

 <dt><code><var>element</var> = <var>node</var> . <a>firstElementChild</a></code>
 <dd><p>Returns the first <a>child</a> that is an <a>element</a>, and null otherwise.

 <dt><code><var>element</var> = <var>node</var> . <a>lastElementChild</a></code>
 <dd><p>Returns the last <a>child</a> that is an <a>element</a>, and null otherwise.

 <!-- childElementCount is redundant -->

 <dt><code><var>node</var> . <a>querySelector</a>(<var>selectors</var>)</code>
 <dd><p>Returns the first <a>element</a> that is a <a>descendant</a> of <var>node</var> that matches <var>selectors</var>.

 <dt><code><var>node</var> . <a>querySelectorAll</a>(<var>selectors</var>)</code>
 <dd><p>Returns all <a>element</a> <a>descendants</a> of <var>node</var> that match <var>selectors</var>.
</dl>

<p>The <dfn id="parentnode-children" for="parentnode"><code>children</code></dfn> attribute must return an <code>{{HTMLCollection}}</code> <a>collection</a> rooted at the <a>context object</a> matching only <a>element</a> <a>children</a>.

<p>The <dfn><code>firstElementChild</code></dfn> attribute must return the first <a>child</a> that is an <a>element</a>, and null otherwise.

<p>The <dfn><code>lastElementChild</code></dfn> attribute must return the last <a>child</a> that is an <a>element</a>, and null otherwise.

<p>The <dfn><code>childElementCount</code></dfn> attribute must return the number of <a>children</a> of the <a>context object</a> that are <a>elements</a>.

<p>The <dfn><code>querySelector(<var>selectors</var>)</code></dfn> method, when invoked, must return the first result of running <a>scope-match a selectors string</a> <var>selectors</var> against the <a>context object</a>, and null if the result is an empty list otherwise.

<p>The <dfn><code>querySelectorAll(<var>selectors</var>)</code></dfn> method, when invoked, must return the <a>static</a> result of running <a>scope-match a selectors string</a> <var>selectors</var> against the <a>context object</a>.

<h4 id="interface-nondocumenttypechildnode">Interface <code><a >NonDocumentTypeChildNode</a></code></h4>

<p class="note">Note: The <code><a>previousElementSibling</a></code> and <code><a>nextElementSibling</a></code> attributes have been removed from <code><a>DocumentType</a></code> nodes for compatibility reasons. If these additions are deemed compatible enough in the future, they could be reinstated.

<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface NonDocumentTypeChildNode {
  readonly attribute Element? previousElementSibling;
  readonly attribute Element? nextElementSibling;
};
Element implements NonDocumentTypeChildNode;
CharacterData implements NonDocumentTypeChildNode;
</pre>

<dl>
<dt><code><var>element</var> = <var>node</var> . <a>previousElementSibling</a></code>
 <dd><p>Returns the first <a>preceding</a> <a>sibling</a> that is an <a>element</a>, and null otherwise.

 <dt><code><var>element</var> = <var>node</var> . <a>nextElementSibling</a></code>
 <dd><p>Returns the first <a>following</a> <a>sibling</a> that is an <a>element</a>, and null otherwise.
</dl>

<p>The <dfn><code>previousElementSibling</code></dfn> attribute must return the first <a>preceding</a> <a>sibling</a> that is an <a>element</a>, and null otherwise.

<p>The <dfn><code>nextElementSibling</code></dfn> attribute must return the first <a>following</a> <a>sibling</a> that is an <a>element</a>, and null otherwise.

<h4 id="interface-childnode">Interface <code><a>ChildNode</a></code></h4>
<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface ChildNode {
  void remove();
};
DocumentType implements ChildNode;
Element implements ChildNode;
CharacterData implements ChildNode;
</pre>

<dl>
 <dt><code><var>node</var> . <a>remove</a>()</code>
 <dd><p>Removes <var>node</var>.
</dl>

<p>The <dfn id="node-contains-func" for="node"><code>remove()</code></dfn> method must run these steps:

<ol>
 <li><p>If the <a>context object</a> does not have a <a>parent</a>, terminate these steps.

 <li><p><a href="#node-remove">Remove</a> the <a>context object</a> from the <a>context object</a>'s <a>parent</a>.
</ol>

<h4 id="old-style-collections:-nodelist-and-htmlcollection">Old-style collections: <code><a>NodeList</a></code> and <code><a>HTMLCollection</a></code></h4>

<p>A <dfn>collection</dfn> is an object that represents a lists of DOM nodes. A <a>collection</a> can be either <dfn>live</dfn> or <dfn>static</dfn>. Unless otherwise stated, a <a>collection</a> must be <a>live</a>.

<p>If a <a>collection</a> is <a>live</a>, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.

<p>When a <a>collection</a> is created, a filter and a root are associated with it.

<p>The <a>collection</a> then <dfn>represents</dfn> a view of the subtree rooted at the <a>collection's</a> root, containing only nodes that match the given filter. The view is linear. In the absence of specific requirements to the contrary, the nodes within the <a>collection</a> must be sorted in <a>tree order</a>.

<h5 id="interface-nodelist">Interface <code><a>NodeList</a></code></h5>

<p>A <code><a>NodeList</a></code> object is a <a>collection</a> of <a>nodes</a>.

<pre class='idl'>
[Exposed=Window]
interface NodeList {
  getter Node? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable<Node>;
};
</pre>

<dl>
 <dt><var>collection</var> . <code><a href="#nodelist-length">length</a></code>
 <dd><p>Returns the number of <a>nodes</a> in the <a>collection</a>.

 <dt><var>element</var> = <var>collection</var> . <code><a>item</a></code>(<var>index</var>)
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd><p>Returns the <a>node</a> with index <var>index</var> from the <a>collection</a>. The <a>nodes</a> are sorted in <a>tree order</a>.
</dl>

<div>

<p>The object's <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-indices">supported property indices</a> are the numbers in the range zero to one less than the number of nodes <a>represented by the collection</a>. If there are no such elements, then there are no <a>supported property indices</a>.

<p>The <dfn id="nodelist-length" for="nodeList"><code>length</code></dfn> attribute must return the number of nodes <a>represented by the collection</a>.

<p>The <dfn id="nodelist-item-func" for="nodelist"><code>item(<var>index</var>)</code></dfn> method must return the <var>index</var>th node in the <a>collection</a>. If there is no <var>index</var>th node in the <a>collection</a>, then the method must return null.

</div>

<h5 id="interface-htmlcollection">Interface <code><a>HTMLCollection</a></code></h5>

<pre class='idl'>
[Exposed=Window]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter Element? item(unsigned long index);
  getter Element? namedItem(DOMString name);
};
</pre>

<p>An {{HTMLCollection}} object is a <a>collection</a> of <a href="#concept-element">elements</a>.

<p class="note">Note: {{HTMLCollection}} is an historical artifact we cannot rid the web of.
 While developers are of course welcome to keep using it, new API standard designers ought not to use
 it (use <code>sequence&lt;T></code> in IDL instead).

<dl>
 <dt><var>collection</var> . <code><a href="#htmlcollection-length">length</a></code>
 <dd><p>Returns the number of <a href="#concept-element">elements</a> in the <a>collection</a>.

 <dt><var>element</var> = <var>collection</var> . <code><a>item</a></code>(<var>index</var>)
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd><p>Returns the <a>element</a> with index <var>index</var> from the <a>collection</a>. The <a>elements</a> are sorted in <a>tree order</a>.

 <dt><var>element</var> = <var>collection</var> . <code><a>namedItem</a></code>(<var>name</var>)
 <dt><var>element</var> = <var>collection</var>[<var>name</var>]
 <dd><p>Returns the first <a>element</a> with <a>ID</a> or name <var>name</var>from the collection.
</dl>

<div>

<p>The object's <a>supported property indices</a> are the numbers in the range zero to one less than the number of elements <a>represented by the collection</a>. If there are no such elements, then there are no <a>supported property indices</a>.

<p>The <dfn id="htmlcollection-length" for="HTMLCollection"><code>length</code></dfn> attribute's getter must return the number of nodes <a>represented by the collection</a>.

<p>The <dfn id="htmlcollection-item-func" for="HTMLCollection"><code>item(<var>index</var>)</code></dfn> method must return the <var>index</var>th <a>element</a> in the <a>collection</a>. If there is no <var>index</var>th <a>element</a> in the <a>collection</a>, then the method must return null.

<p>The <a>supported property names</a> are the values from the list returned by these steps:

<ol>
 <li><p>Let <var>result</var> be an empty list.
 <li>
  <p>For each <var>element</var> <a>represented by the collection</a>, in <a>tree order</a>, run these substeps:
  <ol>
   <li><p>If <var>element</var> has an <a>ID</a> which is not in <var>result</var>, append
   <var>element</var>'s <a>ID</a> to <var>result</var>.

   <li><p>If <var>element</var> is in the <a>HTML namespace</a> and <a>has</a> a <a href="#named-attribute"><code>name</code> attribute</a> whose <a href="#attribute-value">value</a> is neither the empty string nor is in <var>result</var>, append <var>element</var>'s <a href="#named-attribute"><code>name</code> attribute</a> <a href="#attribute-value">value</a> to <var>result</var>.
  </ol>
 <li><p>Return <var>result</var>.
</ol>

<p>The <dfn><code>namedItem(<var>key</var>)</code></dfn> method must run these steps:
<ol>
 <li>If <var>key</var> is the empty string, return null.</li>
 <li>
  <p>Return the first <a>element</a> in the <a>collection</a> for which at least one of the following is true:
  <ul>
   <li>it has an <a>ID</a> which is <var>key</var>;
   <li>it is in the <a>HTML namespace</a> and <a href="#concept-element-attribute-has" title="concept-element-attribute-has">has</a> a
   <a href="#named-attribute"><code>name</code> attribute</a> whose <a href="#attribute-value">value</a> is <var>key</var>;
  </ul>
  <p>or null if there is no such <a>element</a>.
</ol>

</div>

<h3 id="nodes-mutation-observers">Mutation observers</h3>
<p>Each <a>unit of related similar-origin browsing contexts</a> has a <dfn>mutation observer compound microtask queued flag</dfn>, which is initially unset,
and an associated list of <code><a>MutationObserver</a></code> objects, which is initially empty.

<p>To <dfn>queue a mutation observer compound microtask</dfn>, run these steps:

<ol>
 <li><p>If <a>mutation observer compound microtask queued flag</a> is set, terminate these steps.

 <li><p>Set <a>mutation observer compound microtask queued flag</a>.

 <li><p><a href="http://www.w3.org/TR/html51/webappapis.html#queue-a-microtask">Queue</a> a <a>compound microtask</a> to <a>notify mutation observers</a>.
</ol>

<p>To <dfn>notify mutation observers</dfn>, run these steps:

<ol>
 <li><p>Unset <a>mutation observer compound microtask queued flag</a>.

 <li><p>Let <var>notify list</var> be a copy of <a>unit of related similar-origin browsing contexts</a>' list of <code><a>MutationObserver</a></code> objects.

 <li>
  <p>For each <code><a>MutationObserver</a></code> object <var>mo</var> in <var>notify list</var>, <a>execute a compound microtask subtask</a> to run these steps:

  <ol>
   <li><p>Let <var>queue</var> be a copy of <var>mo</var>'s <a>record queue</a>.

   <li><p>Empty <var>mo</var>'s <a>record queue</a>.

   <li><p>Remove all <a>transient registered observers</a> whose <b>observer</b> is <var>mo</var>.

   <li><p>If <var>queue</var> is non-empty, call <var>mo</var>'s <a>callback</a> with <var>queue</var> as first argument, and <var>mo</var> (itself) as second argument and <a>callback this value</a>. If this throws an exception, <a>report the exception</a>.
  </ol>
</ol>

<hr>

<p>Each <a>node</a> has an associated list of <a>registered observers</a>.

<p>A <dfn>registered observer</dfn> consists of an <b>observer</b> (a <code><a>MutationObserver</a></code> object) and <b>options</b> (a <code><a>MutationObserverInit</a></code> dictionary).
 A <dfn>transient registered observer</dfn> is a specific type of <a>registered observer</a> that has a <b>source</b> which is a <a>registered observer</a>.

<p class="note no-backref"><a>Transient registered observers</a> are used to track
mutations within a given <a>node</a>'s <a>descendants</a> after <a>node</a> has been
removed so they do not get lost when <code>subtree</code> is set to true on <a>node</a>'s
<a>parent</a>.

<h4 id="interface-mutationobserver">Interface <code><a>MutationObserver</a></code></h4>

<pre class='idl'>
[Constructor(MutationCallback callback)]
interface MutationObserver {
  void observe(Node target, MutationObserverInit options);
  void disconnect();
  sequence<MutationRecord> takeRecords();
};

callback MutationCallback = void (sequence<MutationRecord> mutations, MutationObserver observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};
</pre>

<p>A <code><a>MutationObserver</a></code> object can be used to observe mutations to the <a>tree</a> of <a>nodes</a>.

<p>Each <code><a>MutationObserver</a></code> object has these associated concepts:
<ul>
 <li><p>A <dfn>callback</dfn> set on creation.
 <li><p>A list of <a>nodes</a> on which it is a <a>registered observer</a>'s <b>observer</b> that is initially empty.
 <li><p>A list of <code><a>MutationRecord</a></code> objects called the <dfn>record queue</dfn> that is initially empty.
</ul>

<dl>
 <dt><code><var>observer</var> = new <a>MutationObserver</a>(<var>callback</var>)</code>
 <dd><p>Constructs a <code><a>MutationObserver</a></code> object and sets its <a>callback</a> to <var>callback</var>. The <var>callback</var> is invoked with a list of <code><a>MutationRecord</a></code> objects as first argument and the constructed <code><a>MutationObserver</a></code> object as second argument. It is invoked after <a>nodes</a> registered with the <code><a>observe()</a></code> method, are mutated.

 <dt><code><var>observer</var> . <a>observe</a>(<var>target</var>, <var>options</var>)</code>
 <dd><p>Instructs the user agent to observe a given <var>target</var> (a <a>node</a>) and report any mutations based on the criteria given by <var>options</var> (an object).

  <p>The <var>options</var> argument allows for setting mutation observation options via object members. These are the object members that can be used:

  <dl>
   <dt><code>childList</code>
   <dd><p>Set to true if mutations to <var>target</var>'s <a>children</a> are to be observed.

   <dt><code>attributes</code>
   <dd><p>Set to true if mutations to <var>target</var>'s <a href="#concept-attribute">attributes</a> are to be observed. Can be omitted if <code>attributeOldValue</code> and/or <code>attributeFilter</code> is specified.

   <dt><code>characterData</code> <dd><p>Set to true if mutations to <var>target</var>'s <a href="#cd-data">data</a> are to be observed. Can be omitted if <code>characterDataOldValue</code> is specified.

   <dt><code>subtree</code>
   <dd><p>Set to true if mutations to not just <var>target</var>, but also <var>target</var>'s <a>descendants</a> are to be observed.

   <dt><code>attributeOldValue</code>
   <dd><p>Set to true if <code>attributes</code> is true or omitted and <var>target</var>'s <a href="#concept-attribute">attribute</a> <a href="#attribute-value">value</a> before the mutation needs to be recorded.

   <dt><code>characterDataOldValue</code>
   <dd><p>Set to true if <code>characterData</code> is set to true or omitted and <var>target</var>'s <a href="#cd-data">data</a> before the mutation needs to be recorded.

   <dt><code>attributeFilter</code>
   <dd><p>Set to a list of <a href="#concept-attribute">attribute</a> <a>local names</a> (without <a href="#attribute-namespace">namespace</a>) if not all <a href="#concept-attribute">attribute</a> mutations need to be observed and <code>attributes</code> is true or omitted.
  </dl>

 <dt><code><var>observer</var> . <a>disconnect</a>()</code>
 <dd><p>Stops <var>observer</var> from observing any mutations. Until the <code><a>observe()</a></code> method is used again, <var>observer</var>'s <a>callback</a> will not be invoked.

 <dt><code><var>observer</var> . <a>takeRecords</a>()</code>
 <dd><p>Empties the <a>record queue</a> and returns what was in there.
</dl>

<p>The <dfn><code>MutationObserver(<var>callback</var>)</code></dfn> constructor must create a new <code><a>MutationObserver</a></code> object with <a>callback</a> set to <var>callback</var>, append it to the <a>unit of related similar-origin browsing contexts</a>' list of <code><a>MutationObserver</a></code> objects, and then return it.

<p>The <dfn><code>observe(<var>target</var>, <var>options</var>)</code></dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If either <var>options</var>' <code>attributeOldValue</code> or <code>attributeFilter</code> is present and <var>options</var>' <code>attributes</code> is omitted, set <var>options</var>' <code>attributes</code> to true.

 <li><p>If <var>options</var>' <code>characterDataOldValue</code> is present and <var>options</var>' <code>characterData</code> is omitted, set <var>options</var>' <code>characterData</code> to true.

 <li><p>If none of <var>options</var>' <code>childList</code> <code>attributes</code>, and <code>characterData</code> is true, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a> a <code>TypeError</code>.

 <li><p>If <var>options</var>' <code>attributeOldValue</code> is true and <var>options</var>' <code>attributes</code> is false, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a> a JavaScript <code>TypeError</code>.

 <li><p>If <var>options</var>' <code>attributeFilter</code> is present and <var>options</var>' <code>attributes</code> is false, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a> a JavaScript <code>TypeError</code>.

 <li><p>If <var>options</var>' <code>characterDataOldValue</code> is true and <var>options</var>' <code>characterData</code> is false, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a> a JavaScript <code>TypeError</code>.

 <li>
  <p>For each <a>registered observer</a> <var>registered</var> in <var>target</var>'s list of <a>registered observers</a> whose <b>observer</b> is the <a>context object</a>:

  <ol>
   <li><p>Remove all <a>transient registered observers</a> whose <b>source</b> is <var>registered</var>.

   <li><p>Replace <var>registered</var>'s <b>options</b> with <var>options</var>.
  </ol>

 <li><p>Otherwise, add a new <a>registered observer</a> to <var>target</var>'s list of <a>registered observers</a> with the <a>context object</a> as the <b>observer</b> and <var>options</var> as the <b>options</b>, and add <var>target</var> to <a>context object</a>'s list of <a>nodes</a> on which it is registered.
</ol>

<p>The <dfn><code>disconnect()</code></dfn> method must, for each <a>node</a> <var>node</var> in the <a>context object</a>'s list of <a>nodes</a>, remove any <a>registered observer</a> on <var>node</var> for which the <a>context object</a> is the <b>observer</b>, and also empty <a>context object</a>'s <a>record queue</a>.

<p>The <dfn><code>takeRecords()</code></dfn> method must return a copy of the <a>record queue</a> and then empty the <a>record queue</a>.

<h4 id="queuing-a-mutation-record">Queuing a mutation record</h4>
<p>To <dfn>queue a mutation record</dfn> of <var>type</var> for <var>target</var> with one or more of (depends on <var>type</var>) name <var>name</var>, namespace <var>namespace</var>, oldValue <var>oldValue</var>, addedNodes <var>addedNodes</var>, removedNodes <var>removedNodes</var>, previousSibling <var>previousSibling</var>, and nextSibling <var>nextSibling</var>, run these steps:

<ol>
 <li><p>Let <var>interested observers</var> be an initially empty set of <code> {{MutationObserver}} </code> objects optionally paired with a string.

 <li><p>Let <var>nodes</var> be the <a>inclusive ancestors</a> of <var>target</var>.

 <li>
  <p>Then, for each <var>node</var> in <var>nodes</var>, and then for each <var>registered observer</var> (with <var>registered observer</var>'s <b>options</b> as <var>options</var>) in <var>node</var>'s list of <a>registered observers</a>, run these substeps:

  <ol>
   <li>
    <p>If none of the following are true

    <ul class=brief>
     <li><var>node</var> is not <var>target</var> and <var>options</var>' <code>subtree</code> is false

     <li><var>type</var> is "<code>attributes</code>" and <var>options</var>' <code>attributes</code> is false

     <li><var>type</var> is "<code>attributes</code>", <var>options</var>'
     <code>attributeFilter</code> is present, and <var>options</var>' <code>attributeFilter</code>
     does not contain <var>name</var> or <var>namespace</var> is non-null

     <li><var>type</var> is "<code>characterData</code>" and <var>options</var>' <code>characterData</code> is false

     <li><var>type</var> is "<code>childList</code>" and <var>options</var>' <code>childList</code> is false
    </ul>

    <p>then run these subsubsteps:
    <ol>
     <li><p>If <var>registered observer</var>'s <b>observer</b> is not in <var>interested observers</var>, append <var>registered observer</var>'s <b>observer</b> to <var>interested observers</var>.

     <li><p>If either <var>type</var> is "<code>attributes</code>" and <var>options</var>' <code>attributeOldValue</code> is true, or <var>type</var> is "<code>characterData</code>" and <var>options</var>' <code>characterDataOldValue</code> is true, set the paired string of <var>registered observer</var>'s <b>observer</b> in <var>interested observers</var> to <var>oldValue</var>.
    </ol>
  </ol>

 <li>
  <p>Then, for each <var>observer</var> in <var>interested observers</var>:

  <ol>
   <li><p>Let <var>record</var> be a new <code> {{MutationRecord}} </code> object with its <code><a href="#mutationrecord-type">type</a></code> set to <var>type</var> and <code><a href="#mutationrecord-target">target</a></code> set to <var>target</var>.

   <li><p>If <var>name</var> and <var>namespace</var> are given, set <var>record</var>'s <code><a>attributeName</a></code> to <var>name</var>, and <var>record</var>'s <code><a>attributeNamespace</a></code> to <var>namespace</var>.

   <li><p>If <var>addedNodes</var> is given, set <var>record</var>'s <code><a>addedNodes</a></code> to <var>addedNodes</var>.

   <li><p>If <var>removedNodes</var> is given, set <var>record</var>'s <code><a>removedNodes</a></code> to <var>removedNodes</var>,

   <li><p>If <var>previousSibling</var> is given, set <var>record</var>'s <code><a href="#mutationrecord-previoussibling">previousSibling</a></code> to <var>previousSibling</var>.

   <li><p>If <var>nextSibling</var> is given, set <var>record</var>'s <code><a href="#mutationrecord-nextsibling">nextSibling</a></code> to <var>nextSibling</var>.

   <li><p>If <var>observer</var> has a paired string, set <var>record</var>'s <code><a>oldValue</a></code> to <var>observer</var>'s paired string.

   <li><p>Append <var>record</var> to <var>observer</var>'s <a>record queue</a>.
  </ol>

 <li><p><a>Queue a mutation observer compound microtask</a>.
</ol>

<h4 id="interface-mutationrecord">Interface <code><a>MutationRecord</a></code></h4>

<pre class='idl'>
[Exposed=Window]
interface MutationRecord {
  readonly attribute DOMString type;
  [SameObject] readonly attribute Node target;
  [SameObject] readonly attribute NodeList addedNodes;
  [SameObject] readonly attribute NodeList removedNodes;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};
</pre>

<dl>
 <dt><code><var>record</var> . <a href="#mutationrecord-type">type</a></code>
 <dd><p>Returns "<code>attributes</code>" if it was an <a href="#concept-attribute">attribute</a> mutation. "<code>characterData</code>" if it was a mutation to a <code><a>CharacterData</a></code> <a>node</a>. And "<code>childList</code>" if it was a mutation to the <a>tree</a> of <a>nodes</a>.

 <dt><code><var>record</var> . <a href="#mutationrecord-target">target</a></code>
 <dd><p>Returns the <a>node</a> the mutation affected, depending on the <code><a href="#mutationrecord-type">type</a></code>. For "<code>attributes</code>", it is the <a>element</a> whose <a href="#concept-attribute">attribute</a> changed. For "<code>characterData</code>", it is the <code><a>CharacterData</a></code> <a>node</a>. For "<code>childList</code>", it is the  <a>node</a> whose <a>children</a> changed.

 <dt><code><var>record</var> . <a>addedNodes</a></code>
 <dt><code><var>record</var> . <a>removedNodes</a></code>
 <dd><p>Return the <a>nodes</a> added and removed respectively.

 <dt><code><var>record</var> . <a href="#mutationrecord-previoussibling">previousSibling</a></code>
 <dt><code><var>record</var> . <a href="#mutationrecord-nextsibling">nextSibling</a></code>
 <dd><p>Return the <a href="#tree-previous-sibling">previous</a> and <a href="#tree-next-sibling">next sibling</a> respectively of the added or removed <a>nodes</a>, and null otherwise.

 <dt><code><var>record</var> . <a>attributeName</a></code>
 <dd><p>Returns the <a>local name</a> of the changed <a href="#concept-attribute">attribute</a>, and null otherwise.

 <dt><code><var>record</var> . <a>attributeNamespace</a></code>
 <dd><p>Returns the <a>namespace</a> of the changed <a href="#concept-attribute">attribute</a>, and null otherwise.

 <dt><code><var>record</var> . <a>oldValue</a></code>
 <dd><p>The return value depends on <code><a href="#mutationrecord-type">type</a></code>. For "<code>attributes</code>", it is the <a href="#attribute-value">value</a> of the changed <a href="#concept-attribute">attribute</a> before the change. For "<code>characterData</code>", it is the <a href="#cd-data">data</a> of the changed <a>node</a> before the change. For "<code>childList</code>", it is null.
</dl>

<p>The <dfn id="mutationrecord-type" for="mutationrecord"><code>type</code></dfn> and <dfn id="mutationrecord-target" for="mutationrecord"><code>target</code></dfn> attributes must return the values they were initialized to.

<p>The <dfn><code>addedNodes</code></dfn> and <dfn><code>removedNodes</code></dfn> attributes must return the values they were initialized to. Unless stated otherwise, when a <code><a>MutationRecord</a></code> object is created, they must both be initialized to an empty <code><a>NodeList</a></code>.

<p>The <dfn id="mutationrecord-previoussibling" for="mutationrecord"><code>previousSibling</code></dfn>, <dfn id="mutationrecord-nextsibling" for="mutationrecord"><code>nextSibling</code></dfn>, <dfn><code>attributeName</code></dfn>, <dfn><code>attributeNamespace</code></dfn>, and <dfn>oldValue</code></dfn> attributes must return the values they were initialized to. Unless stated otherwise, when a <code><a>MutationRecord</a></code> object is created, they must be initialized to null.

<h4 id="garbage-collection">Garbage collection</h4>

<p><a>Nodes</a> have a strong reference to <a>registered observers</a> in their list of <a>registered observers</a>.

<p><a>Registered observers</a> in a <a>node</a>'s list of <a>registered observers</a> have a weak reference to the <a>node</a>.

<h3 id="nodes-interface-node">Interface <code><a href="#dom-node">Node</a></code></h3>

<pre class='idl'>
[Exposed=Window]
interface Node : EventTarget {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2;
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4; // historical
  const unsigned short ENTITY_REFERENCE_NODE = 5; // historical
  const unsigned short ENTITY_NODE = 6; // historical
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; // historical
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute USVString baseURI;

  readonly attribute Document? ownerDocument;
  readonly attribute Node? parentNode;
  readonly attribute Element? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute NodeList childNodes;
  readonly attribute Node? firstChild;
  readonly attribute Node? lastChild;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  [NewObject] Node cloneNode(optional boolean deep = false);
  boolean isEqualNode(Node? node);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(Node other);
  boolean contains(Node? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  Node insertBefore(Node node, Node? child);
  Node appendChild(Node node);
  Node replaceChild(Node node, Node child);
  Node removeChild(Node child);
};
</pre>

<p class="note">Note: <code><dfn id="dom-node" for="dom">Node</dfn></code> is an abstract interface and does not exist as <a>node</a>. It is used by all <a>nodes</a> (<code><a>Document</a></code>, <code><a>DocumentFragment</a></code>, <code><a>DocumentType</a></code>, <code><a>Element</a></code>, <code><a>Text</a></code>, <code><a>ProcessingInstruction</a></code>, and <code><a>Comment</a></code>).

<p>Each <a>node</a> has an associated <dfn>node document</dfn>, set upon creation, that is a <a>document</a>.

<p class="note">Note: A <a>node</a>'s <a>node document</a> can be changed by the <a>adopt</a> algorithm.

<hr>

<dl>
 <dt><code><var>node</var> . <a>nodeType</a></code>
 <dd><p>Returns the type of <var>node</var>, represented by a number from the following list:</p>

  <dl>
   <dt><code><a href="#dom-node">Node</a> . <a>ELEMENT_NODE</a></code> (1)
   <dd><var>node</var> is an <a href="#concept-element">element</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>ATTRIBUTE_NODE</a></code> (2)
   <dd><var>node</var> is an <a href="#concept-attribute">attribute</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>TEXT_NODE</a></code> (3)
   <dd><var>node</var> is a <code><a>Text</a></code> <a>node</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>PROCESSING_INSTRUCTION_NODE</a></code> (7)
   <dd><var>node</var> is a <code><a>ProcessingInstruction</a></code> <a>node</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>COMMENT_NODE</a></code> (8)
   <dd><var>node</var> is a <code><a>Comment</a></code> <a>node</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_NODE</a></code> (9)
   <dd><var>node</var> is a <a>document</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_TYPE_NODE</a></code> (10)
   <dd><var>node</var> is a <a>doctype</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_FRAGMENT_NODE</a></code> (11)
   <dd><var>node</var> is a <code><a>DocumentFragment</a></code> <a>node</a>.
  </dl>

 <dt><code><var>node</var> . nodeName</code>
 <dd>
  <p>Returns a string appropriate for the type of <var>node</var>, as
  follows:

  <dl>
   <dt><code><a href="#element">Element</a></code>
   <dd>Its <code><a>tagName</a></code> attribute value.

   <dt><code><a href="#attr">Attr</a></code>
   <dd>Its <code><a href="#attribute-qualified-name">qualified name</a></code>.

   <dt><code><a>Text</a></code>
   <dd>"<code>#text</code>".

   <dt><code><a>ProcessingInstruction</a></code>
   <dd>Its <a href="#pi-target">target</a>.

   <dt><code><a>Comment</a></code>
   <dd>"<code>#comment</code>".

   <dt><code><a>Document</a></code>
   <dd>"<code>#document</code>".

   <dt><code><a>DocumentType</a></code>
   <dd>Its <a href="#doctype-name">name</a>.

   <dt><code><a>DocumentFragment</a></code>
   <dd>"<code>#document-fragment</code>".
  </dl>
</dl>

<p>The <dfn><code>nodeType</code></dfn> attribute's getter, when invoked, must return the first matching statement, switching on the <a>context object</a>:

<dl class="switch">
 <dt>{{Element}}
 <dd><dfn><code>ELEMENT_NODE</code></dfn> (1);

 <dt>{{Attr}}
 <dd><dfn><code>ATTRIBUTE_NODE</code></dfn> (2);

 <dt>{{Text}}
 <dd><dfn><code>TEXT_NODE</code></dfn> (3);

 <dt>{{ProcessingInstruction}}
 <dd><dfn><code>PROCESSING_INSTRUCTION_NODE</code></dfn> (7);

 <dt>{{Comment}}
 <dd><dfn><code>COMMENT_NODE</code></dfn> (8);

 <dt>{{Document}}
 <dd><dfn><code>DOCUMENT_NODE</code></dfn> (9);

 <dt>{{DocumentType}}
 <dd><dfn><code>DOCUMENT_TYPE_NODE</code></dfn> (10);

 <dt>{{DocumentFragment}}
 <dd><dfn><code>DOCUMENT_FRAGMENT_NODE</code></dfn> (11).
</dl>


<!-- NodeExodus
<hr>

<p>The <dfn><code>namespaceURI</code></dfn> attribute must return the namespace that is associated with the node, if there is one and it's not the empty string, and null otherwise.

<p>The <dfn id="node-prefix" for="node"><code>prefix</code></dfn> attribute must return the prefix that is associated with the node, if there is one and it's not the empty string, and null otherwise.
<!- - support setting? - - On setting, it must run these steps:

<ol>
 <li><p>Let <var>prefix</var> be the value being assigned.
 <li>
  <p>If <var>prefix</var> is not null, run these substeps:
  <ol>
   <li><p>If <var title>prefix</var> does not match the <code>Name</code> production in XML, <span title=concept-throw>throw</span> an "<code>InvalidCharacterError</code>".
   <li><p>If <var title>prefix</var> does not match the <code>NCName</code> production in Namespaces in XML, <span>throw</span> a "<code>NamespaceError</code>".
  </ol>
 <li><p>Actually this does not match any browser. Let's try to drop it instead.
</ol>- ->

<p>The <dfn><code>localName</code></dfn> attribute must return the local name that is associated with the node, if it has one, and null otherwise.-->

<p>The <code>nodeName</code> attribute's getter, when invoked, must return the first matching statement, switching on the <a href="#context-object">context object</a>:

<dl class="switch">
 <dt><code><a>Element</a></code>
 <dd><p>Its <code><a>tagName</a></code> attribute value.

 <dt><code><a href="#attr">Attr</a></code>
 <dd>Its <code><a href="#attribute-qualified-name">qualified name</a></code>.

 <dt><code><a>Text</a></code>
 <dd><p>"<code>#text</code>".

 <dt><code><a>ProcessingInstruction</a></code>
 <dd><p>Its <a href="#pi-target">target</a>.

 <dt><code><a>Comment</a></code>
 <dd><p>"<code>#comment</code>".

 <dt><code><a>Document</a></code>
 <dd><p>"<code>#document</code>".

 <dt><code><a>DocumentType</a></code>
 <dd><p>Its <a href="#doctype-name">name</a>.

 <dt><code><a>DocumentFragment</a></code>
 <dd><p>"<code>#document-fragment</code>".
</dl>

<hr>

<dl>
 <dt><code><var>node</var> . baseURI</code>
 <dd><p>Returns <var>node</var>'s <a>node document</a>'s <a>base URL</a>.
</dl>

The <dfn attribute for=Node><code>baseURI</code></dfn> attribute's getter must return
<a>node document</a>'s <a>base URL</a>.

<hr>

<dl>
 <dt><code><var>node</var> . ownerDocument</code>
 <dd>
  <p>Returns the <a>node document</a>.
  <p>Returns null for <a>documents</a>.

 <dt><code><var>node</var> . <a>parentNode</a></code>
 <dd><p>Returns the <a>parent</a>.

 <dt><code><var>node</var> . <a>parentElement</a></code>
 <dd><p>Returns the <a>parent element</a>.

 <dt><code><var>node</var> . <a>hasChildNodes()</a></code>
 <dd><p>Returns whether <var>node</var> has <a href="#tree-child">children</a>.

 <dt><code><var>node</var> . <a>childNodes</a></code>
 <dd><p>Returns the <a href="#tree-child">children</a>.

 <dt><code><var>node</var> . <a>firstChild</a></code>
 <dd><p>Returns the <a>first child</a>.

 <dt><code><var>node</var> . <a>lastChild</a></code>
 <dd><p>Returns the <a>last child</a>.

 <dt><code><var>node</var> . <a href="#node-previoussibling">previousSibling</a></code>
 <dd><p>Returns the <a href="#tree-previous-sibling">previous sibling</a>.

 <dt><code><var>node</var> . <a href="#node-nextsibling">nextSibling</a></code>
 <dd><p>Returns the <a href="#tree-next-sibling">next sibling</a>.
</dl>

<div>

<p>The <dfn attribute for=Node><code>ownerDocument</code></dfn> attribute's getter must return null, if the <a>context object</a> is a <a href="#concept-document">document</a>, and the <a>context object</a>'s
<a>node document</a> otherwise.

<p class="note">The <a>node document</a> of a <a href="#concept-document">document</a> is that <a href="#concept-document">document</a> itself. All <a>nodes</a> have a <a href="#concept-document">document</a> at all times.

<p>The <dfn><code>parentNode</code></dfn> attribute's getter must return the <a>context object</a>'s <a>parent</a>.

<p class="note">An {{Attr}} <a lt="nodes">node</a> has no <a>parent</a>.

<p>The <dfn><code>parentElement</code></dfn> attribute's getter must return the <a>context object</a>'s <a>parent element</a>.

<p>The <dfn><code>hasChildNodes()</code></dfn> method must return true if the <a>context object</a> has <a href="#tree-child">children</a>, and false otherwise.

<p>The <dfn><code>childNodes</code></dfn> attribute's getter must return a <code>{{NodeList}}</code> rooted at the <a>context object</a> matching only <a>children</a>.

<p>The <dfn><code>firstChild</code></dfn> attribute's getter must return the <a>context object</a>'s <a>first child</a>.

<p>The <dfn><code>lastChild</code></dfn> attribute's getter must return the <a>context object</a>'s <a>last child</a>.

<p>The <dfn id="node-previoussibling" for="node"><code>previousSibling</code></dfn> attribute's getter must return the <a>context object</a>'s <a href="#tree-previous-sibling">previous sibling</a>.

<p class="note">An {{Attr}} <a lt="nodes">node</a> has no <a>siblings</a>.

<p>The <dfn id="node-nextsibling" for="node"><code>nextSibling</code></dfn> attribute's getter must return the <a>context object</a>'s <a href="#tree-next-sibling">next sibling</a>.
</div>

<hr>

<!-- TODO: domintro -->

<p>The <dfn><code>nodeValue</code></dfn> attribute's getter must return the following, depending on the <a>context object</a>:

<dl class="switch">
 <dt><code><a>Attr</a></code>
 <dd><p><a>context object</a>'s <a href="#attribute-value">value</a>.

 <dt><code><a>Text</a></code>
 <dt><code><a>Comment</a></code>
 <dt><code><a>ProcessingInstruction</a></code>
 <dd><p>The <a>context object</a>'s <a href="#cd-data">data</a>.

 <dt>Any other node
 <dd><p>Null.
</dl>

<p>The <code><a>nodeValue</a></code> attribute's setter must, if the new value is null, act as if it was the empty string instead, and then do as described below, depending on the <a>context object</a>:

<dl class="switch">
 <dt><code><a>Attr</a></code>
 <dd><p><a>Set an existing attribute value</a> with <a>context object</a> and new value.

 <dt><code><a>Text</a></code>
 <dt><code><a>Comment</a></code>
 <dt><code><a>ProcessingInstruction</a></code>
 <dd><p><a>Replace data</a> with node <a>context object</a>, offset 0, count <code><a>length</a></code> attribute value, and data new value.

 <dt>Any other node
 <dd><p>Do nothing.
</dl>

<p>The <dfn id="event-textcontent" for="event"><code>textContent</code></dfn> attribute's getter must return the following, depending on the <a>context object</a>:

<dl class="switch">
 <dt><code><a>DocumentFragment</a></code>
 <dt><code><a>Element</a></code>
 <dd><p>The concatenation of <a href="#cd-data">data</a> of all the <code><a>Text</a></code> <a>node</a> <a>descendants</a> of the <a>context object</a>, in <a>tree order</a>.

 <dt><code><a>Attr</a></code>
 <dd><p><a>context object</a>'s <a href="#attribute-value">value</a>.

 <dt><code><a>Text</a></code>
 <dt><code><a>ProcessingInstruction</a></code>
 <dt><code><a>Comment</a></code>
 <dd><p>The <a>context object</a>'s <a href="#cd-data">data</a>.

 <dt>Any other node
 <dd><p>Null.
</dl>

<p>The <code><a href="#event-textcontent">textContent</a></code> attribute's setter must, if the new value is null, act as if it was the empty string instead, and then do as described below, depending on the <a>context object</a>:

<dl class="switch">
 <dt><code><a>DocumentFragment</a></code>
 <dt><code><a>Element</a></code>
 <dd>
  <ol>
   <li><p>Let <var>node</var> be null.

   <li><p>If new value is not the empty string, set <var>node</var> to a new <code><a>Text</a></code> <a>node</a> whose <a href="#cd-data">data</a> is new value.

   <li><p><a>Replace all</a> with <var>node</var> within the <a>context object</a>.
  </ol>

 <dt><code><a>Attr</a></code>
 <dd><p><a>Set an existing attribute value</a> with <a>context object</a> and new value.

 <dt><code><a>Text</a></code>
 <dt><code><a>ProcessingInstruction</a></code>
 <dt><code><a>Comment</a></code>
 <dd><p><a>Replace data</a> with node <a>context object</a>, offset 0, count <code><a>length</a></code> attribute value, and data new value.

 <dt>Any other node
 <dd><p>Do nothing.
</dl>

<hr>

<dl>
 <dt><code><var>node</var> . <a>normalize</a>()</code>
 <dd><p>Removes <a>empty</a> <code><a>Text</a></code> <a>nodes</a> and concatenates the <a href="#cd-data">data</a> of remaining <a>contiguous <code>Text</code> nodes</a> into the first of their <a>nodes</a>.
</dl>

<p>The <dfn><code>normalize()</code></dfn> method must run these steps:</p>

<p>For each <code><a>Text</a></code> <a>node</a> <a>descendant</a> of the <a>context object</a>:

<ol>
 <li><p>Let <var>node</var> be the <code><a>Text</a></code> <a>node</a> <a>descendant</a>.

 <li><p>Let <var>length</var> be <var>node</var>'s <code><a href="#characterdata-length">length</a></code> attribute value.

 <li><p>If <var>length</var> is zero, <a href="#node-remove">remove</a> <var>node</var> and continue with the next <code><a>Text</a></code> <a>node</a>, if any.

 <li><p>Let <var>data</var> be the concatenation of the <a href="#cd-data">data</a> of <var>node</var>'s <a>contiguous <code>Text</code> nodes</a> (excluding itself), in <a>tree order</a>.

 <li><p><a>Replace data</a> with node <var>node</var>, offset <var>length</var>, count 0, and data <var>data</var>.

 <li><p>Let <var>current node</var> be <var>node</var>'s <a href="#tree-next-sibling">next sibling</a>.

 <li><p>While <var>current node</var> is a <code><a>Text</a></code> node:

 <ol>
  <li><p>For each <a>range</a> whose <a>start node</a> is <var>current node</var>, add <var>length</var> to its <a>start offset</a> and set its <a>start node</a> to <var>node</var>.

  <li><p>For each <a>range</a> whose <a>end node</a> is <var>current node</var>, add <var>length</var> to its <a>end offset</a> and set its <a>end node</a> to <var>node</var>.

  <li><p>For each <a>range</a> whose <a>start node</a> is <var>current node</var>'s <a>parent</a> and <a>start offset</a> is <var>current node</var>'s <a>index</a>, set its <a>start node</a> to <var>node</var> and its <a>start offset</a> to <var>length</var>.

  <li><p>For each <a>range</a> whose <a>end node</a> is <var>current node</var>'s <a>parent</a> and <a>end offset</a> is <var>current node</var>'s <a>index</a>, set its <a>end node</a> to <var>node</var> and its <a>end offset</a> to <var>length</var>.

  <li><p>Add <var>current node</var>'s <code><a>length</a></code> attribute value to <var>length</var>.

  <li><p>Set <var>current node</var> to its <a href="#tree-next-sibling">next sibling</a>.
 </ol>

 <li><p><a href="#node-remove">Remove</a> <var>node</var>'s <a>contiguous <code>Text</code> nodes</a> (excluding itself), in <a>tree order</a>.
</ol>

<hr>

<dl>
 <dt><code><var>node</var> . <a>cloneNode</a>([<var>deep</var> = false])</code>
 <dd><p>Returns a copy of <var>node</var>. If <var>deep</var> is true, the copy also includes the <var>node</var>'s <a>descendants</a>.

 <dt><code><var>node</var> . <a>isEqualNode</a>(<var>other</var>)</code>
 <dd><p>Returns whether <var>node</var> and <var>other</var> have the same properties.
</dl>

<div>

<p><a>Specifications</a> may define <dfn>cloning steps</dfn> for all or some <a>nodes</a>. The algorithm is passed <var>copy</var>, <var>node</var>, <var>document</var>, and an optional <i>clone children flag</i>, as indicated in the <a href="#node-clone">clone</a> algorithm.

<p class="note">Note: HTML defines <a>cloning steps</a> for <code><a href="http://www.w3.org/TR/html5/scripting-1.html#the-script-element">script</a></code> and <code><a href="http://www.w3.org/TR/html5/forms.html#the-input-element">input</a></code> elements. SVG ought to do the same for its <code>script</code> elements, but does not call this out at the moment.

<p>To <dfn id="node-clone" for="node">clone</dfn> a <var>node</var>, with an optional <var>document</var> and <i>clone children flag</i>, run these steps:

<ol>
 <li><p>If <var>document</var> is not given, let <var>document</var> be <var>node</var>'s <a>node document</a>.

 <li>
  <p>If <var>node</var> is an <a href="#concept-element">element</a>, then:

  <ol>
   <li>let <var>copy</var> be a <a lt="nodes">node</a> that implements the same interfaces as <var>node</var>.
   <li><p>Set <var>copy</var>'s <a href="#element-local-name">local name</a>, <a href="#element-namespace">namespace</a>,
   <a href="#element-namespace-prefix">namespace prefix</a>, to those of <var>node</var>.
   <li>
    <p>For each <var>attribute</var> in <var>node</var>'s
    <a>attribute list</a>, in order, run these substeps:

    <ol>
     <li><p>Let <var>copyAttribute</var> be a <a>clone</a> of <var>attribute</var>.

     <li><p><a lt="append an attribute">Append</a> <var>copyAttribute</var> to <var>copy</var>.
    </ol>
   </li>
  </ol>
 </li>

 <li><p>Otherwise, let <var>copy</var> be a <a lt="nodes">node</a> that implements the same interfaces as <var>node</var>,
  and fulfills these additional requirements, switching on
  <var>node</var>:

  <dl>
   <dt>{{Document}}
   <dd><p>Set <var>copy</var>'s <a href="#document-encoding">encoding</a>,
   <a href="#concept-document-content-type">content type</a>, <a href="#document-url">URL</a>,
   <a href="#concept-document-origin">origin</a>,
   <a href="#dom-document-doctype">type</a>, and <a href="#dom-document-compatmode">mode</a>,
   to those of <var>node</var>.

   <dt>{{DocumentType}}
   <dd><p>Set <var>copy</var>'s <a href="#doctype-name">name</a>, <a>public ID</a>, and
   <a>system ID</a>, to those of <var>node</var>.

   <dt>{{Attr}}
   <dd><p>Set <var>copy</var>'s <a href="#attribute-namespace">namespace</a>, <a href="#attribute-namespace-prefix">namespace prefix</a>, <a href="#attribute-local-name">local name</a>, and <a href="#attribute-value">value</a>, to those of <var>node</var>.

   <dt>{{Text}}
   <dt>{{Comment}}
   <dd>Set <var>copy</var>'s <a href="#cd-data">data</a>, to that of <var>node</var>.

   <dt>{{ProcessingInstruction}}
   <dd>Set <var>copy</var>'s<a href="#pi-target">target</a> and <a href="#cd-data">data</a> to
   those of <var>node</var>.

   <dt>Any other node
   <dd><p>—
  </dl>

 <li><p>Set <var>copy</var>'s <a>node document</a> and <var>document</var> to
 <var>copy</var>, if <var>copy</var> is a <a>document</a>, and set <var>copy</var>'s
 <a>node document</a> to <var>document</var> otherwise.

 <li><p>Run any <a>cloning steps</a> defined for <var>node</var> in <a>other applicable specifications</a> and pass <var>copy</var>, <var>node</var>, <var>document</var> and the <i>clone children flag</i> if set, as parameters.

 <li><p>If the <i>clone children flag</i> is set, <a href="#node-clone">clone</a> all the <a href="#tree-child">children</a> of <var>node</var> and append them to <var>copy</var>, with <var>document</var> as specified and the <i>clone children flag</i> being set.

 <li><p>Return <var>copy</var>.
</ol>

<p>The <dfn><code>cloneNode(<var>deep</var>)</code></dfn> method must return a <a href="#node-clone">clone</a> of the <a>context object</a>, with the <i>clone children flag</i> set if <var>deep</var> is true.

<p>A <a>node</a> <var>A</var> <dfn>equals</dfn> a <a>node</a> <var>B</var> if all of the following conditions are true:

<ul>
 <li><p><var>A</var> and <var>B</var>'s <code><a>nodeType</a></code> attribute value is identical.
 <li>
  <p>The following are also equal, depending on <var>A</var>:
  <dl class="switch">
   <dt><code><a>DocumentType</a></code>
   <dd><p>Its <a href="#doctype-name">name</a>, <a>public ID</a>, and <a>system ID</a>.

   <dt><code><a>Element</a></code>
   <dd>
    <p>Its <a href="#element-namespace">namespace</a>, <a href="#element-namespace-prefix">namespace prefix</a>, <a href="#element-local-name">local name</a>, and its number of <a href="#concept-attribute">attributes</a> in its <a>attribute list</a>.

   <dt><code><a>Attr</a></code>
   <dd><p>Its <a href="#attribute-namespace">namespace</a>, <a href="#attribute-local-name">local name</a>, and <a href="#attribute-value">value</a>.


   <dt><code><a>ProcessingInstruction</a></code>
   <dd><p>Its <a href="#pi-target">target</a> and <a href="#cd-data">data</a>.

   <dt><code><a>Text</a></code>
   <dt><code><a>Comment</a></code>
   <dd><p>Its <a href="#cd-data">data</a>.

   <dt>Any other node
   <dd><p>—
  </dl>
 <li><p>If <var>A</var> is an <a>element</a>, each <a href="#concept-attribute">attribute</a> in its <a>attribute list</a> has an <a href="#concept-attribute">attribute</a> that <a>equals</a> in <var>B</var>'s <a>attribute list</a>.
 <li><p><var>A</var> and <var>B</var> have the same number of <a href="#tree-child">children</a>.
 <li><p>Each <a href="#tree-child">child</a> of <var>A</var> <a>equals</a> the <a href="#tree-child">child</a> of <var>B</var> at the identical <a>index</a>.
</ul>

<p>The <dfn><code>isEqualNode(<var>node</var>)</code></dfn> method must return true if <var>node</var> is not null and <a>context object</a> <a>equals</a> <var>node</var>, and false otherwise.

</div>

<hr>

<dl>
 <dt><code><var>node</var> . <a>compareDocumentPosition</a>(<var>other</var>)</code>
 <dd>
  <p>Returns a bitmask indicating the position of <var>other</var> relative to <var>node</var>. These are the bits that can be set:

  <dl>
   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_POSITION_DISCONNECTED</a></code> (1)
   <dd>Set when <var>node</var> and <var>other</var> are not in the same <a>tree</a>.

   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_POSITION_PRECEDING</a></code> (2)
   <dd>Set when <var>other</var> is <a>preceding</a> <var>node</var>.

   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_POSITION_FOLLOWING</a></code> (4)
   <dd>Set when <var>other</var> is <a>following</a> <var>node</var>.

   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_POSITION_CONTAINS</a></code> (8)
   <dd>Set when <var>other</var> is an <a>ancestor</a> of <var>node</var>.

   <dt><code><a href="#dom-node">Node</a> . <a>DOCUMENT_POSITION_CONTAINED_BY</a></code> (16, 10 in hexadecimal)
   <dd>Set when <var>other</var> is a <a>descendant</a> of <var>node</var>.
  </dl>

 <dt><code><var>node</var> . <a>contains</a>(<var>other</var>)</code>
 <dd><p>Returns true if <var>other</var> is an <a>inclusive descendant</a> of <var>node</var>, and false otherwise.
</dl>

<p>These are the constants <code><a>compareDocumentPosition()</a></code> returns as mask:

<ul>
 <li><dfn><code>DOCUMENT_POSITION_DISCONNECTED</code></dfn> (1);
 <li><dfn><code>DOCUMENT_POSITION_PRECEDING</code></dfn> (2);
 <li><dfn><code>DOCUMENT_POSITION_FOLLOWING</code></dfn> (4);
 <li><dfn><code>DOCUMENT_POSITION_CONTAINS</code></dfn> (8);
 <li><dfn><code>DOCUMENT_POSITION_CONTAINED_BY</code></dfn> (16, 10 in hexadecimal);
 <li><dfn><code>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></dfn> (32, 20 in hexadecimal).
</ul>

<p>The <dfn><code>compareDocumentPosition(<var>other</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <a>context object</a> is <var>other</var>, then return zero.

 <li><p>Let <var>node1</var> be <var>other</var> and <var>node2</var> be <a>context object</a>.

 <li><p>Let <var>attr1</var> and <var>attr2</var> be null.

 <li><p>If <var>node1</var> is an <a>attribute</a>, then set <var>attr1</var> to <var>node1</var>
 and <var>node1</var> to <var>attr1</var>'s <a href="#concept-element">element</a>.

 <li>
  <p>If <var>node2</var> is an <a>attribute</a>, then:

  <ol>
   <li><p>Set <var>attr2</var> to <var>node2</var> and <var>node2</var> to <var>attr2</var>'s
   <a href="#concept-element">element</a>.

   <li>
    <p>If <var>attr1</var> and <var>node1</var> are non-null, and <var>node2</var> is
    <var>node1</var>, then:

    <ol>
     <li>
      <p>For each <a>attribute</a> <var>attr</var> in <var>node2</var>'s
      <a>attribute list</a>:

      <ol>
       <li><p>If <var>attr</var> <a>equals</a> <var>attr1</var>, then return the result of
       adding {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}} and
       {{Node/DOCUMENT_POSITION_PRECEDING}}.

       <li><p>If <var>attr</var> <a>equals</a> <var>attr2</var>, then return the result of
       adding {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}} and
       {{Node/DOCUMENT_POSITION_FOLLOWING}}.
      </ol>
    </ol>
  </ol>

 <li>
  <p>If <var>node1</var> or <var>node2</var> is null, or <var>node1</var>'s <a>root</a> is
  not <var>node2</var>'s <a>root</a>, then return the result of adding
  {{Node/DOCUMENT_POSITION_DISCONNECTED}}, {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}}, and
  either {{Node/DOCUMENT_POSITION_PRECEDING}} or {{Node/DOCUMENT_POSITION_FOLLOWING}}, with the
  constraint that this is to be consistent, together.

  <p class="note no-backref">Whether to return {{Node/DOCUMENT_POSITION_PRECEDING}} or
  {{Node/DOCUMENT_POSITION_FOLLOWING}} is typically implemented via pointer comparison. In
  JavaScript implementations a cached <code class='lang-javascript'>Math.random()</code> value can
  be used.

 <li><p>If <var>node1</var> is an <a>ancestor</a> of <var>node2</var> and <var>attr1</var> is null,
 or <var>node1</var> is <var>node2</var> and <var>attr2</var> is non-null, then return the result of
 adding {{Node/DOCUMENT_POSITION_CONTAINS}} to {{Node/DOCUMENT_POSITION_PRECEDING}}.

 <li><p>If <var>node1</var> is a <a>descendant</a> of <var>node2</var> and <var>attr2</var> is null,
 or <var>node1</var> is <var>node2</var> and <var>attr1</var> is non-null, then return the result of
 adding {{Node/DOCUMENT_POSITION_CONTAINED_BY}} to {{Node/DOCUMENT_POSITION_FOLLOWING}}.

 <li>
  <p>If <var>node1</var> is <a>preceding</a> <var>node2</var>, then return
  {{Node/DOCUMENT_POSITION_PRECEDING}}.

  <p class="note">Due to the way <a>attributes</a> are handled in this algorithm this results in a
  <a>node</a>'s <a>attributes</a> counting as <a>preceding</a> that <a>node</a>'s <a>children</a>,
  despite <a>attributes</a> not <a>participating</a> in a <a>tree</a>.

 <li><p>Return <code><a>DOCUMENT_POSITION_FOLLOWING</a></code>.
</ol>

<p>The <dfn id="node-contains-func" for="node"><code>contains(<var>other</var>)</code></dfn> method, when invoked, must return true if <var>other</var> is an <a>inclusive descendant</a> of <a>context object</a>, and false otherwise (including when <var>other</var> is null).

<hr>

<!--
 XXX apparently these algorithms might not be quite correct
 https://bugzilla.mozilla.org/show_bug.cgi?id=312019
 https://bugzilla.mozilla.org/show_bug.cgi?id=505178
-->

<p>To <dfn>locate a namespace prefix</dfn> for an <var>element</var> using <var>namespace</var>, run these steps:

<ol>
 <li><p>If <var>element</var>'s <a href="#element-namespace">namespace</a> is <var>namespace</var> and its <a href="#element-namespace-prefix">namespace prefix</a> is not null, then return its <a href="#element-namespace-prefix">namespace prefix</a>.

 <li><p>If, <var>element</var> <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>" and <a href="#attribute-value">value</a> is <var>namespace</var>, then return <var>element</var>'s first such <a href="#concept-attribute">attribute</a>'s <a href="#attribute-local-name">local name</a>.

 <li><p>If <var>element</var>'s <a>parent element</a> is not null, then return the result of running <a>locate a namespace prefix</a> on that <a>element</a> using <var>namespace</var>. <li><p>Return null.

</ol>

<p>To <dfn>locate a namespace</dfn> for a <var>node</var> using <var>prefix</var> switch on <var>node</var>:

<dl class="switch">
 <dt><code><a href="#dom-element">Element</a></code>
 <dd>
  <ol>
   <li><p>If its <a href="#element-namespace">namespace</a> is not null and its <a href="#element-namespace-prefix">namespace prefix</a> is <var>prefix</var>, then return <a href="#element-namespace">namespace</a>.

   <li><p>If it <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-namespace">namespace</a>
   is the <a>XMLNS namespace</a>, <a href="#attribute-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>", and
   <a href="#attribute-local-name">local name</a> is <var>prefix</var>, or if <var>prefix</var> is null and it
   <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-namespace">namespace</a> is the
   <a>XMLNS namespace</a>, <a href="#attribute-namespace-prefix">namespace prefix</a> is null, and <a href="#attribute-local-name">
   local name</a> is "<code>xmlns</code>", then return its <a href="#attribute-value">value</a> if it is not the empty string,
   and null otherwise.

   <li><p>If its <a>parent element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>parent element</a> using <var>prefix</var>.
  </ol>

 <dt><code><a>Document</a></code>
 <dd>
  <ol>
   <li><p>If its <a>document element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>document element</a> using <var>prefix</var>.
  </ol>

 <dt><code><a>DocumentType</a></code>
 <dt><code><a>DocumentFragment</a></code>
 <dd><p>Return null.

 <dt>{{Attr}}
 <dd>
  <ol>
   <li><p>If its <a>element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>element</a>
   using <var>prefix</var>.
  </ol>

 <dt>Any other node
 <dd>
  <ol>
   <li><p>If its <a>parent element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>parent element</a> using <var>prefix</var>.
  </ol>
</dl>

<p>The <dfn><code>lookupPrefix(<var>namespace</var>)</code></dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>namespace</var> is null or the empty string, then return null.

 <li>
  <p>Switch on the <a>context object</a>:

  <dl class="switch">
   <dt><code><a href="#dom-element">Element</a></code>
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for it using <var>namespace</var>.

   <dt><code><a>Document</a></code>
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for its <a>document element</a>, if its <a>document element</a> is non-null, and null otherwise.

   <dt><code><a>DocumentType</a></code>
   <dt><code><a>DocumentFragment</a></code>
   <dd><p>Return null.

   <dt>{{Attr}}
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for its <a href="#attribute-element">element</a>,
   if its <a href="#attribute-element">element</a> is non-null, and null otherwise.

   <dt>Any other node
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for its <a>parent element</a>, if its <a>parent element</a> is non-null, and null otherwise.
   </dl>
</ol>

<p>The <dfn><code>lookupNamespaceURI(<var>prefix</var>)</code></dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>prefix</var> is the empty string, then set it to null.

 <li><p>Return the result of running <a>locate a namespace</a> for the <a>context object</a> using <var>prefix</var>.
</ol>

<p>The <dfn><code>isDefaultNamespace(<var>namespace</var>)</code></dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>namespace</var> is the empty string, then set it to null.

 <li><p>Let <var>defaultNamespace</var> be the result of running <a>locate a namespace</a> for <a>context object</a> using null.

 <li><p>Return true if <var>defaultNamespace</var> is the same as <var>namespace</var>, and false otherwise.
</ol>

<hr>

<p>The <dfn><code>insertBefore(<var>node</var>, <var>child</var>)</code></dfn> method, when invoked, must return the result of <a>pre-inserting</a> <var>node</var> into <a>context object</a> before <var>child</var>.

<p>The <dfn><code>appendChild(<var>node</var>)</code></dfn> method, when invoked, must return the result of <a>appending</a> <var>node</var> to <a>context object</a>.

<p>The <dfn><code>replaceChild(<var>node</var>, <var>child</var>)</code></dfn> method, when invoked, must return the result of <a>replacing</a> <var>child</var> with <var>node</var> within <a>context object</a>.

<p>The <dfn><code>removeChild(<var>child</var>)</code></dfn> method, when invoked, must return the result of <a>pre-removing</a> <var>child</var> from <a>context object</a>.

<p>The <dfn>list of elements with local name <var>localName</var></dfn> for a <a>node</a> <var>root</var> is the <code><a>HTMLCollection</a></code> returned by the following algorithm:
<ol>
 <li><p>If <var>localName</var> is "<code>*</code>" (U+002A), return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches only <a>elements</a>.

 <li>
  <p>Otherwise, if <var>root</var>'s <a>node document</a> is an <a>HTML document</a>, return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches the following <a>descendant</a> <a>elements</a>:

  <ul>
   <li>Whose <a href="#element-namespace">namespace</a> is the <a>HTML namespace</a> and whose <a href="#element-local-name">local name</a> is <var>localName</var> <a>converted to ASCII lowercase</a>.

   <li>Whose <a href="#element-namespace">namespace</a> is <em>not</em> the <a>HTML namespace</a> and whose <a href="#element-local-name">local name</a> is <var>localName</var>.
  </ul>

 <li><p>Otherwise, return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#element-local-name">local name</a> is <var>localName</var>.
</ol>

<p>When invoked with the same argument, and as long as <var>root</var>'s <a>node document</a>'s <a for=Document>type</a> has not changed,
the same <code>{{HTMLCollection}}</code> object may be returned as returned by an earlier call.


<p>The <dfn>list of elements with namespace <var>namespace</var> and local name <var>localName</var></dfn> for a <a>node</a> <var>root</var> is the <code><a>HTMLCollection</a></code> returned by the following algorithm:

<ol>
 <li><p>If <var>namespace</var> is the empty string, set it to null.

 <li><p>If both <var>namespace</var> and <var>localName</var> are "<code>*</code>" (U+002A), return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a>.

 <li><p>Otherwise, if <var>namespace</var> is "<code>*</code>" (U+002A), return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#element-local-name">local name</a> is <var>localName</var>.

 <li><p>Otherwise, if <var>localName</var> is "<code>*</code>" (U+002A), return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#element-namespace">namespace</a> is <var>namespace</var>.

 <li><p>Otherwise, return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#element-namespace">namespace</a> is <var>namespace</var> and <a href="#element-local-name">local name</a> is <var>localName</var>.
</ol>

<p>When invoked with the same arguments, the same <code>{{HTMLCollection}}</code> object may be returned as returned by an earlier call.


<p>The <dfn>list of elements with class names <var>classNames</var></dfn> for a <a>node</a> <var>root</var> is the <code><a>HTMLCollection</a></code> returned by the following algorithm:
<ol>
 <li>
  <p>Let <var>classes</var> be the result of running the <a>ordered set parser</a> on <var>classNames</var>.

 <li>
  <p>If <var>classes</var> is the empty set, return an empty <code><a>HTMLCollection</a></code>.

 <li>
  <p>Return a <code><a>HTMLCollection</a></code> rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> that have all their <a>classes</a> in <var>classes</var>.

  <p>The comparisons for the <a>classes</a> must be done in an <a>ASCII case-insensitive</a> manner if <var>root</var>'s <a>node document</a>'s <a for=Document>mode</a> is "<code>quirks</code>", and in a <a>case-sensitive</a> manner otherwise.
</ol>

<p>When invoked with the same argument, the same <code>{{HTMLCollection}}</code> object may be returned as returned by an earlier call.

<h3 id="nodes-interface-document">Interface <code><a href="#dom-document">Document</a></code></h3>

<pre class='idl'>
[Constructor,
 Exposed=Window]
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  readonly attribute USVString URL;
  readonly attribute USVString documentURI;
  readonly attribute USVString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; // for legacy use, alias of .characterSet
  readonly attribute DOMString inputEncoding; // for legacy use, alias of .characterSet
  readonly attribute DOMString contentType;

  readonly attribute DocumentType? doctype;
  readonly attribute Element? documentElement;
  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  [NewObject] Element createElement(DOMString localName);
  [NewObject] Element createElementNS(DOMString? namespace, DOMString qualifiedName);
  [NewObject] DocumentFragment createDocumentFragment();
  [NewObject] Text createTextNode(DOMString data);
  [NewObject] Comment createComment(DOMString data);
  [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] Node importNode(Node node, optional boolean deep = false);
  Node adoptNode(Node node);

  [NewObject] Event createEvent(DOMString interface);

  [NewObject] Range createRange();

  // NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
  [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
};

[Exposed=Window]
interface XMLDocument : Document {};
</pre>

<p><code><dfn id="dom-document" for="dom">Document</dfn></code> <a>nodes</a> are simply known as <dfn for="concept" lt="document|documents">documents</dfn>.

<p>Each <a>document</a> has an associated <dfn export for=Document id=document-encoding>encoding</dfn> (an <a spec=encoding>encoding</a>), <dfn export for=Document id=concept-document-content-type>content type</dfn> (a string), <dfn export for=Document id=concept-document-url>URL</dfn> (a <a spec=url>URL</a>), <dfn export for=Document id=concept-document-origin>origin</dfn> (an <a spec=HTML51>origin</a>),
<dfn export for=Document id=concept-document-type>type</dfn> ("<code>xml</code>" or "<code>html</code>"), and <dfn export for=Document id=concept-document-mode>mode</dfn> ("<code>no-quirks</code>", "<code>quirks</code>", or "<code>limited-quirks</code>"). [[!ENCODING]] [[!URL]] [[!HTML51]]

<p>Unless stated otherwise, a <a>document</a>'s <a href="#document-encoding">encoding</a> is the <a>utf-8</a> <a spec=encoding>encoding</a>, its <a for=Document>content type</a> is "<code>application/xml</code>", its <a for=Document" title="document-url">URL</a> is "<code>about:blank</code>", <a for=Document>origin</a> is an <code><a>opaque origin</a></code>, <a for=Document>type</a> is "<code>xml</code>", and its <a for=Document>mode</a> is "<code>no-quirks</code>".

<p>A <a>document</a> is said to be an <dfn export>XML document</dfn> if its <a for=Document>type</a> is "<code>xml</code>", and an <dfn>HTML document</dfn> otherwise. Whether a <a>document</a> is an <a>HTML document</a> or an <a>XML document</a> affects the behavior of certain APIs.

A <a>document</a> is said to be in <dfn export id=concept-document-no-quirks>no-quirks mode</dfn> if its <a for=Document>mode</a> is "<code>no-quirks</code>", <dfn export id=concept-document-quirks>quirks mode</dfn> if its <a for=Document>mode</a> is "<code>quirks</code>", and <dfn export id=concept-document-limited-quirks>limited-quirks mode</dfn> if its <a for=Document>mode</a> is "<code>limited-quirks</code>".

<div class="note no-backref"> <p>The <a for=Document>mode</a> is only ever changed from the default for <a>documents</a> created by the <a>HTML parser</a> based on the presence, absence, or value of the DOCTYPE string, and by a new <a>browsing context</a> (initial "<code>about:blank</code>"). [[!HTML]]

<p><a>No-quirks mode</a> was originally known as "standards mode" and <a>limited-quirks mode</a> was once known as "almost standards mode". They have been renamed because their details are now defined by standards. (And because Ian Hickson vetoed their original names on the basis that they are nonsensical.)</div>

<hr>

<dl>
 <dt><code><var>document</var> = new <a>Document</a>()</code>
 <dd><p>Returns a new <a>document</a>.

 <dt><code><var>document</var> . <a>implementation</a></code>
 <dd><p>Returns <var>document</var>'s <code><a>DOMImplementation</a></code> object.

 <dt><code><var>document</var> . <a href="#document-url">URL</a></code>
 <dt><code><var>document</var> . <a>documentURI</a></code>
 <dd><p>Returns <var>document</var>'s <a href="#document-url">URL</a>.

 <dt><code><var>document</var> . <a href="#document-origin">origin</a></code>
 <dd><p>Returns <var>document</var>'s <a href="#concept-document-origin">origin</a>.

 <dt><code><var>document</var> . <a>compatMode</a></code>
 <dd>
  <p>Returns the string "<code>BackCompat</code>" if <var>document</var>'s <a for=Document>mode</a> is "<code>quirks mode</code>", and "<code>CSS1Compat</code>" otherwise.

 <dt><code><var>document</var> . <a>characterSet</a></code>
 <dd><p>Returns <var>document</var>'s <a href="#document-encoding">encoding</a>.

 <dt><code><var>document</var> . <a>contentType</a></code>
 <dd><p>Returns <var>document</var>'s <a>content type</a>.
</dl>

<p>The <dfn><code>Document()</code></dfn> constructor must return a new <a>document</a> whose <a href="#concept-document-origin">origin</a> is the <a href="#concept-document-origin">origin</a> of the global object's associated <a>document</a>. [[!HTML51]]

<p class="note">Note: Unlike <code><a>createDocument()</a></code>, this constructor does not return an <code><a>XMLDocument</a></code> object, but a <a href="#concept-document">document</a> (<code><a href="#dom-document">Document</a></code> object).

<p>The <dfn><code>implementation</code></dfn> attribute must return the <code><a>DOMImplementation</a></code> object that is associated with the <a>document</a>.

<p>The <dfn id="document-url"><code>URL</code></dfn> and <dfn><code>documentURI</code></dfn> attributes must return the <a href="#document-url">URL</a>.

<p>The <dfn id="document-origin" for="document"><code>origin</code></dfn> attribute must return the <a spec=HTML51>Unicode serialization</a> of <a>context object</a>'s <a href="#concept-document-origin">origin</a>.

<p>The <dfn><code>compatMode</code></dfn> attribute's getter must return "<code>BackCompat</code>" if the <a>context object</a>'s <a for=Document>mode</a> is "<code>quirks</code>", and "<code>CSS1Compat</code>" otherwise.

<p>The <dfn><code>characterSet</code></dfn> attribute's getter, <dfn><code>charSet</code></dfn> attribute's getter, and <dfn><code>inputEncoding</code></dfn> attribute's getter, must return <a>context object</a>'s <a href="#document-encoding">encoding</a>'s <a href="https://www.w3.org/TR/encoding/#name">name</a>.

<p>The <dfn><code>contentType</code></dfn> attribute must return the <a>content type</a>.

<hr>

<dl>
 <dt><var>document</var> . <code><a href="#document-doctype">doctype</a></code>
 <dd><p>Returns the <a href="#concept-doctype">doctype</a> or null if there is none.

 <dt><var>document</var> . <code><a>documentElement</a></code>
 <dd><p>Returns the <a>document element</a>.

 <dt><var>collection</var> = <var>document</var> . <code><a href="#document-getelementsbytagname-func">getElementsByTagName(<var>localName</var>)</a></code>

 <dd>
  <p>If <var>localName</var> is "<code>*</code>" returns a <code><a>HTMLCollection</a></code> of all <a>descendant</a> <a>elements</a>.

  <p>Otherwise, returns a <code><a>HTMLCollection</a></code> of all <a>descendant</a> <a>elements</a> whose <a href="#element-local-name">local name</a> is <var>localName</var>. (Matches case-insensitively against <a>elements</a> in the <a>HTML namespace</a> within an <a>HTML document</a>.)

 <dt><var>collection</var> = <var>document</var> . <code><a href="#document-getelementsbytagnamens-func">getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</a></code>

 <dd>
  <p>If <var>namespace</var> and <var>localName</var> are "<code>*</code>" returns a <code><a>HTMLCollection</a></code> of all <a>descendant</a> <a>elements</a>.

  <p>If only <var>namespace</var> is "<code>*</code>" returns a <code><a>HTMLCollection</a></code> of all <a>descendant</a> <a>elements</a> whose <a href="#element-local-name">local name</a> is <var>localName</var>.

  <p>If only <var>localName</var> is "<code>*</code>" returns a <code><a>HTMLCollection</a></code> of all <a>descendant</a> <a>elements</a> whose <a href="#element-namespace">namespace</a> is <var>namespace</var>.

  <p>Otherwise, returns a <code><a>HTMLCollection</a></code> of all <a>descendant</a> <a>elements</a> whose <a href="#element-namespace">namespace</a> is <var>namespace</var> and <a href="#element-local-name">local name</a> is <var>localName</var>.

 <dt><var>collection</var> = <var>document</var> . <code><a href="#document-getelementsbytagname-func">getElementsByClassName(<var>classes</var>)</a></code>
 <dt><var>collection</var> = <var>element</var> . <code><a href="#element-getelementsbytagname-func">getElementsByClassName(<var>classes</var>)</a></code>
 <dd>
  <p>Returns a <code><a>HTMLCollection</a></code> of the <a>elements</a> in the object on which the method was invoked (a <a>document</a> or an <a>element</a>) that have all the classes given by <var>classes</var>.
  <p>The <var>classes</var> argument is interpreted as a space-separated list of classes.
</dl>

<p>The <dfn id="document-doctype" for="document"><code>doctype</code></dfn> attribute must return the <a href="#tree-child">child</a> of the <a>document</a> that is a <a href="#concept-doctype">doctype</a>, and null otherwise.

<p>The <dfn><code>documentElement</code></dfn> attribute must return the <a>document element</a>.

<p>The <dfn id="document-getelementsbytagname-func" for="document"><code>getElementsByTagName(<var>localName</var>)</code></dfn> method must return the <a>list of elements with local name <var>localName</var></a> for the <a>context object</a>.

<p class="note">Note: Thus, in an <a>HTML document</a>, <code>document.getElementsByTagName("FOO")</code> will match <code>FOO</code> elements that are not in the <a>HTML namespace</a>, and <code>foo</code> elements that are in the <a>HTML namespace</a>, but not <code>FOO</code> elements that are in the <a>HTML namespace</a>.


<p>The <dfn id="document-getelementsbytagnamens-func" for="document"><code>getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</code></dfn> method must return the <a>list of elements with namespace <var>namespace</var> and local name <var>localName</var></a> for the <a>context object</a>.

<p>The <dfn id="element-getelementsbyclassname-func" for="document"><code>getElementsByClassName(<var>classNames</var>)</code></dfn> method must return the <a>list of elements with class names <var>classNames</var></a> for the <a>context object</a>.

<div class="example">
 <p>Given the following XHTML fragment:

 <pre>&lt;div id="example"&gt;
  &lt;p id="p1" class="aaa bbb"/&gt;
  &lt;p id="p2" class="aaa ccc"/&gt;
  &lt;p id="p3" class="bbb ccc"/&gt;
&lt;/div&gt;</pre>

 <p>A call to <code>document.getElementById('example').getElementsByClassName('aaa')</code> would return a <code><a>HTMLCollection</a></code> with the two paragraphs <code>p1</code> and <code>p2</code> in it.

 <p>A call to <code>getElementsByClassName('ccc bbb')</code> would only return one node, however, namely <code>p3</code>. A call to <code>document.getElementById('example').getElementsByClassName('bbb  ccc ')</code> would return the same thing.

 <p>A call to <code>getElementsByClassName('aaa,bbb')</code> would return no nodes; none of the elements above are in the <code>aaa,bbb</code> class.
</div>

<hr>

<dl>
 <dt><var>element</var> = <var>document</var> . <code><a>createElement(<var>localName</var>)</a></code>
 <dd>
  <p>Returns an <a>element</a> in the <a>HTML namespace</a> [see <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=19431'>bug 19431</a>] with <var>localName</var> as <a href="#element-local-name">local name</a>. (In an <a>HTML document</a> <var>localName</var> is lowercased.)

  <p>If <var>localName</var> does not match the <code><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> production an "<code><a>InvalidCharacterError</a></code>" will be thrown.

 <dt><var>element</var> = <var>document</var> . <code><a>createElementNS(<var>namespace</var>, <var>qualifiedName</var>)</a></code>

 <dd>
  <p>Returns an <a>element</a> with <a href="#element-namespace">namespace</a> <var>namespace</var>. Its <a href="#element-namespace-prefix">namespace prefix</a> will be everything before "<code>:</code>" (U+003E) in <var>qualifiedName</var> or null. Its <a href="#element-local-name">local name</a> will be everything after "<code>:</code>" (U+003E) in <var>qualifiedName</var> or <var>qualifiedName</var>.

  <p>If <var>localName</var> does not match the <code><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> production an "<code><a>InvalidCharacterError</a></code>" will be thrown.

  <p>If one of the following conditions is true a "<code><a>NamespaceError</a></code>" will be thrown:

  <ul>
   <li><var>localName</var> does not match the <code><a>QName</a></code> production.
   <li><a href="#element-namespace-prefix">Namespace prefix</a> is not null and <var>namespace</var> is the empty string.
   <li><a href="#element-namespace-prefix">Namespace prefix</a> is "<code>xml</code>" and <var>namespace</var> is not the <a>XML namespace</a>.
   <li><var>qualifiedName</var> or <a href="#element-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>" and <var>namespace</var> is not the <a>XMLNS namespace</a>.
   <li><var>namespace</var> is the <a>XMLNS namespace</a> and neither <var>qualifiedName</var> nor <a href="#element-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>".
  </ul>

 <dt><var>documentFragment</var> = <var>document</var> . <code><a>createDocumentFragment()</a></code>
 <dd><p>Returns a <code><a>DocumentFragment</a></code> <a>node</a>.

 <dt><var>text</var> = <var>document</var> . <code><a>createTextNode(<var>data</var>)</a></code>
 <dd><p>Returns a <code><a>Text</a></code> <a>node</a> whose <a href="#cd-data">data</a> is <var>data</var>.

 <dt><var>comment</var> = <var>document</var> . <code><a>createComment(<var>data</var>)</a></code>
 <dd><p>Returns a <code><a>Comment</a></code> <a>node</a> whose <a href="#cd-data">data</a> is <var>data</var>.

 <dt><var>processingInstruction</var> = <var>document</var> . <code><a>createProcessingInstruction(<var>target</var>, <var>data</var>)</a></code>
 <dd>
  <p>Returns a <code><a>ProcessingInstruction</a></code> <a>node</a> whose <a href="#pi-target">target</a> is <var>target</var> and <a href="#cd-data">data</a> is <var>data</var>.
  <p>If <var>target</var> does not match the <code><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> production an "<code><a>InvalidCharacterError</a></code>" will be thrown.
  <p>If <var>data</var> contains "<code>?&gt;</code>" an "<code><a>InvalidCharacterError</a></code>" will be thrown.
</dl>

<p>The <dfn>element interface</dfn> for any <var>name</var> and <var>namespace</var> is <code><a>Element</a></code>, unless stated otherwise.

<p class="note">Note: The HTML Standard will e.g. define that for <code>html</code> and the <a>HTML namespace</a>, the <code>HTMLHtmlElement</code> interface is used. [[!HTML5]

<p>The <dfn><code>createElement(<var>localName</var>)</code></dfn> method must run the these steps:

<ol>
 <li><p>If <var>localName</var> does not match the <code><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> production, <a>throw</a> an "<code><a>InvalidCharacterError</a></code>".

 <li><p>If the <a>context object</a> is an <a>HTML document</a>, let <var>localName</var> be <a>converted to ASCII lowercase</a>.

 <li><p>Let <var>interface</var> be the <a>element interface</a> for <var>localName</var> and the <a>HTML namespace</a>.

 <li><p>Return a new <a>element</a> that implements <var>interface</var>, with no attributes, <a href="#element-namespace">namespace</a> set to the <a>HTML namespace</a> [see <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=19431'>bug 19431</a>], <a href="#element-local-name">local name</a> set to <var>localName</var>, and <a>node document</a> set to the <a>context object</a>.
</ol>

<p>The <dfn><code>createElementNS(<var>namespace</var>, <var>qualifiedName</var>)</code></dfn> method must run these steps:
<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>. Rethrow
 any exceptions.

 <li><p>Let <var>interface</var> be the
 <a href="#element-interface" title="element-interface">element interface</a> for
 <var>localName</var> and <var>namespace</var>.

 <li><p>Return a new <a href="#concept-element" title="concept-element">element</a> that implements <var>interface</var>,
 with no attributes,
 <a href="#element-namespace" title="element-namespace">namespace</a> set to <var>namespace</var>,
 <a href="#element-namespace-prefix" title="element-namespace-prefix">namespace prefix</a> set to <var>prefix</var>,
 <a href="#element-local-name" title="element-local-name">local name</a> set to <var>localName</var>, and
 <a href="#node-document" title="node-document">node document</a> set to the <a href="#context-object">context object</a>.
</ol>

<p>The <dfn><code>createDocumentFragment()</code></dfn> method must return a new <code><a>DocumentFragment</a></code> <a>node</a> with its <a>node document</a> set to the <a href="#context-object">context object</a>.

<p>The <dfn><code>createTextNode(<var>data</var>)</code></dfn> method must return a new <code><a>Text</a></code> <a>node</a> with its <a href="#cd-data">data</a> set to <var>data</var> and <a>node document</a> set to the <a>context object</a>.

<p class="note">Note: No check is performed that <var>data</var> consists of characters that match the <code><a href="http://www.w3.org/TR/xml/#NT-Char">Char</a></code> production.

<p>The <dfn><code>createComment(<var>data</var>)</code></dfn> method must return a new <code><a>Comment</a></code> <a>node</a> with its <a href="#cd-data">data</a> set to <var>data</var> and <a>node document</a> set to the <a>context object</a>.
<p class="note">Note: No check is performed that <var>data</var> consists of characters that match the <code><a href="http://www.w3.org/TR/xml/#NT-Char">Char</a></code> production or that it contains two adjacent hyphens or ends with a hyphen.

<p>The <dfn><code>createProcessingInstruction(<var>target</var>, <var>data</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var>target</var> does not match the <code><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> production, <a>throw</a> an "<code><a>InvalidCharacterError</a></code>". <!-- DOM3 does not check for "xml" -->

 <li><p>If <var>data</var> contains the string "<code>?&gt;</code>", <a>throw</a> an "<code><a>InvalidCharacterError</a></code>". <!-- Gecko does this. -->

 <li><p>Return a new <code><a>ProcessingInstruction</a></code> <a>node</a>, with <a href="#pi-target">target</a> set to <var>target</var>, <a href="#cd-data">data</a> set to <var>data</var>, and <a>node document</a> set to the <a>context object</a>.
</ol>

<p class="note">Note: No check is performed that <var>target</var> contains "<code>xml</code>" or "<code>:</code>", or that <var>data</var> contains characters that match the <code><a href="http://www.w3.org/TR/xml/#NT-Char">Char</a></code> production.

<hr>

<dl>
 <dt><var>clone</var> = <var>document</var> . <code><a>importNode(<var>node</var> [, <var>deep</var> = false])</a></code>
 <dd>
 <dd>
  <p>Returns a copy of <var>node</var>. If <var>deep</var> is true, the copy also includes the <var>node</var>'s <a>descendants</a>.

  <p>If <var>node</var> is a <a>document</a> throws a "<code><a>NotSupportedError</a></code>".

 <dt><var>node</var> = <var>document</var> . <code><a>adoptNode(<var>node</var>)</a></code>

 <dd>
  <p>Moves <var>node</var> from another <a>document</a> and returns it.

  <p>If <var>node</var> is a <a>document</a> throws a "<code><a>NotSupportedError</a></code>".
</dl>

<p>The <dfn><code>importNode(<var>node</var>, <var>deep</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var>node</var> is a <a>document</a>, <a>throw</a> a "<code><a>NotSupportedError</a></code>".

 <li><p>Return a <a href="#node-clone">clone</a> of <var>node</var>, with <a>context object</a> and the <i>clone children flag</i> set if <var>deep</var> is true.
</ol>

<p><a>Specifications</a> may define <dfn>adopting steps</dfn> for all or some <a>nodes</a>. The algorithm is passed <var>node</var> and <var>oldDocument</var>, as indicated in the <a>adopt</a> algorithm.

<p>To <dfn>adopt</dfn> a <var>node</var> into a <var>document</var>, run these steps:

<ol>
 <li><p>Let <var>oldDocument</var> be <var>node</var>'s <a>node document</a>.

 <li><p>If <var>node</var>'s <a>parent</a> is not null, <a href="#node-remove">remove</a> <var>node</var> from its <a>parent</a>.

 <li>
  <p>If <var>document</var> is not the same as <var>oldDocument</var>, run these substeps:

  <ol>
   <li>
    <p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
    <a>inclusive descendants</a>, run these subsubsteps:
    <ol>
     <li><p>Set <var>inclusiveDescendant</var>'s <a>node document</a> to <var>document</var>.

     <li><p>If <var>inclusiveDescendant</var> is an <a href="#concept-element">element</a>, then set the
     <a>node document</a> of each <a href="#concept-attribute">attribute</a> in <var>inclusiveDescendant</var>'s
     <a>attribute list</a> to <var>document</var>.
    </ol>

   <li><p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
   <a>inclusive descendants</a>, in <a>tree order</a>, run the
   <a>adopting steps</a> with <var>inclusiveDescendant</var> and <var>oldDocument</var>.
  </ol>
</ol>

<p>The <dfn><code>adoptNode(<var>node</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var>node</var> is a <a>document</a>, <a>throw</a> a "<code><a>NotSupportedError</a></code>".

 <li><p><a>Adopt</a> <var>node</var> into the <a>context object</a>.

 <li><p>Return <var>node</var>.
</ol>

<hr>

<p>The <dfn><code>createEvent(<var>interface</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>Let <var>constructor</var> be null.

 <li>
  <p>If <var>interface</var> is an <a>ASCII case-insensitive</a> match for any of the strings in the first column in the following table, set <var>constructor</var> to the interface in the second column on the same row as the matching string:</p>

  <table>
   <thead>
    <tr><th>String<th>Interface<td>Notes
   <tbody>
    <tr><td>"<code>compositionevent</code>"<td><code><a>CompositionEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>customevent</code>"<td>{{CustomEvent}}<td>
    <tr><td>"<code>event</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>event</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>events</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>hashchangeevent</code>"<td><code><a>HashChangeEvent</a></code><td> [[HTML51]]
    <tr><td>"<code>htmlevents</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>keyboardevent</code>"<td><code><a>KeyboardEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>messageevent</code>"<td><code><a>MessageEvent</a></code><td> [[WEBMESSAGING]]
    <tr><td>"<code>mouseevent</code>"<td><code><a>MouseEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>mouseevents</code>"<td><code><a>MouseEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>storageevent</code>"<td><code><a>StorageEvent</a></code><td> [[WEBSTORAGE]]
    <tr><td>"<code>uievent</code>"<td><code><a>UIEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>uievents</code>"<td><code><a>UIEvent</a></code><td> [[UIEVENTS]]
  </table></li>

 <li><p>If <var>constructor</var> is null, <a>throw</a> a "<code><a>NotSupportedError</a></code>".

 <li><p>Let <var>event</var> be the result of <a>invoking</a> the initial value of <var>constructor</var> with the empty string as argument.

 <li><p>Unset <var>event</var>'s <a>initialized flag</a>.

 <li><p>Return <var>event</var>.
</ol>

<p class="note">Note: <a>Event</a> constructors can be used instead.

<hr>

<p>The <dfn><code>createRange()</code></dfn> method must return a new <a>range</a> with (<a>context object</a>, 0) as its <a>start</a> and <a>end</a>.

<p class="note">Note: The <code><a>Range()</a></code> constructor can be used instead.

<hr>

<p>The <dfn><code>createNodeIterator(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>Create a <code><a>NodeIterator</a></code> object.
 <li><p>Set <a href="#traversal-root">root</a> and initialize the <code><a>referenceNode</a></code> attribute to the <var>root</var> argument.
 <li><p>Initialize the <code><a>pointerBeforeReferenceNode</a></code> attribute to true.
 <li><p>Set <a href="#traversal-whattoshow">whatToShow</a> to the <var>whatToShow</var> argument.
 <li><p>Set <a href="#traversal-filter" title="traversal-filter">filter</a> to <var>filter</var>.
 <li><p>Return the newly created <code><a>NodeIterator</a></code> object.
</ol>

<p>The <dfn><code>createTreeWalker(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>Create a <code><a>TreeWalker</a></code> object.
 <li><p>Set <a href="#traversal-root" title="traversal-root">root</a> and initialize the <code><a>currentNode</a></code> attribute to the <var>root</var> argument.
 <li><p>Set <a href="#traversal-whattoshow">whatToShow</a> to the <var>whatToShow</var> argument.
 <li><p>Set <a href="#traversal-filter" title="traversal-filter">filter</a> to <var>filter</var>.
 <li><p>Return the newly created <code><a>TreeWalker</a></code> object.
</ol>

<h4 id="interface-domimplementation">Interface <code><a>DOMImplementation</a></code></h4>

<p>User agents must create a <code><a>DOMImplementation</a></code> object whenever a <a>document</a> is created and associate it with that <a>document</a>.

<pre class='idl'>
[Exposed=Window]
interface DOMImplementation {
  [NewObject] DocumentType createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] XMLDocument createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional DocumentType? doctype = null);
  [NewObject] Document createHTMLDocument(optional DOMString title);

  boolean hasFeature(); // useless; always returns true
};
</pre>

<dl>
 <dt><code><var>doctype</var> = <var>document</var> . <a>implementation</a> . <a>createDocumentType</a>(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</code>

 <dd>
  <p>Returns a <a>doctype</a>, with the given <var>qualifiedName</var>, <var>publicId</var>, and <var>systemId</var>. If <var>qualifiedName</var> does not match the <code><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> production, an "<code><a>InvalidCharacterError</a></code>" is thrown, and if it does not match the <code><a>QName</a></code> production, a "<code><a>NamespaceError</a></code>" is thrown.

 <dt><code><var>doc</var> = <var>document</var> . <a>implementation</a> . <a>createDocument</a>(<var>namespace</var>, <var>qualifiedName</var> [, <var>doctype</var> = null])</code>

 <dd>
  <p>Returns an <code><a>XMLDocument</a></code> [see <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22960">bug 22960</a>], with a <a>document element</a> whose <a href="#element-local-name">local name</a> is <var>qualifiedName</var> and whose <a href="#element-namespace">namespace</a> is <var>namespace</var> (unless <var>qualifiedName</var> is the empty string), and with <var>doctype</var>, if it is given, as its <a href="#concept-doctype">doctype</a>.

  <p>This method throws the same exceptions as the <code><a>createElementNS</a></code> method, when invoked with the same arguments.

 <dt><code><var>doc</var> = <var>document</var> . <a>implementation</a> . <a>createHTMLDocument</a>([<var>title</var>])</code>

 <dd>
  <p>Returns a <a>document</a>, with a basic <a>tree</a> already constructed including a <code>title</code> element, unless the <var>title</var> argument is omitted.
</dl>

<div>

<p>The <dfn><code>createDocumentType(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var>qualifiedName</var> does not match the <code><a>Name</a></code> production, <a>throw</a> an "<code><a>InvalidCharacterError</a></code>".
 <li><p>If <var>qualifiedName</var> does not match the <code><a>QName</a></code> production, <a>throw</a> a "<code><a>NamespaceError</a></code>".
 <li><p>Return a new <a href="#concept-doctype">doctype</a>, with <var>qualifiedName</var> as its <a href="#doctype-name">name</a>, <var>publicId</var> as its <a>public ID</a>, and <var>systemId</var> as its <a>system ID</a>, and with its <a>node document</a> set to the associated <a>document</a> of the <a>context object</a>.
</ol>
<p class="note">Note: No check is performed that <var>publicId</var> matches the <code>PublicChar</code> production or that <var>systemId</var> does not contain both a '<code>"</code>' and "<code>'</code>".

<p>The <dfn><code>createDocument(<var>namespace</var>, <var>qualifiedName</var>, <var>doctype</var>)</code></dfn> method must run these steps:

<ol>
 <li>
  <p>Let <var>document</var> be a new <code><a href="#xmldocument">XMLDocument</a></code> [see <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22960">bug 22960</a>].

 <li><p>Let <var>element</var> be null.

 <li><p>If <var>qualifiedName</var> is not the empty string, set <var>element</var> to the result of invoking the <code><a>createElementNS()</a></code> method with the arguments <var>namespace</var> and <var>qualifiedName</var> on <var>document</var>. Rethrow any exceptions.

 <li><p>If <var>doctype</var> is not null, <a>append</a> <var>doctype</var> to <var>document</var>.

 <li><p>If <var>element</var> is not null, <a>append</a> <var>element</var> to <var>document</var>.

 <li><p><var>document</var>'s <a href="#concept-document-origin">origin</a> is <a>context object</a>'s associated <a href="#concept-document">document</a>'s <a href="#concept-document-origin">origin</a>.

 <li>
  <p><var>document</var>'s <a>content type</a> is determined by <var>namespace</var>:

    <dl class=switch>
      <dt><a>HTML namespace</a>
      <dd><code>application/xhtml+xml</code>

      <dt><a>SVG namespace</a>
      <dd><code>image/svg+xml</code>

      <dt><a>Any other namespace</a>
      <dd><code>application/xml</code>
    </dl>

 <li><p>Return <var>document</var>.
</ol>

<p>The <dfn><code>createHTMLDocument(<var>title</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>Let <var>doc</var> be a new <a>document</a> that is an <a>HTML document</a>.

 <li><p>Set <var>doc</var>'s <a>content type</a> to "<code>text/html</code>".

 <li><p>Create a <a>doctype</a>, with "<code>html</code>" as its <a href="#doctype-name">name</a> and with its <a>node document</a> set to <var>doc</var>. <a>Append</a> the newly created node to <var>doc</var>.

 <li><p>Create an <code>html</code> element in the <a>HTML namespace</a>, and <a>append</a> it to <var>doc</var>.

 <li><p>Create a <code>head</code> element in the <a>HTML namespace</a>, and  <a>append</a> it to the <code>html</code> element created in the previous step.

 <li>
  <p>If the <var>title</var> argument is not omitted:

  <ol>
   <li><p>Create a <code>title</code> element in the <a>HTML namespace</a>, and <a>append</a> it to the <code>head</code> element created in the previous step.

   <li><p>Create a <code><a>Text</a></code> <a>node</a>, set its <a href="#cd-data">data</a> to <var>title</var> (which could be the empty string), and <a>append</a> it to the <code>title</code> element created in the previous step.
  </ol>

 <li><p>Create a <code>body</code> element in the <a>HTML namespace</a>, and <a>append</a> it to the <code>html</code> element created in the earlier step.

 <li><p><var>document</var>'s <a href="#concept-document-origin">origin</a> is <a>context object</a>'s associated <a href="#concept-document">document</a>'s <a href="#concept-document-origin">origin</a>.

 <li><p>Return <var>doc</var>.
</ol>

<p>The <dfn><code>hasFeature()</code></dfn> method must return true.

<p class="note">Note: <code><a>hasFeature()</a></code> originally would report whether the user agent claimed to support a given DOM feature, but experience proved it was not nearly as reliable or granular as simply checking whether the desired objects, attributes, or methods existed. As such, it should no longer be used, but continues to exist (and simply returns true) so that old pages don't stop working.

</div>

<h3 id="nodes-interface-documentfragment">Interface <code><a>DocumentFragment</a></code></h3>

<pre class='idl'>
[Constructor,
 Exposed=Window]
interface DocumentFragment : Node {
};
</pre>

<p>A <code><a>DocumentFragment</a></code> <a>node</a> can have an associated <a>element</a> named <dfn>host</dfn>.

<p>An object <var>A</var> is a <dfn>host-including inclusive ancestor</dfn> of an object <var>B</var>, if either <var>A</var> is an <a>inclusive ancestor</a> of <var>B</var>, or if <var>B</var>'s <a href="#tree-root">root</a> has an associated <a>host</a> and <var>A</var> is a <a>host-including inclusive ancestor</a> of <var>B</var>'s <a href="#tree-root">root</a>'s <a>host</a>.

<p class="note">Note: The <code><a>DocumentFragment</a></code> <a>node</a>'s <a>host</a> concept is useful for HTML's <code>template</code> element and the <code>ShadowRoot</code> object and impacts the <a>pre-insert</a> and <a>replace</a> algorithms.

<dl>
 <dt><code><var>tree</var> = new <a>DocumentFragment</a>()</code>
 <dd><p>Returns a new <code><a>DocumentFragment</a></code> <a>node</a>.
</dl>

<p>The <dfn><code>DocumentFragment()</code></dfn> constructor must return a new <code><a>DocumentFragment</a></code> <a>node</a> whose <a>node document</a> is the global object's associated <a>document</a>.

<h3 id="nodes-interface-documenttype">Interface <code><a>DocumentType</a></code></h3>

<pre class='idl'>
[Exposed=Window]
interface DocumentType : Node {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};
</pre>

<p><code><a>DocumentType</a></code> <a>nodes</a> are simply known as <dfn id="concept-doctype" for="concept">doctypes</dfn>.

<p><a href="#concept-doctype">Doctypes</a> have an associated <dfn id="doctype-name">name</dfn>, <dfn>public ID</dfn>, and <dfn>system ID</dfn>.

<p>When a <a href="#concept-doctype">doctype</a> is created, its <a href="#doctype-name">name</a> is always given. Unless explicitly given when a <a href="#concept-doctype">doctype</a> is created, its <a>public ID</a> and <a>system ID</a> are the empty string.

<p>The <dfn id="documenttype-name" for="documenttype"><code>name</code></dfn> attribute must return the <a href="#doctype-name">name</a>.

<p>The <dfn><code>publicId</code></dfn> attribute must return the <a>public ID</a>.

<p>The <dfn><code>systemId</code></dfn> attribute must return the <a>system ID</a>.

<h3 id="nodes-interface-element">Interface <code><a href="#dom-element">Element</a></code></h3>
<pre class='idl'>
[Exposed=Window]
interface Element : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject] readonly attribute DOMTokenList classList;

  [SameObject] readonly attribute NamedNodeMap attributes;
  DOMString? getAttribute(DOMString qualifiedName);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString qualifiedName, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
  void removeAttribute(DOMString qualifiedName);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString qualifiedName);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);


  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  Element? insertAdjacentElement(DOMString where, Element element); // historical
  void insertAdjacentText(DOMString where, DOMString data); // historical
};
</pre>

<p><code><dfn id="dom-element" for="dom">Element</dfn></code> <a>nodes</a> are simply known as <dfn id="concept-element" for="concept" lt="element|elements">elements</dfn>.</p>

<p><a href="#concept-element">Elements</a> have an associated <dfn id="element-namespace" for="element">namespace</dfn>, <dfn id="element-namespace-prefix" for="element">namespace prefix</dfn>, and <dfn id="element-local-name" for="element">local name</dfn>. When an <a href="#concept-element">element</a> is created, its <a href="#element-local-name">local name</a> is always given. Unless explicitly given when an <a href="#concept-element">element</a> is created, its <a href="#element-namespace">namespace</a> and <a href="#element-namespace-prefix">namespace prefix</a> are null.

<p>An <a href="#concept-element">element</a>'s
<a>qualified name</a> is its
<a href="#element-local-name">local name</a> if its <a href="#element-namespace-prefix">namespace prefix</a> is null, or its
<a href="#element-namespace-prefix">namespace prefix</a>, followed by "<code>:</code>", followed by its
<a href="#element-local-name">local name</a>.

<p><a href="#concept-element">Elements</a> also have an ordered <dfn>attribute list</dfn>. Unless explicitly given when an <a href="#concept-element">element</a> is created, its <a>attribute list</a> is empty. An <a href="#concept-element">element</a> <dfn>has</dfn> an <a href="#concept-attribute">attribute</a> <var>A</var> if <var>A</var> is in its <a>attribute list</a>.

<p><a>Applicable specifications</a> and this specification (can) use the hooks an <dfn>attribute is set</dfn>, an <dfn id="attribute-is-changed">attribute is changed</dfn>, an <dfn>attribute is added</dfn>, and an <dfn>attribute is removed</dfn>, for further processing of the <a href="#concept-attribute">attribute</a>'s <a href="#attribute-value">value</a>.

To <dfn export id=concept-element-attributes-replace lt="replace an attribute">replace</dfn> an
<a>attribute</a> <var>oldAttr</var> by an <a>attribute</a> <var>newAttr</var>
in an <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var>
 with name <var>oldAttr</var>'s <a href="#attribute-localname">local name</a>,
 namespace <var>oldAttr</var>'s <a href="#attribute-namespace">namespace</a>,
 and oldValue <var>oldAttr</var>'s <a href="#attribute-value">value</a>.

 <li><p>Run the <a>attribute change steps</a> with <var>element</var>, <var>oldAttr</var>'s
 <a href="#attribute-localname">local name</a>, <var>oldAttr</var>'s <a href="#attribute-value">value</a>, <var>newAttr</var>'s
 <a href="#attribute-value">value</a>, and <var>oldAttr</var>'s <a href="#attribute-namespace">namespace</a>.

 <li><p>Replace <var>oldAttr</var> by <var>newAttr</var> in the <var>element</var>'s
 <a href="#element-attribute-list">attribute list</a>.

 <li><p>Set <var>oldAttr</var>'s <a href="#concept-element">element</a> to null.

 <li><p>Set <var>newAttr</var>'s <a href="#concept-element">element</a> to <var>element</var>.
</ol>

To <dfn id="element-attributes-get-by-name">get an attribute by name</dfn> given a
<var>qualifiedName</var> and <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p>If <var>element</var> is in the <a>HTML namespace</a> and its <a>node document</a>
 is an <a>HTML document</a>, then set <var>qualifiedName</var> to <var>qualifiedName</var> in
 <a>ASCII lowercase</a>.

 <li><p>Return the first <a href="#concept-attribute">attribute</a> in <var>element</var>'s <a>attribute list</a>
 whose <a href="#attribute-qualified-name">qualified name</a> is <var>qualifiedName</var>, and null otherwise.
</ol>

<p>To <dfn id="element-attributes-get-by-namespace">get an attribute by namespace and local name</dfn>
given a <var>namespace</var>, <var>localName</var>, and <a href="#concept-element">element</a> <var>element</var>,
run these steps:

<ol>
 <li>If <var>namespace</var> is the empty string, set it to null.

 <li>Return the <a href="#concept-attribute">attribute</a> in
 <var>element</var>'s <a>attribute list</a>
 whose <a href="#attribute-namespace">namespace</a> is
 <var>namespace</var> and
 <a href="#attribute-local-name">local name</a> is
 <var>localName</var>, if any, and null otherwise.
</ol>

<p>To <dfn>get an attribute value</dfn> given <a href="#concept-element">element</a> <var>element</var>,
<var>localName</var>, and an optional <var>namespace</var> (null unless stated otherwise), run these steps:</p>

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-namespace">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.</p></li>

 <li><p>If <var>attr</var> is null, then return the empty string.</p></li>

 <li><p>Return <var>attr</var>'s <a for=Attr>value</a>.</p></li>
</ol>

To <dfn>set an attribute</dfn> given an
<var>attr</var> and <var>element</var>, run these steps:

<ol>
 <li><p>If <var>attr</var>'s <a href="#concept-element">element</a> is neither null nor <var>element</var>,
 <a>throw</a> an {{InUseAttributeError}}.

 <li><p>Let <var>oldAttr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>attr</var>'s <a href="#attribute-namespace">namespace</a>, <var>attr</var>'s <a href="#attribute-local-name">local name</a>, and
 <var>element</var>.

 <li><p>If <var>oldAttr</var> is <var>attr</var>, return <var>attr</var>.

 <li><p>If <var>oldAttr</var> is non-null, <a lt="replace an attribute">replace</a> it
  by <var>attr</var> in <var>element</var>.

 <li><p>Otherwise, <a href="#element-append">append</a> <var>attr</var> to <var>element</var>.

 <li><p>Return <var>oldAttr</var>.
</ol>

<p>To <dfn>set an attribute value</dfn> for an <a href="#concept-element">element</a> <var>element</var>
using a <var>localName</var> and <var>value</var>, and an optional <var>prefix</var>, and
an optional <var>namespace</var>, run these steps:

<ol>
 <li>If <var>prefix</var> is not given, set it to null.

 <li>If <var>namespace</var> is not given, set it to null.

 <li>Let <var>attribute</var> be the result of
 <a href="#element-attributes-get-by-namespace">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li>If <var>attribute</var> is null, create an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-namespace">namespace</a> is
 <var>namespace</var>, <a href="#attribute-namespace-prefix">namespace prefix</a> is <var>prefix</var>,
 <a href="#attribute-local-name">local name</a> is <var>localName</var>, <a href="#attribute-value">value</a> is <var>value</var>, and
 <a href="#node-document">node document</a> is <var>element</var>'s <a href="#node-document">node document</a>, then
 <a href="#element-append">append</a> this <a href="#concept-attribute">attribute</a> to <var>element</var>, and then
 terminate these steps.

 <li><a>Change</a>
 <var>attribute</var> from <var>element</var> to
 <var>value</var>.
</ol>


<p>To <dfn>change</dfn> an <a href="#concept-attribute">attribute</a> <var>attribute</var> from an <a href="#concept-element">element</a> <var>element</var> to <var>value</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var> with name <var>attribute</var>'s <a href="#attribute-local-name">local name</a>, namespace <var>attribute</var>'s <a href="#attribute-namespace">namespace</a>, and oldValue <var>attribute</var>'s <a href="#attribute-value">value</a>.

 <li><p>Set <var>attribute</var>'s <a href="#attribute-value">value</a> to <var>value</var>.

 <li><p>An <a>attribute is set</a> and an <a>attribute is changed</a>.
</ol>

<p>To <dfn id="element-append" lt="append an attribute">append</dfn> an <a href="#concept-attribute">attribute</a> <var>attribute</var> to an <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var> with name <var>attribute</var>'s <a href="#attribute-local-name">local name</a>, namespace <var>attribute</var>'s <a href="#attribute-namespace">namespace</a>, and oldValue null.

 <li><p>Append the <var>attribute</var> to the <var>element</var>'s <a>attribute list</a>.

 <li><p>An <a>attribute is set</a> and an <a>attribute is added</a>.
</ol>

<p>To <dfn id="element-attributes-remove" for="element-attributes">remove</dfn> an <a href="#concept-attribute">attribute</a> <var>attribute</var> from an <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var> with name <var>attribute</var>'s <a href="#attribute-local-name">local name</a>, namespace <var>attribute</var>'s <a href="#attribute-namespace">namespace</a>, and oldValue <var>attribute</var>'s <a href="#attribute-value">value</a>.

 <li><p>Remove <var>attribute</var> from the <var>element</var>'s <a>attribute list</a>.

 <li><p>An <a>attribute is removed</a>.
</ol>

<p>To <dfn id="element-attributes-remove-by-name">remove an attribute by name</dfn>
given a <var>qualifiedName</var> and <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-name">getting an attribute</a> given
 <var>qualifiedName</var> and <var>element</var>.

 <li><p>If <var>attr</var> is non-null, <a href="#element-attributes-remove">remove</a> it from
 <var>element</var>.

 <li><p>Return <var>attr</var>.
</ol>

<p> To <dfn export id="element-attributes-remove-by-namespace">remove an attribute by namespace and local name</dfn>
given a <var>namespace</var>, <var>localName</var>, and
<a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-namespace">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li><p>If <var>attr</var> is non-null, <a href="#element-attributes-remove">remove</a> it from
 <var>element</var>.

 <li><p>Return <var>attr</var>.
</ol>

<hr>

<p><a href="#concept-element">Elements</a> can have an associated <dfn lt="unique identifier|ID">unique identifier (ID)</dfn> and have an associated <code><a>DOMTokenList</a></code> object. The <code><a>DOMTokenList</a></code> object's associated <a href="#concept-attribute">attribute</a>'s <a href="#attribute-local-name">local name</a> is <code>class</code> and its associated ordered set of tokens is called the <a href="#concept-element">element</a>'s <dfn lt="class|classes">classes</dfn>.

<p class="note">Note: Historically <a href="#concept-element">elements</a> could have multiple identifiers e.g. by using the HTML <code>id</code> <a href="#concept-attribute">attribute</a> and a DTD. This specification makes <a>ID</a> a concept of the DOM and allows for only one per <a href="#concept-element">element</a>, given by an <a href="#named-attribute"><code>id</code> attribute</a>.

<p>Either when an <a href="#concept-element">element</a> is created that <a>has</a> an <a href="#named-attribute"><code>id</code> attribute</a> whose <a href="#attribute-value">value</a> is not the empty string or when an <a href="#concept-element" title="concept-element">element</a>'s <a href="#named-attribute"><code>id</code> attribute</a> is <a href="#attribute-is-set">set</a> to a <a href="#attribute-value">value</a> other than the empty string, set the <a href="#concept-element">element</a>'s <a>ID</a> to the new <a href="#attribute-value">value</a>.

<p>When an <a href="#concept-element">element</a>'s <a href="#named-attribute"><code>id</code> attribute</a> is <a href="#attribute-is-removed">removed</a> or <a href="#attribute-is-set">set</a> to the empty string, unset the <a href="#concept-element">element</a>'s <a>ID</a>.

<p>Either when an <a href="#concept-element">element</a> is created that <a>has</a> a <a href="#named-attribute"><code>class</code> attribute</a> or when an <a href="#concept-element">element</a>'s <a href="#named-attribute" ><code>class</code> attribute</a> is <a href="#attribute-is-set">set</a>, set the <a href="#concept-element">element</a>'s <a>classes</a> to the new <a href="#attribute-value">value</a>, <a>parsed</a>.

<p>When an <a href="#concept-element">element</a>'s <a href="#named-attribute"><code>class</code> attribute</a> is <a href="#attribute-is-removed">removed</a>, set the <a href="#concept-element">element</a>'s <a>classes</a> to the empty set.

<p class="note">Note: While this specification defines user agent processing requirements for <code>id</code> and <code>class</code> <a href="#concept-attribute">attributes</a> on any <a href="#concept-element">element</a>, it makes no claims as to whether using them is conforming or not.

<hr>

<p>A <a>node</a>'s <a>parent</a> of type <code><a href="#dom-element">Element</a></code> is known as a <dfn>parent element</dfn>. If the <a>node</a> has a <a>parent</a> of a different type, its <a>parent element</a> is null.</p>

<p>The <dfn>document element</dfn> of a <a>document</a> is the <a href="#concept-element">element</a> whose <a>parent</a> is that <a>document</a>, if it exists, and null otherwise.

<p class="note">Note: Per the <a>node tree</a> constraints, there can only be one such <a href="#concept-element">element</a>.

<p>When an <a href="#concept-element">element</a> or one of its <a>ancestors</a> is the <a>document element</a>, it is <dfn>in a document</dfn>.

<hr>

<dl>
 <dt><var>namespace</var> = <var>element</var> . <code><a>namespaceURI</a></code>
 <dd><p>Returns the <a href="#element-namespace">namespace</a>.

 <dt><var>prefix</var> = <var>element</var> . <code><a href="#element-prefix">prefix</a></code>
 <dd><p>Returns the <a href="#element-namespace-prefix">namespace prefix</a>.

 <dt><var>localName</var> = <var>element</var> . <code><a href="#element-localname">localName</a></code>
 <dd><p>Returns the <a href="#element-local-name">local name</a>.

 <dt><var>qualifiedName</var> = <var>element</var> . <code><a>tagName</a></code>
 <dd><p>If <a href="#element-namespace-prefix">namespace prefix</a> is not null, returns the concatenation of <a href="#element-namespace-prefix">namespace prefix</a>, "<code>:</code>", and <a href="#element-local-name">local name</a>. Otherwise it returns the <a href="#element-local-name">local name</a>. (The return value is uppercased in an <a>HTML document</a>.)
</dl>

<p>The <dfn id="element-namespaceuri" for="element"><code>namespaceURI</code></dfn> attribute must return the <a>context object</a>'s <a href="#element-namespace">namespace</a>.

<p>The <dfn id="element-prefix" for="element"><code>prefix</code></dfn> attribute must return the <a>context object</a>'s <a href="#element-namespace-prefix">namespace prefix</a>.

<p>The <dfn id="element-localname" for="element"><code>localName</code></dfn> attribute must return the <a>context object</a>'s <a href="#element-local-name">local name</a>.

<p>The <dfn><code>tagName</code></dfn> attribute
must run these steps:
<ol>
 <li><p>If <a>context object</a>'s <a href="#element-namespace-prefix">namespace prefix</a> is not null, let <var>qualified name</var> be its <a href="#element-namespace-prefix">namespace prefix</a>, followed by a "<code>:</code>" (U+003A), followed by its <a href="#element-local-name">local name</a>. Otherwise, let <var>qualified name</var> be its <a href="#element-local-name">local name</a>.

 <li><p>If the <a>context object</a> is in the <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, let <var>qualified name</var> be <a>converted to ASCII uppercase</a>.

 <li><p>Return <var>qualified name</var>.
</ol>

<hr>

<p>IDL attributes that are defined to <dfn export id="concept-reflect">reflect</dfn> a content <a href="#concept-attribute">attribute</a> of a given <var>name</var>, must have a getter and setter that follow these steps:

<dl>
  <dt>getter
  <dd>
    <p>Return the result of running <a>get an attribute value</a> given <a>context object</a> and <var>name</var>.

  <dt>setter
  <dd>
    <p><a>Set an attribute value</a> for the <a>context object</a> using <var>name</var> and the given value.
</dl>

<p>The <dfn id="element-id" for="element"><code>id</code></dfn> <a>attribute</a> must <a>reflect</a> the "<code>id</code>" content attribute.

<p>The <dfn><code>className</code></dfn> attribute must <a>reflect</a> the "<code>class</code>" content attribute.

<p>The <dfn><code>classList</code></dfn> attribute must return the associated <code><a>DOMTokenList</a></code> object representing the <a>context object</a>'s <a>classes</a>.

<hr>

<p>The <dfn id="element-attributes" for="element"><code>attributes</code></dfn> attribute must return a <code>{{{NamedNodeMap}}}</code>.

<p>The <dfn><code>getAttribute(<var>qualifiedName</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-name" title="#element-attributes-get-by-name">
 getting an attribute</a> given <var>qualifiedName</var> and the <a>context object</a>.

 <li><p>If <var>attr</var> is null, return null.

 <li><p>Return <var>attr</var>'s <a href="#attribute-value">value</a>.
</ol>

<p>The <dfn><code>getAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn> method must return the following steps:
<ol>
  <li><p>If <var>namespace</var> is the empty string, set it to null.

  <li><p>Return <a href="#element-attributes-get-by-name">getting an attribute</a> for the <a>context object</a> using <var>localName</var> and <var>namespace</var>.
</ol>

<p>The <dfn><code>setAttribute(<var>qualifiedName</var>, <var>value</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var>name</var> does not match the <code><a href="http://www.w3.org/TR/xml/#NT-QName">QName</a></code> production in XML, <a>throw</a> an "<code><a>InvalidCharacterError</a></code>".

 <li><p>If the <a>context object</a> is in the <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, let <var>qualifiedName</var> be <a>converted to ASCII lowercase</a>.

 <li><p>Let <var>attribute</var> be the first <a href="#concept-attribute">attribute</a> in the <a>context object</a>'s <a>attribute list</a> whose <a href="#attribute-name">name</a> is <var>qualifiedName</var>, or null if there is no such <a href="#concept-attribute">attribute</a>.

 <li><p>If <var>attribute</var> is null, create an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-local-name">local name</a> is <var>qualifiedName</var>, <a href="#attribute-value">value</a> is <var>value</var>,
and <a href="#node-document">node document</a> is <a>context object</a>'s <a href="#node-document">node document</a>,
 and then <a href="#element-append">append</a> this <a href="#concept-attribute">attribute</a> to the <a>context object</a> and terminate these steps.

 <li><p><a>Change</a> <var>attribute</var> from <a>context object</a> to <var>value</var>.
</ol>

<p>The <dfn><code>setAttributeNS(<var>namespace</var>, <var>qualifiedName</var>, <var>value</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>. Rethrow
 any exceptions.

 <li><p><a>Set an attribute value</a> for the <a>context object</a> using <var>localName</var>,
 <var>value</var>, and also <var>prefix</var> and <var>namespace</var>.
</ol>

<p>The <dfn><code>removeAttribute(<var>qualifiedName</var>)</code></dfn>
method, when invoked, must <a lt="remove an attribute by name">remove an attribute</a> given
<var>qualifiedName</var> and the <a>context object</a>, and then return undefined.

<p>The <dfn><code>removeAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn> method must
<a href="#element-attributes-remove-by-namespace">remove an attribute</a> given <var>namespace</var>,
<var>localName</var>, and <a>context object</a>, and then return undefined.

<p>The <dfn><code>hasAttribute(<var>name</var>)</code></dfn> method must run these steps:
<ol>
 <li><p>If the <a>context object</a> is in the <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, let <var>name</var> be <a>converted to ASCII lowercase</a>.

 <li><p>Return true if the <a>context object</a> <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-qualified-name">qualifiedName</a> is <var>qualifiedName</var>, and false otherwise.
</ol>

<p>The <dfn><code>hasAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn> method must run these steps:

<ol>
 <li><p>If <var>namespace</var> is the empty string, set it to null.

 <li><p>Return true if the <a>context object</a> <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-namespace">namespace</a> is <var>namespace</var> and <a href="#attribute-local-name">local name</a> is <var>localName</var>, and false otherwise.
</ol>

<hr>

<p>The <dfn id="element-getelementsbytagname-func" for="element"><code>getElementsByTagName(<var>localName</var>)</code></dfn> method must return the <a>list of elements with local name <var>localName</var></a> for the <a>context object</a>.

<p>The <dfn id="element-getelementsbytagnamens-func" for="element"><code>getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</code></dfn> method must return the <a>list of elements with namespace <var>namespace</var> and local name <var>localName</var></a> for the <a>context object</a>.

<p>The <dfn id="element-getelementsbyclassname-func" for="element"><code>getElementsByClassName(<var>classNames</var>)</code></dfn> method must return the <a>list of elements with class names <var>classNames</var></a> for the <a>context object</a>.

<hr>

<p>To <dfn>insert adjacent</dfn>, given an <a for=/>element</a> <var>element</var>, string
<var>where</var>, and a <a>node</a> <var>node</var>, run the steps associated with the first
<a>ASCII case-insensitive</a> match for <var>where</var>:

<dl class=switch>
 <dt>"<code>beforebegin</code>"
 <dd>
  <p>If <var>element</var>'s <a>parent</a> is null, return null.

  <p>Return the result of <a>pre-inserting</a></a> <var>node</var> into <var>element</var>'s <a>parent</a> before
  <var>element</var>. Rethrow any exceptions.

 <dt>"<code>afterbegin</code>"
 <dd><p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var> before
 <var>element</var>'s <a for=tree>first child</a>. Rethrow any exceptions.

 <dt>"<code>beforeend</code>"
 <dd><p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var> before null.
 Rethrow any exceptions.

 <dt>"<code>afterend</code>"
 <dd>
  <p>If <var>element</var>'s <a>parent</a> is null, return null.

  <p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var>'s <a>parent</a> before
  <var>element</var>'s <a for=tree>next sibling</a>. Rethrow any exceptions.

 <dt>Otherwise</dt>
 <dd><p>Throw a "<code><a>SyntaxError</a></code>".
</dl>

<p>The
<dfn method for=Element><code>insertAdjacentElement(<var>where</var>, <var>element</var>)</code></dfn>
method, when invoked, must return the result of running <a>insert adjacent</a>, given
<a>context object</a>, <var>where</var>, and <var>element</var>. Rethrow any exceptions.

<p>The
<dfn method for=Element><code>insertAdjacentText(<var>where</var>, <var>data</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>text</var> be a new <code>Text</code> object whose <a>data</a> is <var>data</var>.

 <li><p>Run <a>insert adjacent</a>, given <a>context object</a>, <var>where</var>, and
 <var>text</var>. Rethrow any exceptions.
</ol>

<p class="note">This method returns nothing because it existed before we had a chance to design it.

<h4 id=interface-namednodemap>Interface {{NamedNodeMap}}</h4>

<pre class=idl>
[Exposed=Window, LegacyUnenumerableNamedProperties]
interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter Attr? item(unsigned long index);
  getter Attr? getNamedItem(DOMString qualifiedName);
  Attr? getNamedItemNS(DOMString? namespace, DOMString localName);
  Attr? setNamedItem(Attr attr);
  Attr? setNamedItemNS(Attr attr);
  Attr removeNamedItem(DOMString qualifiedName);
  Attr removeNamedItemNS(DOMString? namespace, DOMString localName);
};
</pre>

A {{NamedNodeMap}} has an associated
<dfn export id=concept-namednodemap-element for=NamedNodeMap>element</dfn> (an
<a href="#concept-element">element</a>).

A {{NamedNodeMap}} object's
<dfn export id=concept-namednodemap-attribute for=NamedNodeMap>attribute list</dfn> is its
<a href="#concept-namednodemap-element">element</a>'s
<a href="#attribute-list">attribute list</a>.

<hr>

A {{NamedNodeMap}} object's
<a>supported property indices</a> are the numbers in the
range zero to the number of <a>attributes</a> in its
<a href="#concept-namednodemap-attribute">attribute list</a> map minus one, unless the
<a href="#concept-namednodemap-attribute">attribute list</a> is empty, in which case
there are no <a>supported property indices</a>.

<p>The <dfn attribute for="NamedNodeMap"><code>length</code></dfn> attribute's getter must return
the number of <a>attributes</a> in the <a for=NamedNodeMap>attribute list</a>.

<p>The <dfn method for="NamedNodeMap"><code>item(<var>index</var>)</code></dfn> method, when
invoked, must run these steps:

<ol>
 <li><p>If <var>index</var> is equal to or greater than the number of <a>attributes</a> in the
 <a for=NamedNodeMap>attribute list</a>, return null.

 <li><p>Otherwise, return the <var>index</var>th <a>attribute</a> in the
 <a for=NamedNodeMap>attribute list</a>.
</ol>

<p>A {{NamedNodeMap}} object's <a>supported property names</a> are the return value of running these
steps:

<ol>
 <li><p>Let <var>names</var> be the <a href="#attribute-qualified-name">qualified names</a> of the <a>attributes</a> in this
 {{NamedNodeMap}} object's <a for=NamedNodeMap>attribute list</a>, with duplicates omitted, in
 order.
 <!-- Even though not all names that map to an attribute are listed, due to lowercasing, ECMAScript
      invariants are not violated. https://github.com/whatwg/dom/issues/141#issuecomment-168753410
      has details. -->

 <li>
  <p>If this {{NamedNodeMap}} object's <a for=NamedNodeMap>element</a> is in the
  <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, then for
  each <var>name</var> in <var>names</var>, run these substeps:

  <ol>
   <li><p>Let <var>lowercaseName</var> be <var>name</var>, in <a href="#converted-to-ascii-lowercase">ASCII lowercase</a>.

   <li><p>If <var>lowercaseName</var> is not equal to <var>name</var>, remove <var>name</var> from
   <var>names</var>.
  </ol>

 <li><p>Return <var>names</var>.
</ol>

<p>The <dfn method for="NamedNodeMap"><code>getNamedItem(<var>qualifiedName</var>)</code></dfn>
method, when invoked, must return the result of
<a lt="get an attribute by name">getting an attribute</a> given <var>qualifiedName</var> and
<a for=NamedNodeMap>element</a>.

<p>The
<dfn method for="NamedNodeMap"><code>getNamedItemNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method, when invoked, must return the result of
<a lt="get an attribute by namespace and local name">getting an attribute</a> given
<var>namespace</var>, <var>localName</var>, and
<a for=NamedNodeMap>element</a>.

<p>The <dfn method for="NamedNodeMap"><code>setNamedItem(<var>attr</var>)</code></dfn> and
<dfn method for="NamedNodeMap"><code>setNamedItemNS(<var>attr</var>)</code></dfn>
methods, when invoked, must return the result of <a lt="set an attribute">setting an attribute</a> given <var>attr</var> and <a for=NamedNodeMap>element</a>. Rethrow any exceptions.

<p>The <dfn method for="NamedNodeMap"><code>removeNamedItem(<var>qualifiedName</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="remove an attribute by name">removing an attribute</a> given
 <var>qualifiedName</var> and <a for=NamedNodeMap>element</a>.

 <li><p>If <var>attr</var> is null, then <a>throw</a> a {{NotFoundError}}.

 <li><p>Return <var>attr</var>.
</ol>

<p>The
<dfn method for="NamedNodeMap"><code>removeNamedItemNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="remove an attribute by namespace and local name">removing an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <a for=NamedNodeMap>element</a>.

 <li><p>If <var>attr</var> is null, then <a>throw</a> a {{NotFoundError}}.

 <li><p>Return <var>attr</var>.
</ol>

<h4 id="interface-attr">Interface <code><a>Attr</a></code></h4>
<pre class='idl'>
[Exposed=Window]
interface Attr : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
  readonly attribute DOMString nodeName; // for legacy use, alias of .name
           attribute DOMString value;

  readonly attribute Element? ownerElement;

  readonly attribute boolean specified; // useless; always returns true
};
</pre>

<p><code><a href="#attr">Attr</a></code> <a href="#node">nodes</a> are simply known as <dfn id="concept-attribute" for="attribute">attributes</dfn>. They are sometimes referred to as <em>content attributes</em> to avoid confusion with IDL attributes.

<p><a href="#concept-attribute">Attributes</a> have a <dfn id="attribute-namespace" for="attribute">namespace</dfn> (null or a non-empty string), <dfn id="attribute-namespace-prefix" for="attribute">namespace prefix</dfn> (null or a non-empty string), <dfn id="attribute-local-name" for="attribute">local name</dfn> (a non-empty string), <dfn id="attribute-name" for="attribute">name</dfn> (a non-empty string), <dfn id="attribute-value" for="attribute">value</dfn> (a string), and <dfn id="attribute-element" for="attribute">element</dfn> (null or an <a href="#concept-element">element</a>).

<p class="note">Note: If designed today they would just have a name and value.

<p>An <a>attribute</a>'s
<dfn id="attribute-qualified-name">qualified name</dfn> is its
<a href="#attribute-name">local name</a> if its <a href="#attribute-namespace-prefix">namespace prefix</a> is null, and its
<a href="#attribute-namespace-prefix">namespace prefix</a>, followed by "<code>:</code>", followed by its
<a href="#attribute-local-name">local name</a>, otherwise.

<p>When an <a href="#concept-attribute">attribute</a> is created, its <a href="#attribute-local-name">local name</a> and <a href="#attribute-value">value</a> are always given. Unless explicitly given when an <a href="#concept-attribute">attribute</a> is created, its <a href="#attribute-name">name</a> is identical to its <a href="#attribute-local-name">local name</a>, and its <a href="#attribute-namespace">namespace</a> and <a href="#attribute-namespace-prefix">namespace prefix</a> are null.

<p>An <dfn id="named-attribute" for="named"><code><var>A</var></code> attribute</dfn> is an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-local-name">local name</a> is <code><var>A</var></code> and whose <a href="#attribute-namespace">namespace</a> and <a href="#attribute-namespace-prefix">namespace prefix</a> are null.

<p>The <dfn id="attr-namespaceuri" for="attr"><code>namespaceURI</code></dfn> attribute's getter must return the <a href="#attribute-namespace">namespace</a>.

<p>The <dfn id="attr-prefix" for="attr"><code>prefix</code></dfn> attribute's getter must return the <a href="#attribute-namespace-prefix">namespace prefix</a>.

<p>The <dfn id="attr-localname" for="attr"><code>localName</code></dfn> attribute's getter must return the <a href="#attribute-local-name">local name</a>.

<p>The <dfn id="attr-name"  for="attr"><code>name</code></dfn> attribute's getter and <dfn id="attr-nodename" for="attr"><code>nodeName</code></dfn> attribute's getter must return the <a href="#attribute-name">name</a>.

<p>The <dfn id="attr-value" for="attr"><code>value</code></dfn> attribute's getter must both return the <a href="#attribute-value">value</a>.

<p>To <dfn>set an existing attribute value</dfn>, given an <a>attribute</a> <var>attribute</var> and
string <var>value</var>, run these steps:

<ol>
 <li>If <var>attribute</var>'s <a href="#attribute-element">element</a> is null, then set <var>attribute</var>'s
 <a href="#attribute-value">value</a> to <var>value</var>.

 <li>Otherwise, <a>change</a> <var>attribute</var> from
 <var>attribute</var>'s <a href="#attribute-element">element</a> to <var>value</var>.
</ol>

<p>The {{Attr/value}} attribute's setter must <a>set an existing attribute value</a> with
<a>context object</a> and the given value.

<p>The <dfn attribute for="Attr"><code>ownerElement</code></dfn> attribute's getter must return
<a>context object</a>'s <a href="#attribute-element">element</a>.

<p>The <dfn><code>specified</code></dfn> attribute must return true.

<h3 id="nodes-interface-characterdata">Interface <code><a>CharacterData</a></code></h3>

<pre class='idl'>
[Exposed=Window]
interface CharacterData : Node {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};
</pre>

<p class="note">Note: <code><dfn>CharacterData</dfn></code> is an abstract interface and does not exist as <a>node</a>. It is used by <code><a>Text</a></code>, <code><a>Comment</a></code>, and <code><a>ProcessingInstruction</a></code> <a>nodes</a>.

<p>Each <a>node</a> inheriting from the <code><a>CharacterData</a></code> interface has an associated mutable string called <dfn id="cd-data" for="cd">data</dfn>.

<p>To <dfn>replace data</dfn> of node <var>node</var> with offset <var>offset</var>, count <var>count</var>, and data <var>data</var>, run these steps:</p>

<ol>
 <li><p>Let <var>length</var> be <var>node</var>'s <code><a href="#characterdata-length">length</a></code> attribute value.

 <li><p>If <var>offset</var> is greater than <var>length</var>, <a>throw</a> an "<code><a>IndexSizeError</a></code>".

 <li><p>If <var>offset</var> plus <var>count</var> is greater than <var>length</var> let <var>count</var> be <var>length</var> minus <var>offset</var>.

 <li><p><a>Queue a mutation record</a> of "<code><a>characterData</a></code>" for <var>node</var> with oldValue <var>node</var>'s <a href="#cd-data">data</a>.

 <li><p>Insert <var>data</var> into <var>node</var>'s <a href="#cd-data">data</a> after <var>offset</var> <a>code units</a>.

 <li><p>Let <var>delete offset</var> be <var>offset</var> plus the number of <a>code units</a> in <var>data</var>.

 <li><p>Starting from <var>delete offset</var> <a>code units</a>, remove <var>count</var> <a>code units</a> from <var>node</var>'s <a href="#cd-data">data</a>.

 <li><p>For each <a>range</a> whose <a>start node</a> is <var>node</var> and <a>start offset</a> is greater than <var>offset</var> but less than or equal to <var>offset</var> plus <var>count</var>, set its <a>start offset</a> to <var>offset</var>.

 <li><p>For each <a>range</a> whose <a>end node</a> is <var>node</var> and <a>end offset</a> is greater than <var>offset</var> but less than or equal to <var>offset</var> plus <var>count</var>, set its <a>end offset</a> to <var>offset</var>.

 <li><p>For each <a>range</a> whos <a>start node</a> is <var>node</var> and <a>start offset</a> is greater than <var>offset</var> plus <var>count</var>, increase its <a>start offset</a> by the number of <a>code units</a> in <var>data</var>, then decrease it by <var>count</var>.

 <li><p>For each <a>range</a> whose <a>end node</a> is <var>node</var> and <a>end offset</a> is greater than <var>offset</var> plus <var>count</var>, increase its <a>end offset</a> by the number of <a>code units</a> in <var>data</var>, then decrease it by <var>count</var>.
</ol>

<p>To <dfn>substring data</dfn> with node <var>node</var>, offset <var>offset</var>, and count <var>count</var>, run these steps:

<ol>
 <li><p>Let <var>length</var> be <var>node</var>'s <code><a href="#characterdata-length">length</a></code> attribute value.

 <li><p>If <var>offset</var> is greater than <var>length</var>, <a>throw</a> an "<code><a>IndexSizeError</a></code>".

 <li><p>If <var>offset</var> plus <var>count</var> is greater than <var>length</var>, return a string whose value is the <a>code units</a> from the <var>offset</var><sup>th</sup> <a>code unit</a> to the end of <var>node</var>'s <a href="#cd-data">data</a>, and then terminate these steps.

 <li><p>Return a string whose value is the <a>code units</a> from the <var>offset</var><sup>th</sup> <a>code unit</a> to the <var>offset</var>+<var>count</var><sup>th</sup> <a>code unit</a> in <var>node</var>'s <a href="#cd-data">data</a>.
</ol>

<p>The <dfn id="characterdata-data" for="characterdata"><code>data</code></dfn> attribute must return <a href="#cd-data">data</a>, and on setting, must <a>replace data</a> with node <a>context object</a> offset 0, count <code><a href="#characterdata-length">length</a></code> attribute value, and data new value.

<p>The <dfn id="characterdata-length" for="characterdata"><code>length</code></dfn> attribute must return the number of <a>code units</a> in <a href="#cd-data">data</a>.

<p>The <dfn><code>substringData(<var>offset</var>, <var>count</var>)</code></dfn> method must <a>substring data</a> with node <a>context object</a>, offset <var>offset</var>, and count <var>count</var>.

<p>The <dfn><code>appendData(<var>data</var>)</code></dfn> method must <a>replace data</a> with node <a>context object</a>, offset <code><a href="#characterdata-length">length</a></code> attribute value, count 0, and data <var>data</var>.

<p>The <dfn><code>insertData(<var>offset</var>, <var>data</var>)</code></dfn> method must <a>replace data</a> with node <a>context object</a>, offset <var>offset</var>, count 0, and data <var>data</var>.

<p>The <dfn><code>deleteData(<var>offset</var>, <var>count</var>)</code></dfn> method must <a>replace data</a> with node <a>context object</a>, offset <var>offset</var>, count <var>count</var>, and data the empty string.

<p>The <dfn><code>replaceData(<var>offset</var>, <var>count</var>, <var>data</var>)</code></dfn> method must <a>replace data</a> with node <a>context object</a>, offset <var>offset</var>, count <var>count</var>, and data <var>data</var>.

<h3 id="nodes-interface-text">Interface <code><a>Text</a></code></h3>

<pre class='idl'>
[Constructor(optional DOMString data = ""),
 Exposed=Window]
interface Text : CharacterData {
  [NewObject] Text splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};
</pre>

<dl>
 <dt><code><var>text</var> = new <a href="#documentfragment">Text</a>([<var>data</var> = ""])</code>
 <dd><p>Returns a new <code><a>Text</a></code> <a>node</a> whose <a href="#cd-data">data</a> is <var>data</var>.

 <dt><code><var>text</var> . <a>splitText</a>(<var>offset</var>)</code>
 <dd><p>Splits <a href="#cd-data">data</a> at the given <var>offset</var> and returns the remainder as <code><a>Text</a></code> <a>node</a>.

 <dt><code><var>text</var> . <a>wholeText</a></code>
 <dd><p>Returns the combined <a href="#cd-data">data</a> of all direct <code><a>Text</a></code> <a>node</a> <a>siblings</a>.
</dl>

<p>The <dfn><code>Text(<var>data</var>)</code></dfn> constructor must return a new <code><a>Text</a></code> <a>node</a> whose <a href="#cd-data">data</a> is <var>data</var> and <a>node document</a> is the global object's associated <a>document</a>.

<p>To <dfn>split</dfn> a <code><a>Text</a></code> <a>node</a> <var>node</var> with offset <var>offset</var>, run these steps:

<ol>
 <li><p>Let <var>length</var> be <var>node</var>'s <code><a href="#characterdata-length">length</a></code> attribute value.

 <li><p>If <var>offset</var> is greater than <var>length</var>, <a>throw</a> an "<code><a>IndexSizeError</a></code>".

 <li><p>Let <var>count</var> be <var>length</var> minus <var>offset</var>.

 <li><p>Let <var>new data</var> be the result of <a>substringing data</a> with node <var>node</var>, offset <var>offset</var>, and count <var>count</var>.

 <li><p>Let <var>new node</var> be a new <code><a>Text</a></code> <a>node</a>, with the same <a>node document</a> as <var>node</var>. Set <var>new node</var>'s <a href="#cd-data">data</a> to <var>new data</var>.

 <li><p>Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

 <li>
  <p>If <var>parent</var> is not null, run these substeps:

  <ol>
   <li><p><a>Insert</a> <var>new node</var> into <var>parent</var> before
   <var>node</var>'s <a href="#tree-next-sibling">next sibling</a>.
   <!-- Do this before we replace data, so that the data replacement won't
   mutate ranges prematurely:
   https://www.w3.org/Bugs/Public/show_bug.cgi?id=15325 -->

   <li><p>For each <a>range</a> whose <a>start node</a> is <var>node</var> and <a>start offset</a> is greater than <var>offset</var>, set its <a>start node</a> to <var>new node</var> and decrease its <a>start offset</a> by <var>offset</var>.

   <li><p>For each <a>range</a> whose <a>end node</a> is <var>node</var> and <a>end offset</a> is greater than <var>offset</var>, set its <a>end node</a> to <var>new node</var> and decrease its <a>end offset</a> by <var>offset</var>.

   <!-- This shit is complicated:
        https://www.w3.org/Bugs/Public/show_bug.cgi?id=19968 -->
   <li><p>For each <a>range</a> whose <a>start node</a> is <var>parent</var> and <a>start offset</a> is equal to the <a>index</a> of <var>node</var> + 1, increase its <a>start offset</a> by one.

   <li><p>For each <a>range</a> whose <a>end node</a> is <var>parent</var> and <a>end offset</a> is equal to the <a>index</a> of <var>node</var> + 1, increase its <a>end offset</a> by one.
  </ol>

 <li><p><a>Replace data</a> with node <var>node</var>, offset <var>offset</var>, count <var>count</var>, and data the empty string.

 <li>
  <p>If <var>parent</var> is null, run these substeps:</p>

  <ol>
   <li><p>For each <a>range</a> whose <a>start node</a> is <var>node</var> and <a>start offset</a> is greater than <var>offset</var>, set its <a>start offset</a> to <var>offset</var>.

   <li><p>For each <a>range</a> whose <a>end node</a> is <var>node</var> and <a>end offset</a> is greater than <var>offset</var>, set its <a>end offset</a> to <var>offset</var>.
  </ol>

 <li><p>Return <var>new node</var>.
</ol>

<p>The <dfn><code>splitText(<var>offset</var>)</code></dfn> method must <a>split</a> the <a>context object</a> with offset <var>offset</var>.


<p>The <dfn>contiguous <code>Text</code> nodes</dfn> of a node are the node itself, the <a href="#tree-previous-sibling">previous sibling</a> <code><a>Text</a></code> node (if any) and its <a>contiguous <code>Text</code> nodes</a>, and the <a href="#tree-next-sibling">next sibling</a> <code><a>Text</a></code> node (if any) and its <a>contiguous <code>Text</code> nodes</a>, avoiding any duplicates.

<p>The <dfn><code>wholeText</code></dfn> attribute must return a concatenation of the <a href="#cd-data">data</a> of the <a>contiguous <code>Text</code> nodes</a> of the <a>context object</a>, in <a>tree order</a>.

<h3 id="nodes-interface-processinginstruction">Interface <code><a>ProcessingInstruction</a></code></h3>

<pre class='idl'>
[Exposed=Window]
interface ProcessingInstruction : CharacterData {
  readonly attribute DOMString target;
};
</pre>

<p><code><dfn>ProcessingInstruction</dfn></code> <a>nodes</a> have an associated <dfn id="pi-target" for="pi">target</dfn>.

<p>The <dfn id="processinginstruction-target" for="processinginstruction"><code>target</code></dfn> attribute must return the <a href="#pi-target">target</a>.

<h3 id="nodes-interface-comment">Interface <code><a>Comment</a></code></h3>

<pre class='idl'>
[Constructor(optional DOMString data = ""),
 Exposed=Window]
interface Comment : CharacterData {
};
</pre>

<dl>
 <dt><code><var>comment</var> = new <a>Comment</a>([<var>data</var> = ""])</code>
 <dd><p>Returns a new <code><a>Comment</a></code> <a>node</a> whose <a href="#cd-data">data</a> is <var>data</var>.
</dl>

<p>The <dfn><code>Comment(<var>data</var>)</code></dfn> constructor must return a new <code><a>Comment</a></code> <a>node</a> whose <a href="#cd-data">data</a> is <var>data</var> and <a>node document</a> is the global object's associated <a>document</a>.
</section>
