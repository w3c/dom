<section>
<h2 id="nodes">Nodes</h2>

<h3 id=introduction-to-the-dom>Introduction to "The DOM"</h3>

<p>In its original sense, "The DOM" is an API for accessing and manipulating documents (in particular, HTML and XML documents). In this specification, the term "document" is used for any markup-based resource, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications.

<p>These documents are presented as a <a>node tree</a>. Some of the <a>nodes</a> in the <a>tree</a> can have <a>children</a>, while others are always leaves.

<p>To illustrate, consider this HTML document:

<pre class='example'>
<code>&lt;!DOCTYPE html&gt;
&lt;html class=e&gt;
 &lt;head&gt;&lt;title&gt;Aliens?&lt;/title&gt;&lt;/head&gt;
 &lt;body&gt;Why yes.&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>It is represented as follows:

<ul class="domTree">
 <li>
  <a href="#concept-document">Document</a>
  <ul>
   <li class="t10"><a>Doctype</a>: <code>html</code></li>
   <li class="t1">{{Element}}: <code>html</code> <span class="t2"><code class="attribute name">class</code>="<code class="attribute value">e</code>"</span>
    <ul>
     <li class="t1">
      {{Element}}: <code>head</code>
      <ul>
       <li class="t1">
        {{Element}}: <code>title</code>
        <ul>
         <li class="t3">{{Text}}: <span>Aliens?</span></li>
        </ul>
       </li>
      </ul>
     </li>
     <li class="t3">{{Text}}: <span>⏎␣</span></li>
     <li class="t1">
      {{Element}}: <code>body</code>
      <ul>
       <li class="t3">{{Text}}: <span>Why yes.⏎</span></li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

<p>Note that, due to the magic of <a>HTML parser</a>, not all <a>ASCII whitespace</a> were turned into {{Text}} <a>nodes</a>, but the general concept is clear. Markup goes in, a <a>tree</a> of <a>nodes</a> comes out.

<p class="note">Note: The most excellent <a>Live DOM Viewer</a> can be used to explore this matter in more detail.

<h3 id=node-trees>Node tree</h3>
<p>Objects implementing the {{Document}}, {{DocumentFragment}}, {{DocumentType}}, {{Element}}, {{Text}}, {{ProcessingInstruction}}, or {{Comment}} interface (simply called <dfn id="concept-node" lt="node|nodes">nodes</dfn>) <a>participate</a> in a <a>tree</a>, simply named the <dfn>node tree</dfn>.

<p>A <a>node tree</a> is constrained as follows, expressed as a relationship between the type of <a href="#concept-node">node</a> and its allowed <a>children</a>:
<dl>
 <dt>{{Document}}
 <dd>
  <p>In <a>tree order</a>:
  <ol>
   <li><p>Zero or more nodes each of which is either {{ProcessingInstruction}} or {{Comment}}.
   <li><p>Optionally one {{DocumentType}} node.
   <li><p>Zero or more nodes each of which is either {{ProcessingInstruction}} or {{Comment}}.
   <li><p>Optionally one {{Element}} node.
   <li><p>Zero or more nodes each of which is either {{ProcessingInstruction}} or {{Comment}}.
  </ol>
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <dd><p>Zero or more nodes each of which is one of <code><a href="#concept-element">Element</a></code>,
 {{ProcessingInstruction}}, {{Comment}}, or
 {{Text}}.
 <dt>{{DocumentType}}
 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd><p>None.
</dl>
<!--AttrExodus -->

<p>To determine the <dfn id="node-length" for="node">length</dfn> of a <a href="#concept-node">node</a> <var>node</var>,
 switch on <var>node</var>:
<dl class="switch">
 <dt>{{DocumentType}}
 <dd><p>Zero.

 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd><p>The number of <a>code units</a> in its <a>data</a>.

 <dt>Any other node
 <dd><p>Its number of <a>children</a>.
</dl>

<p>A <a>node</a> is considered <dfn>empty</dfn> if its <a>length</a> is zero.

<h4 id=document-trees>Document tree</h4>

<p>A <dfn export id=concept-document-tree>document tree</dfn> is a <a>node tree</a> whose
<a for=tree>root</a> is a <a href="#concept-document">document</a>.

<p>The <dfn export>document element</dfn> of a <a href="#concept-document">document</a> is the <a for="/">element</a> whose
<a>parent</a> is that <a href="#concept-document">document</a>, if it exists, and null otherwise.

<p class="note">Note: Per the <a>node tree</a> constraints, there can be only one such
<a for="/">element</a>.

<p>An <a for=/>element</a> is <dfn export>in a document tree</dfn> if its <a for=tree>root</a> is a
<a href="#concept-document">document</a>.

<p>An <a for=/>element</a> is <dfn export>in a document</dfn> if it is <a>in a document tree</a>.
<p><span class="note">Note: The term <a>in a document</a> is no longer supposed to be used. It indicates that
the standard using it has not been updated to account for <a>shadow trees</a>.</span>

<h4 id=shadow-trees>Shadow tree</h4>

<p>A <dfn export id=concept-shadow-tree>shadow tree</dfn> is a <a>node tree</a> whose
<a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a>.

<p>A <a href="#concept-shadow-root">shadow root</a> is always attached to another <a>node tree</a> through its
<a>host</a>. A <a>shadow tree</a> is therefore never alone. The
<a>node tree</a> of a <a href="#concept-shadow-root">shadow root</a>'s <a>host</a> is sometimes
referred to as the <dfn export id=concept-light-tree>light tree</dfn>.</p>

<p class="note">Note: A <a>shadow tree</a>'s corresponding <a>light tree</a> can be a <a>shadow tree</a>
itself.</p>

<p id=in-a-shadow-including-document>An <a for=/>element</a> is <dfn export>connected</dfn> if its
<a>shadow-including root</a> is a <a href="#concept-document">document</a>.

<h5 id=shadow-tree-slots>Slots</h5>

<p>A <a>shadow tree</a> contains zero or more <a for=/>elements</a> that are
<dfn export id=concept-slot lt=slot>slots</dfn>.</p>

<p class="note">Note: A <a>slot</a> can only be created through HTML's <{slot}> element.</p>

<p>A <a>slot</a> has an associated <dfn export for=slot>name</dfn> (a string). Unless stated
otherwise it is the empty string.</p>

<p>Use these <a>attribute change steps</a> to update a <a>slot</a>'s <a for=slot>name</a>:

<ol>
 <li>
  <p>If <var>element</var> is a <a>slot</a>, <var>localName</var> is <code>name</code>, and
  <var>namespace</var> is null, then:

  <ol>
   <li><p>If <var>value</var> is <var>oldValue</var>, then return.

   <li><p>If <var>value</var> is null and <var>oldValue</var> is the empty string, then return.

   <li><p>If <var>value</var> is the empty string and <var>oldValue</var> is null, then return.

   <li><p>If <var>value</var> is null or the empty string, then set <var>element</var>'s
   <a for=slot>name</a> to the empty string.

   <li><p>Otherwise, set <var>element</var>'s <a for=slot>name</a> to <var>value</var>.

   <li><p>Run <a>assign slotables for a tree</a> with <var>element</var>'s <a>tree</a>.
  </ol>
</ol>

<p class="note">Note: The first <a>slot</a> in a <a>shadow tree</a>, in <a>tree order</a>, whose
<a for=slot>name</a> is the empty string, is sometimes known as the "default slot".</p>

<p>A <a>slot</a> has an associated <dfn export for=slot>assigned nodes</dfn> (a list of
<a>slotables</a>). Unless stated otherwise it is empty.</p>

<h5 id=light-tree-slotables>Slotables</h5>

<p>{{Element}} and {{Text}} <a>nodes</a> are
<dfn export id=concept-slotable lt=slotable>slotables</dfn>.</p>

<p class="note">Note: A <a>slot</a> can be a <a>slotable</a>.

<p>A <a>slotable</a> has an associated <dfn export for=slotable>name</dfn> (a string). Unless stated
otherwise it is the empty string.</p>

<p>Use these <a>attribute change steps</a> to update a <a>slotable</a>'s <a for=slotable>name</a>:

<ol>
 <li>
  <p>If <var>localName</var> is <code>slot</code> and <var>namespace</var> is null, then:

  <ol>
   <li><p>If <var>value</var> is <var>oldValue</var>, then return.

   <li><p>If <var>value</var> is null and <var>oldValue</var> is the empty string, then return.

   <li><p>If <var>value</var> is the empty string and <var>oldValue</var> is null, then return.

   <li><p>If <var>value</var> is null or the empty string, then set <var>element</var>'s
   <a for=slotable>name</a> to the empty string.

   <li><p>Otherwise, set <var>element</var>'s <a for=slotable>name</a> to <var>value</var>.

   <li><p>If <var>element</var> is <a for=slotable>assigned</a>, then run <a>assign slotables</a>
   for <var>element</var>'s <a for=slotable>assigned slot</a>.

   <li><p>Run <a>assign a slot</a> for <var>element</var>.
  </ol>
</ol>

<p>A <a>slotable</a> has an associated <dfn export for=slotable>assigned slot</dfn> (null or a
<a>slot</a>). Unless stated otherwise it is null. A <a>slotable</a> is
<dfn export for=slotable>assigned</dfn> if its <a>assigned slot</a> is non-null.</p>

<h5 id=finding-slots-and-slotables>Finding slots and slotables</h5>

<p>To <dfn export lt="find a slot|finding a slot">find a slot</dfn> for a given <a>slotable</a>
<var>slotable</var> and an optional <i>open flag</i> (unset unless stated otherwise), run these
steps:</p>

<ol>
 <li><p>If <var>slotable</var>'s <a>parent</a> is null, then return null.</p></li>

 <li><p>Let <var>shadow</var> be <var>slotable</var>'s <a>parent</a>'s
 <a href="#concept-shadow-root">shadow root</a>.</p></li>

 <li><p>If <var>shadow</var> is null, then return null.</p></li>

 <li><p>If the <i>open flag</i> is set and <var>shadow</var>'s <a for=ShadowRoot>mode</a> is
 <em>not</em> "<code>open</code>", then return null.</p></li>

 <li><p>Return the first <a>slot</a> in <var>shadow</var>'s <a>tree</a> whose <a for=slot>name</a>
 is <var>slotable</var>'s <a for=slotable>name</a>, if any, and null otherwise.</p></li>
</ol>

<p>To <dfn export lt="find slotables|finding slotables">find slotables</dfn> for a given <a>slot</a>
<var>slot</var>, run these steps:</p>

<ol>
 <li><p>Let <var>result</var> be an empty list.</p></li>

 <li><p>If <var>slot</var>'s <a for=tree>root</a> is not a <a href="#concept-shadow-root">shadow root</a>, then return
 <var>result</var>.</p></li>

 <li><p>Let <var>host</var> be <var>slot</var>'s <a for=tree>root</a>'s
 <a>host</a>.</p></li>

 <li>
  <p>For each <a>slotable</a> <a>child</a> of <var>host</var>, <var>slotable</var>, in
  <a>tree order</a>:</p>

  <ol>
   <li><p>Let <var>foundSlot</var> be the result of <a>finding a slot</a> given
   <var>slotable</var>.</p></li>

   <li><p>If <var>foundSlot</var> is <var>slot</var>, then append <var>slotable</var> to
   <var>result</var>.</p></li>
  </ol>
 </li>

 <li><p>Return <var>result</var>.</p></li>
</ol>

<p>To
<dfn export lt="find flattened slotables|finding flattened slotables">find flattened slotables</dfn>
for a given <a>slot</a> <var>slot</var>, run these steps:</p>

<ol>
 <li><p>Let <var>result</var> be an empty list.</p></li>

 <li><p>If <var>slot</var>'s <a for=tree>root</a> is not a <a href="#concept-shadow-root">shadow root</a>, then return
 <var>result</var>.</p></li>

 <li><p>Let <var>slotables</var> be the result of <a>finding slotables</a> given
 <var>slot</var>.</p></li>

 <li><p>If <var>slotables</var> is the empty list, then append each <a>slotable</a>
 <a>child</a> of <var>slot</var>, in <a>tree order</a>, to <var>slotables</var>.</p></li>

 <li>
  <p>For each <var>node</var> in <var>slotables</var>:

  <ol>
   <li>
    <p>If <var>node</var> is a <a>slot</a> whose <a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a>,
    then:

    <ol>
     <li><p>Let <var>temporaryResult</var> be the result of <a>finding flattened slotables</a> given
     <var>node</var>.</p></li>

     <li><p>Append each <a>slotable</a> in <var>temporaryResult</var>, in order, to
     <var>result</var>.</p></li>
    </ol>

   <li><p>Otherwise, append <var>node</var> to <var>result</var>.</p></li>
  </ol>
 </li>

 <li><p>Return <var>result</var>.</p></li>
</ol>

<h5 id=assigning-slotables-and-slots>Assigning slotables and slots</h5>

<p>To <dfn noexport>assign slotables</dfn> for a <a>slot</a> <var>slot</var>, run these steps:

<ol>
 <li><p>Let <var>slotables</var> be the result of <a>finding slotables</a> for <var>slot</var>.

 <li><p>If <var>slotables</var> and <var>slot</var>'s <a for=slot>assigned nodes</a> are not
 identical, then run <a>signal a slot change</a> for <var>slot</var>.

 <li><p>Set <var>slot</var>'s <a for=slot>assigned nodes</a> to <var>slotables</var>.

 <li><p>For each <var>slotable</var> in <var>slotables</var>, set <var>slotable</var>'s
 <a>assigned slot</a> to <var>slot</var>.
</ol>

<p>To <dfn noexport>assign slotables for a tree</dfn>, given a <a>tree</a>
<var>tree</var>, run <a>assign slotables</a> for each <a>slot</a> <var>slot</var> in
<var>tree</var>, in <a>tree order</a>.

<p>To <dfn noexport>assign a slot</dfn>, given a <a>slotable</a> <var>slotable</var>, run these
steps:

<ol>
 <li><p>Let <var>slot</var> be the result of <a>finding a slot</a> with <var>slotable</var>.

 <li><p>If <var>slot</var> is non-null, then run <a>assign slotables</a> for <var>slot</var>.
</ol>

<h5 id=signaling-slot-change>Signaling slot change</h5>

<p>Each <a>unit of related similar-origin browsing contexts</a> has a
<dfn export>signal slot list</dfn> (a list of <a>slots</a>). Unless stated otherwise it is empty.
[[!HTML]]

<p>To <dfn noexport>signal a slot change</dfn>, for a <a>slot</a> <var>slot</var>, run these steps:

<ol>
 <li><p>If <var>slot</var> is not in <a>unit of related similar-origin browsing contexts</a>'
 <a>signal slot list</a>, append <var>slot</var> to
 <a>unit of related similar-origin browsing contexts</a>' <a>signal slot list</a>.

 <li><p><a>Queue a mutation observer compound microtask</a>.
</ol>

<h4 id="mutation-algorithms">Mutation algorithms</h4>

<p>To <dfn>ensure pre-insertion validity</dfn> of a <var>node</var> into a <var>parent</var> before a <var>child</var>, run these steps:

<ol>
 <li><p>If <var>parent</var> is not a {{Document}}, {{DocumentFragment}}, or {{Element}} <a href="#concept-node">node</a>,
 <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li><p>If <var>node</var> is a <a>host-including inclusive ancestor</a> of <var>parent</var>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li><p>If <var>child</var> is not null and its <a>parent</a> is not <var>parent</var>, <a>throw</a> a <code><a>NotFoundError</a></code>.

 <li><p>If <var>node</var> is not a {{DocumentFragment}}, {{DocumentType}}, {{Element}}, {{Text}}, {{ProcessingInstruction}}, or {{Comment}} <a href="#concept-node">node</a>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li><p>If either <var>node</var> is a {{Text}} <a href="#concept-node">node</a> and <var>parent</var> is a <a href="#concept-document">document</a>, or <var>node</var> is a <a href="#concept-doctype">doctype</a> and <var>parent</var> is not a <a href="#concept-document">document</a>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li>
  <p>If <var>parent</var> is a <a href="#concept-document">document</a>, and any of the statements below, switched on <var>node</var>, are true, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

  <dl class="switch">
   <dt>{{DocumentFragment}} <a href="#concept-node">node</a>
   <dd>
    <p>If <var>node</var> has more than one {{element}} <a>child</a> or has a {{Text}} <a href="#concept-node">node</a> <a>child</a>.

    <p>Otherwise, if <var>node</var> has one {{element}} <a>child</a> and either <var>parent</var> has an {{element}} <a>child</a>, <var>child</var> is a <a href="#concept-doctype">doctype</a>, or <var>child</var> is not null and a <a href="#concept-doctype">doctype</a> is <a>following</a> <var>child</var>.

   <dt>{{element}} <dd><p><var>parent</var> has an {{element}} <a>child</a>, <var>child</var> is a <a href="#concept-doctype">doctype</a>, or <var>child</var> is not null and a <a href="#concept-doctype">doctype</a> is <a>following</a> <var>child</var>.

   <dt><a href="#concept-doctype">doctype</a> <dd><p><var>parent</var> has a <a href="#concept-doctype">doctype</a> <a>child</a>, <var>child</var> is non-null and an <a href="#concept-element">element</a> is <a>preceding</a> <var>child</var>, or <var>child</var> is null and <var>parent</var> has an {{element}} <a>child</a>.
  </dl>
</ol>

<p>To <dfn>pre-insert</dfn> a <var>node</var> into a <var>parent</var> before a <var>child</var>, run these steps:

<ol>
 <li><p><a>Ensure pre-insertion validity</a> of <var>node</var> into <var>parent</var> before <var>child</var>.

 <li><p>Let <var>reference child</var> be <var>child</var>.

 <li><p>If <var>reference child</var> is <var>node</var>, set it to <var>node</var>'s <a href="#concept-tree-next-sibling">next sibling</a>.

 <li><p><a>Adopt</a> <var>node</var> into <var>parent</var>'s <a>node document</a>.

 <li><p><a href="#node-insert">Insert</a> <var>node</var> into <var>parent</var> before <var>reference child</var>.

 <li><p>Return <var>node</var>.
</ol>

<p><a lt="Other applicable specifications">Specifications</a> may define <dfn>insertion steps</dfn> for all or some <a>nodes</a>. The algorithm is passed <var>newNode</var>, as indicated in the <a href="#node-insert">insert</a> algorithm below.

<p>To <dfn id="node-insert" for="node">insert</dfn> a <var>node</var> into a <var>parent</var> before a <var>child</var> with an optional <i>suppress observers flag</i>, run these steps:

<ol>
 <li><p>Let <var>count</var> be the number of <a>children</a> of <var>node</var> if it is a {{DocumentFragment}} <a href="#concept-node">node</a>, and one otherwise.

 <li>
  <p>If <var>child</var> is non-null, run these substeps:

  <ol>
   <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is <var>parent</var> and <a>start offset</a> is greater than <var>child</var>'s <a>index</a>, increase its <a>start offset</a> by <var>count</var>.

   <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>parent</var> and <a>end offset</a> is greater than <var>child</var>'s <a>index</a>, increase its <a>end offset</a> by <var>count</var>.
  </ol>

 <li><p>Let <var>nodes</var> be <var>node</var>'s <a>children</a> if <var>node</var> is a {{DocumentFragment}} <a href="#concept-node">node</a>, and a list containing solely <var>node</var> otherwise.

 <li><p>If <var>node</var> is a {{DocumentFragment}} <a href="#concept-node">node</a>, <a href="#node-remove">remove</a> its <a>children</a> with the <i>suppress observers flag</i> set.
 <li><p>If <var>node</var> is a {{DocumentFragment}} <a href="#concept-node">node</a>, <a>queue a mutation record</a> of "<code>childList</code>" for <var>node</var> with removedNodes <var>nodes</var>.

  <p class="note">Note: This step intentionally does not pay attention to the <i>suppress observers flag</i>.
 <li><p>Let <var>previousSibling</var> be <var>child</var>'s <a>previous sibling</a> or <var>parent</var>'s <a>last child</a> if <var>child</var> is null.
 <li>
  <p>For each <var>newNode</var> in <var>nodes</var>, in <a>tree order</a>, run these substeps:

  <ol>
   <li><p>Insert <var>newNode</var> into <var>parent</var> before <var>child</var> or at the end of <var>parent</var> if <var>child</var> is null.

   <li><p>Run the <a>insertion steps</a> with <var>newNode</var>.
   <li><p>If <var>parent</var> is a <a href="#concept-shadow-root">shadow host</a> and <var>node</var> is a
   <a>slotable</a>, then <a>assign a slot</a> for <var>node</var>.

   <li><p>If <var>parent</var>'s <a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a>, and
   <var>parent</var> is a <a>slot</a> whose <a for=slot>assigned nodes</a> is the empty list,
   then run <a>signal a slot change</a> for <var>parent</var>.
   <li><p>Run <a>assign slotables for a tree</a> with <var>node</var>'s <a>tree</a>.
   <li>
    <p>For each <a>shadow-including inclusive descendant</a> <var>inclusiveDescendant</var> of
    <var>node</var>, in <a>shadow-including tree order</a>:

    <ol>
     <li><p>Run the <a>insertion steps</a> with <var>inclusiveDescendant</var>.

     <li>
      <p>If <var>inclusiveDescendant</var> is <a>connected</a>, then:

      <ol>
       <li><p>If <var>inclusiveDescendant</var> is <a>custom</a>, then
       <a>enqueue a custom element callback reaction</a> with <var>inclusiveDescendant</var>,
       callback name "<code>connectedCallback</code>", and an empty argument list.

       <li>
        <p>Otherwise, <a lt="try to upgrade an element">try to upgrade</a>
        <var>inclusiveDescendant</var>.

        <p class=note>If this successfully upgrades <var>inclusiveDescendant</var>, its
        <code>connectedCallback</code> will be enqueued automatically during the
        <a>upgrade an element</a> algorithm.
      </ol>
     </li>
    </ol>
   </li>
  </ol>
 <li><p>If <i>suppress observers flag</i> is unset, <a>queue a mutation record</a> of "<code>childList</code>" for <var>parent</var> with addedNodes <var>nodes</var>, nextSibling <var>child</var>, and previousSibling <var>child</var>'s <a href="#concept-tree-previous-sibling">previous sibling</a> or <var>parent</var>'s <a>last child</a> if <var>child</var> is null.

</ol>


<p>To <dfn id="node-append" for="node">append</dfn> a <var>node</var> to a <var>parent</var>, <a>pre-insert</a> <var>node</var> into <var>parent</var> before null.

<p>To <dfn id="node-replace" for="node">replace</dfn> a <var>child</var> with <var>node</var> within a <var>parent</var>, run these steps:

<ol>
 <li><p>If <var>parent</var> is not a {{Document}}, {{DocumentFragment}}, or {{Element}} <a href="#concept-node">node</a>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li><p>If <var>node</var> is a <a>host-including inclusive ancestor</a> of <var>parent</var>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li><p>If <var>child</var>'s <a>parent</a> is not <var>parent</var>, <a>throw</a> a <code><a>NotFoundError</a></code>.

 <li><p>If <var>node</var> is not a {{DocumentFragment}}, {{DocumentType}}, {{Element}}, {{Text}}, {{ProcessingInstruction}}, or {{Comment}} <a href="#concept-node">node</a>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li><p>If either <var>node</var> is a {{Text}} <a href="#concept-node">node</a> and <var>parent</var> is a <a href="#concept-document">document</a>, or <var>node</var> is a <a href="#concept-doctype">doctype</a> and <var>parent</var> is not a <a href="#concept-document">document</a>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

 <li>
  <p>If <var>parent</var> is a <a href="#concept-document">document</a>, and any of the statements below, switched on <var>node</var>, are true, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.

  <dl class="switch">
   <dt>{{DocumentFragment}} <a href="#concept-node">node</a>
   <dd>
    <p>If <var>node</var> has more than one <a href="#concept-element">element</a> <a>child</a> or has a {{Text}} <a href="#concept-node">node</a> <a>child</a>.

    <p>Otherwise, if <var>node</var> has one <a href="#concept-element">element</a> <a>child</a> and either <var>parent</var> has an <a href="#concept-element">element</a> <a>child</a> that is not <var>child</var> or a <a href="#concept-doctype">doctype</a> is <a>following</a> <var>child</var>.

   <dt><a href="#concept-element">element</a> <dd><p><var>parent</var> has an <a href="#concept-element">element</a> <a>child</a> that is not <var>child</var> or a <a href="#concept-doctype">doctype</a> is <a>following</a> <var>child</var>.

   <dt><a href="#concept-doctype">doctype</a> <dd><var>parent</var> has a <a href="#concept-doctype">doctype</a> <a>child</a> that is not <var>child</var>, or an <a href="#concept-element">element</a> is <a>preceding</a> <var>child</var>.
  </dl>

  <p class="note">Note: The above statements differ from the <a>pre-insert</a> algorithm.

 <li><p>Let <var>reference child</var> be <var>child</var>'s <a href="#concept-tree-next-sibling">next sibling</a>.

 <li><p>If <var>reference child</var> is <var>node</var>, set it to <var>node</var>'s <a href="#concept-tree-next-sibling">next sibling</a>.

 <li><p>Let <var>previousSibling</var> be <var>child</var>'s <a>previous sibling</a>.

 <li><p><a>Adopt</a> <var>node</var> into <var>parent</var>'s <a>node document</a>.

 <li>Let <var>removedNodes</var> be the empty list.

 <li>
  <p>If <var>child</var>'s <a>parent</a> is not null, run these substeps:

  <ol>
   <li><p>Set <var>removedNodes</var> to a list solely containing <var>child</var>.

   <li><p><a href="#node-remove">Remove</a> <var>child</var> from its <var>parent</var> with the
   <i>suppress observers flag</i> set.
  </ol>

  <p class="note no-backref">Note: The above can only be false if <var>child</var> is <var>node</var>.

 <li>Let <var>nodes</var> be <var>node</var>'s <a>children</a> if <var>node</var> is a
 {{DocumentFragment}} <a href="#concept-node">node</a>, and a list containing solely <var>node</var> otherwise.

 <li><p><a href="#node-insert">Insert</a> <var>node</var> into <var>parent</var> before <var>reference child</var> with the <i>suppress observers flag</i> set.

 <li><p><a>Queue a mutation record</a> of "<code>childList</code>" for target <var>parent</var> with addedNodes <var>nodes</var>, removedNodes a list solely containing <var>child</var>, nextSibling <var>reference child</var>, and previousSibling <var>previousSibling</var>.

 <li><p>Return <var>child</var>.
</ol>


To <dfn export for=Node id=concept-node-replace-all>replace all</dfn> with a
<var>node</var> within a <var>parent</var>, run these steps:

<ol>
 <li><p>If <var>node</var> is not null, <a>adopt</a> <var>node</var> into <var>parent</var>'s <a>node document</a>.

 <li><p>Let <var>removedNodes</var> be <var>parent</var>'s <a>children</a>.

 <li><p>Let <var>addedNodes</var> be the empty list if <var>node</var> is null, <var>node</var>'s <a>children</a> if <var>node</var> is a {{DocumentFragment}} <a href="#concept-node">node</a>, and a list containing <var>node</var> otherwise.

 <li><p><a href="#node-remove">Remove</a> all <var>parent</var>'s <a>children</a>, in <a>tree order</a>, with the <i>suppress observers flag</i> set.

 <li><p>If <var>node</var> is not null, <a href="#node-insert">insert</a> <var>node</var> into <var>parent</var> before null with the <i>suppress observers flag</i> set.

 <li><p><a>Queue a mutation record</a> of "<code>childList</code>" for <var>parent</var> with addedNodes <var>addedNodes</var> and removedNodes <var>removedNodes</var>.
</ol>

<p class="note">Note: This algorithm does not make any checks with regards to the <a>node tree</a> constraints. Specification authors need to use it wisely.


<p>To <dfn>pre-remove</dfn> a <var>child</var> from a <var>parent</var>, run these steps:</p>

<ol>
 <li><p>If <var>child</var>'s <a>parent</a> is not <var>parent</var>, <a>throw</a> a <code><a>NotFoundError</a></code>.

 <li><p><a href="#node-remove">Remove</a> <var>child</var> from <var>parent</var>.

 <li><p>Return <var>child</var>.
</ol>


<p><a lt="Other applicable specifications">Specifications</a> may define
<dfn export id=concept-node-remove-ext>removing steps</dfn> for all or some <a>nodes</a>. The
algorithm is passed <var ignore>removedNode</var>, and optionally <var ignore>oldParent</var>, as
indicated in the <a href="#node-remove">remove</a> algorithm below.

<p>To <dfn id="node-remove" for="node">remove</dfn> a <var>node</var> from a <var>parent</var> with an optional <i>suppress observers flag</i> set, run these steps:

<ol>
 <li><p>Let <var>index</var> be <var>node</var>'s <a>index</a>.

 <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is an <a>inclusive descendant</a> of <var>node</var>, set its <a>start</a> to (<var>parent</var>, <var>index</var>).

 <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is an <a>inclusive descendant</a> of <var>node</var>, set its <a>end</a> to (<var>parent</var>, <var>index</var>).

 <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is <var>parent</var> and <a>start offset</a> is greater than <var>index</var>, decrease its <a>start offset</a> by one.

 <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>parent</var> and <a>end offset</a> is greater than <var>index</var>, decrease its <a>end offset</a> by one.

 <li><p>For each {{NodeIterator}} object <var>iterator</var> whose <a for=traversal>root</a>'s <a>node document</a> is <var>node</var>'s
 <a>node document</a>, run the <a><code>NodeIterator</code> pre-removing steps</a> given <var>node</var> and <var>iterator</var>.

 <li><p>Let <var>oldPreviousSibling</var> be <var>node</var>'s <a href="#concept-tree-previous-sibling">previous sibling</a>.
 <li><p>Let <var>oldNextSibling</var> be <var>node</var>'s <a href="#concept-tree-next-sibling">next sibling</a>.

 <li><p>Remove <var>node</var> from its <var>parent</var>.

 <li><p>If <var>node</var> is <a for=slotable>assigned</a>, then run <a>assign slotables</a> for
 <var>node</var>'s <a>assigned slot</a>.

 <li><p>If <var>parent</var>'s <a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a>, and
 <var>parent</var> is a <a>slot</a> whose <a for=slot>assigned nodes</a> is the empty list,
 then run <a>signal a slot change</a> for <var>parent</var>.

 <li><p>If <var>node</var> has an <a>inclusive descendant</a> that is a <a>slot</a>, then:

  <ol>
   <li><p>Run <a>assign slotables for a tree</a> with <var>parent</var>'s <a>tree</a>.

   <li><p>Run <a>assign slotables for a tree</a> with <var>node</var>'s <a>tree</a>.
  </ol>

 <li><p>Run the <a>removing steps</a> with <var>node</var> and <var>parent</var>.

 <li>
  <p>If <var>node</var> is <a>custom</a>, then <a>enqueue a custom element callback reaction</a> with <var>node</var>, callback name "<code>disconnectedCallback</code>", and an empty argument list.

  <p class=note>It is intentional for now that <a>custom</a> <a for=/>elements</a> do not get <var>parent</var> passed. This might change in the future if there is a need.

  <li>
   <p>For each <a>shadow-including descendant</a> <var>descendant</var> of <var>node</var>, in <a>shadow-including tree order</a>, run these substeps:

  <ol>
   <li><p>Run the <a>removing steps</a> with <var>descendant</var>.

   <li><p>If <var>descendant</var> is <a>custom</a>, then <a>enqueue a custom element callback reaction</a> with <var>descendant</var>, callback name ""<code>disconnectedCallback</code>", and an empty argument list.
  </ol>
 </li>

 <li><p>For each <a>inclusive ancestor</a> <var>inclusiveAncestor</var> of <var>node</var>, if <var>inclusiveAncestor</var> has any <a>registered observers</a> whose <b>options</b>' <code>subtree</code> is true, then for each such <a>registered observer</a> <var>registered</var>, append a <a>transient registered observer</a> whose <b>observer</b> and <b>options</b> are identical to those of <var>registered</var> and <b>source</b> which is <var>registered</var> to <var>node</var>'s list of <a>registered observers</a>.

 <li><p>If <i>suppress observers flag</i> is unset, <a>queue a mutation record</a> of "<code>childList</code>" for <var>parent</var> with removedNodes a list solely containing <var>node</var>, nextSibling <var>oldNextSibling</var>, and previousSibling <var>oldPreviousSibling</var>.

</ol>

<h4 id="interface-nonelementparentnode">Interface {{NonElementParentNode}}</h4>

<p class="note no-backref">Note: Web compatibility prevents the {{NonElementParentNode/getElementById()}}
method from being exposed on <a href="#concept-element">elements</a> (and therefore on {{ParentNode}}).

<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface NonElementParentNode {
  Element? getElementById(DOMString elementId);
};
Document implements NonElementParentNode;
DocumentFragment implements NonElementParentNode;
</pre>

<dl>
 <dt><var>node</var> . {{NonElementParentNode/getElementById(elementId)}}
 <dd><p>Returns the first <a href="#concept-element">element</a> within <var>node</var>'s <a>descendants</a> whose <a>ID</a> is <var>elementId</var>.
</dl>

<p>The <dfn method for=NonElementParentNode>getElementById(<var>elementId</var>)</dfn> method, when invoked, must return the first <a href="#concept-element">element</a>, in <a>tree order</a>, within <a>context object</a>'s <a>descendants</a>, whose <a>ID</a> is <var>elementId</var>, and null if there is no such <a href="#concept-element">element</a> otherwise.

<h4 id="interface-documentorshadowroot">Interface {{DocumentOrShadowRoot}}</h4>

<pre class=idl>
[NoInterfaceObject,
 Exposed=Window]
interface DocumentOrShadowRoot {
};
Document implements DocumentOrShadowRoot;
ShadowRoot implements DocumentOrShadowRoot;
</pre>

<p class="note no-backref">Note: The {{DocumentOrShadowRoot}} interface is expected to be used by other
standards that want to define APIs shared between <a href="#concept-document">document</a> and
<a for=/>shadow roots</a>.

<h4 id="interface-parentnode">Interface <code>{{ParentNode}}</code></h4>

<p>To <dfn export lt="converting nodes into a node">convert nodes into a node</dfn>, given <var>nodes</var> and <var>document</var>, run these steps:</p>

<ol>
 <li>Let <var>node</var> be null.

 <li>Replace each string in <var>nodes</var> with a new {{Text}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is the string and <a>node document</a> is <var>document</var>.

 <li>If <var>nodes</var> contains one <a href="#concept-node">node</a>, set <var>node</var> to that <a href="#concept-node">node</a>.

 <li>Otherwise, set <var>node</var> to a new {{DocumentFragment}} whose <a>node document</a> is <var>document</var>, and then <a href="#node-append">append</a> each <a href="#concept-node">node</a> in <var>nodes</var>, if any, to it.

 <li>Return <var>node</var>.
</ol>

<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface ParentNode {
  [SameObject] readonly attribute HTMLCollection children;
  readonly attribute Element? firstElementChild;
  readonly attribute Element? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [Unscopable] void prepend((Node or DOMString)... nodes);
  [Unscopable] void append((Node or DOMString)... nodes);

  Element? querySelector(DOMString selectors);
  [NewObject] NodeList querySelectorAll(DOMString selectors);
};
Document implements ParentNode;
DocumentFragment implements ParentNode;
Element implements ParentNode;
</pre>

<dl>
 <dt><code><var ignore>collection</var> = <var>node</var> . {{ParentNode/children}}</code>
 <dd><p>Returns the <a>child</a> <a href="#concept-element">elements</a>.

 <dt><code><var ignore>element</var> = <var>node</var> . {{ParentNode/firstElementChild}}</code>
 <dd><p>Returns the first <a>child</a> that is an <a href="#concept-element">element</a>, and null otherwise.

 <dt><code><var ignore>element</var> = <var>node</var> . {{ParentNode/lastElementChild}}</code>
 <dd><p>Returns the last <a>child</a> that is an <a href="#concept-element">element</a>, and null otherwise.

 <!-- childElementCount is redundant -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="prepend()">prepend</a>(<var>nodes</var>)</code>
 <dd>
  Inserts <var>nodes</var> before the  <a href="#concept-tree-first-child">first child</a> of <var>node</var>, while replacing strings in <var>nodes</var> with equivalent {{Text}} <a>nodes</a>.

  <a>Throws</a> a <code><a>HierarchyRequestError</a></code> if the constraints of the <a>node tree</a> are violated.
  <!-- "NotFoundError" is impossible -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="append()">append</a>(<var>nodes</var>)</code>
 <dd>
  Inserts <var>nodes</var> after the <a>last child</a> of <var>node</var>, while replacing strings in <var>nodes</var>
  with equivalent {{Text}} <a>nodes</a>.

  <a>Throws</a> a <a>HierarchyRequestError</a> if the constraints of the <a>node tree</a> are violated.
  <!-- "NotFoundError" is impossible -->

 <dt><code><var>node</var> . {{ParentNode/querySelector(selectors)}}</code>
 <dd><p>Returns the first <a href="#concept-element">element</a> that is a <a>descendant</a> of <var>node</var> that matches <var>selectors</var>.

 <dt><code><var>node</var> . {{ParentNode/querySelectorAll(selectors)}}</code>
 <dd><p>Returns all <a href="#concept-element">element</a> <a>descendants</a> of <var>node</var> that match <var>selectors</var>.
</dl>

<p>The <dfn attribute id="parentnode-children" for=ParentNode>children</dfn> attribute's getter must return an {{HTMLCollection}} <a>collection</a> rooted at the <a>context object</a> matching only <a href="#concept-element">element</a> <a>children</a>.

<p>The <dfn attribute for=ParentNode>firstElementChild</dfn> attribute's getter must return the first <a>child</a> that is an <a href="#concept-element">element</a>, and null otherwise.

<p>The <dfn attribute for=ParentNode>lastElementChild</dfn> attribute's getter must return the last <a>child</a> that is an <a href="#concept-element">element</a>, and null otherwise.

<p>The <dfn attribute for=ParentNode>childElementCount</dfn> attribute's getter must return the number of <a>children</a> of the <a>context object</a> that are <a>elements</a>.

<p>The <dfn method for=ParentNode>prepend(<var>nodes</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>node</var> be the result of <a>converting nodes into a node</a> given <var>nodes</var> and <a>context object</a>'s <a>node document</a>.

 <li><p><a>Pre-insert</a> <var>node</var> into <a>context object</a> before the <a>context object</a>'s <a href="#concept-tree-first-child">first child</a>.
</ol>

<p>The <dfn method for=ParentNode>append(<var>nodes</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>node</var> be the result of <a>converting nodes into a node</a> given <var>nodes</var> and <a>context object</a>'s <a>node document</a>.

 <li><p><a href="#node-append">Append</a> <var>node</var> to <a>context object</a>.
</ol>

<p>The <dfn method for=ParentNode>querySelector(<var>selectors</var>)</dfn> method, when invoked, must return the first result of running <a>scope-match a selectors string</a> <var>selectors</var> against the <a>context object</a>, and null if the result is an empty list otherwise.

<p>The <dfn method for=ParentNode>querySelectorAll(<var>selectors</var>)</dfn> method, when invoked, must return the <a>static</a> result of running <a>scope-match a selectors string</a> <var>selectors</var> against the <a>context object</a>.

<h4 id="interface-nondocumenttypechildnode">Interface {{NonDocumentTypeChildNode}}</h4>

<p class="note no-backref">Note: Web compatibility prevents the {{previousElementSibling}} and
{{nextElementSibling}} attributes from being exposed on <a href="#concept-doctype">doctypes</a> (and therefore on
{{ChildNode}}).

<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface NonDocumentTypeChildNode {
  readonly attribute Element? previousElementSibling;
  readonly attribute Element? nextElementSibling;
};
Element implements NonDocumentTypeChildNode;
CharacterData implements NonDocumentTypeChildNode;
</pre>

<dl>
<dt><var ignore>element</var> = <var>node</var> . {{NonDocumentTypeChildNode/previousElementSibling}}
 <dd><p>Returns the first <a>preceding</a> <a>sibling</a> that is an <a href="#concept-element">element</a>, and null otherwise.

 <dt><var ignore>element</var> = <var>node</var> . {{NonDocumentTypeChildNode/nextElementSibling}}
 <dd><p>Returns the first <a>following</a> <a>sibling</a> that is an <a href="#concept-element">element</a>, and null otherwise.
</dl>

<p>The <dfn>previousElementSibling</dfn> attribute's getter must return the first <a>preceding</a> <a>sibling</a> that is an <a href="#concept-element">element</a>, and null otherwise.

<p>The <dfn>nextElementSibling</dfn> attribute's getter must return the first <a>following</a> <a>sibling</a> that is an <a href="#concept-element">element</a>, and null otherwise.

<h4 id="interface-childnode">Interface {{ChildNode}}</h4>
<pre class='idl'>
[NoInterfaceObject,
 Exposed=Window]
interface ChildNode {
  [Unscopable] void before((Node or DOMString)... nodes);
  [Unscopable] void after((Node or DOMString)... nodes);
  [Unscopable] void replaceWith((Node or DOMString)... nodes);
  [Unscopable] void remove();
};
DocumentType implements ChildNode;
Element implements ChildNode;
CharacterData implements ChildNode;
</pre>

<dl>
 <dt><code><var>node</var> . <a method for=ChildNode lt="before()">before</a>(<var>nodes</var>)</code>
 <dd>
  Inserts <var>nodes</var> just before <var>node</var>, while replacing strings in <var>nodes</var> with equivalent {{Text}} <a>nodes</a>.

  <a>Throws</a> a <code><a>HierarchyRequestError</a></code> if the constraints of the <a>node tree</a> are violated.

 <dt><code><var>node</var> . <a method for=ChildNode lt="after()">after</a>(<var>nodes</var>)</code>
 <dd>
  Inserts <var>nodes</var> just after <var>node</var>, while replacing strings in <var>nodes</var> with equivalent {{Text}} <a>nodes</a>.

  <a>Throws</a> a <code><a>HierarchyRequestError</a></code> if the constraints of the <a>node tree</a> are violated.

 <dt><code><var>node</var> . <a method for=ChildNode lt="replaceWith()">replaceWith</a>(<var>nodes</var>)</code>
 <dd>
  Replaces <var>node</var> with <var>nodes</var>, while replacing strings in <var>nodes</var> with equivalent {{Text}} <a>nodes</a>.

  <a>Throws</a> a <code><a>HierarchyRequestError</a></code> if the constraints of the <a>node tree</a> are violated.

 <dt><var>node</var> . {{ChildNode/remove()}}
 <dd><p>Removes <var>node</var>.
</dl>

<p>The <dfn method for=ChildNode><code>before(nodes)</code></dfn> method, when invoked,
must run these steps:
<ol>
 <li><p>Let <var>parent</var> be <a>context object</a>'s <a>parent</a>.

 <li><p>If <var>parent</var> is null, then return.

 <li><p>Let <var>viablePreviousSibling</var> be <a>context object</a>'s first <a>preceding</a> <a href="#tree-sibling">sibling</a> not in <var>nodes</var>, and null otherwise.

 <li><p>Let <var>node</var> be the result of <a>converting nodes into a node</a>, given <var>nodes</var> and <a>context object</a>'s <a>node document</a>.

 <li><p>If <var>viablePreviousSibling</var> is null, set it to <var>parent</var>'s <a href="#concept-tree-first-child">first child</a>, and to <var>viablePreviousSibling</var>'s <a href="#concept-tree-next-sibling">next sibling</a> otherwise.

 <li><p><a>Pre-insert</a> <var>node</var> into <var>parent</var> before <var>viablePreviousSibling</var>.
</ol>

<p>The <dfn method for=ChildNode>after(<var>nodes</var>)</dfn> method, when invoked,  must run these steps:

<ol>
 <li><p>Let <var>parent</var> be <a>context object</a>'s <a>parent</a>.

 <li><p>If <var>parent</var> is null, then return.

 <li><p>Let <var>viableNextSibling</var> be <a>context object</a>'s first <a>following</a> <a href="#tree-sibling">sibling</a> not in <var>nodes</var>, and null otherwise.

 <li><p>Let <var>node</var> be the result of <a>converting nodes into a node</a>, given <var>nodes</var> and <a>context object</a>'s <a>node document</a>.

 <li><p><a>Pre-insert</a> <var>node</var> into <var>parent</var> before <var>viableNextSibling</var>.
</ol>

<p>The <dfn method for=ChildNode>replaceWith(<var>nodes</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>parent</var> be <a>context object</a>'s <a>parent</a>.

 <li><p>If <var>parent</var> is null, then return.

 <li><p>Let <var>viableNextSibling</var> be <a>context object</a>'s first <a>following</a> <a href="#tree-sibling">sibling</a> not in <var>nodes</var>, and null otherwise.

 <li><p>Let <var>node</var> be the result of <a>converting nodes into a node</a>, given <var>nodes</var> and <a>context object</a>'s <a>node document</a>.

 <li>
  <p>If <a>context object</a>'s <a>parent</a> is <var>parent</var>, <a href="#node-replace">replace</a> the
  <a>context object</a> with <var>node</var> within <var>parent</var>.

  <p class=note><a>Context object</a> could have been inserted into <var>node</var>.

 <li><p>Otherwise, <a>pre-insert</a> <var>node</var> into <var>parent</var> before <var>viableNextSibling</var>.
</ol>

<p>The <dfn method id="node-remove-func" for=ChildNode>remove()</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If the <a>context object</a> does not have a <a>parent</a>, terminate these steps.

 <li><p><a href="#node-remove">Remove</a> the <a>context object</a> from the <a>context object</a>'s <a>parent</a>.
</ol>

<h4 id="interface-slotable">Interface {{Slotable}}</h4>

<pre class=idl>
[NoInterfaceObject,
 Exposed=Window]
interface Slotable {
  readonly attribute HTMLSlotElement? assignedSlot;
};
Element implements Slotable;
Text implements Slotable;
</pre>

<p>The <dfn attribute for=Slotable><code>assignedSlot</code></dfn> attribute's getter must return
the result of <a>find a slot</a> given <a>context object</a> and with the <i>open flag</i> set.</p>


<h4 id="old-style-collections:-nodelist-and-htmlcollection">Old-style collections: <code>{{NodeList}}</code> and <code>{{HTMLCollection}}</code></h4>

<p>A <dfn>collection</dfn> is an object that represents a lists of DOM nodes. A <a>collection</a> can be either <dfn>live</dfn> or <dfn>static</dfn>. Unless otherwise stated, a <a>collection</a> must be <a>live</a>.

<p>If a <a>collection</a> is <a>live</a>, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.

<p>When a <a>collection</a> is created, a filter and a root are associated with it.

<p>The <a>collection</a> then <dfn for=collection lt="represented by the collection" id=represented-by-the-collection>represents</dfn> a view of the subtree rooted at the <a>collection's</a> root, containing only nodes that match the given filter. The view is linear. In the absence of specific requirements to the contrary, the nodes within the <a>collection</a> must be sorted in <a>tree order</a>.

<h5 id="interface-nodelist">Interface {{NodeList}}</h5>

<p>A {{NodeList}} object is a <a>collection</a> of <a>nodes</a>.

<pre class='idl'>
[Exposed=Window]
interface NodeList {
  getter Node? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable&lt;Node>;
};
</pre>

<dl>
 <dt><var>collection</var> . {{NodeList/length}}
 <dd><p>Returns the number of <a>nodes</a> in the <a>collection</a>.

 <dt><var ignore>element</var> = <var>collection</var> . {{NodeList/item(index)}}
 <dt><var ignore>element</var> = <var>collection</var>[<var>index</var>]
 <dd><p>Returns the <a href="#concept-node">node</a> with index <var>index</var> from the <a>collection</a>. The <a>nodes</a> are sorted in <a>tree order</a>.
</dl>

<div>

<p>The object's <a class="external" data-anolis-spec="webidl">supported property indices</a> are the numbers in the range zero to one less than the number of nodes <a>represented by the collection</a>. If there are no such elements, then there are no <a>supported property indices</a>.

<p>The <dfn attribute id="nodelist-length" for=NodeList>length</dfn> attribute's getter must return the number of nodes <a>represented by the collection</a>.


The <dfn method for=NodeList><code>item(<var>index</var>)</code></dfn> method must return the <var>index</var><sup>th</sup> node in the <a>collection</a>. If there is no <var>index</var><sup>th</sup> node in the <a>collection</a>, then the method must return null.

</div>

<h5 id="interface-htmlcollection">Interface {{HTMLCollection}}</h5>

<pre class='idl'>
[Exposed=Window]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter Element? item(unsigned long index);
  getter Element? namedItem(DOMString name);
};
</pre>

<p>An {{HTMLCollection}} object is a <a>collection</a> of <a href="#concept-element">elements</a>.

<p class="note">Note: {{HTMLCollection}} is an historical artifact we cannot rid the web of.
 While developers are of course welcome to keep using it, new API standard designers ought not to use
 it (use <code>sequence&lt;T></code> in IDL instead).

<dl>
 <dt><var>collection</var> . {{HTMLCollection/length}}
 <dd><p>Returns the number of <a href="#concept-element">elements</a> in the <a>collection</a>.

 <dt><var ignore>element</var> = <var>collection</var> . {{HTMLCollection/item(index)}}
 <dt><var ignore>element</var> = <var>collection</var>[<var>index</var>]
 <dd><p>Returns the <a href="#concept-element">element</a> with index <var>index</var> from the <a>collection</a>. The <a>elements</a> are sorted in <a>tree order</a>.

 <dt><var ignore>element</var> = <var>collection</var> . {{HTMLCollection/namedItem(name)}}
 <dt><var ignore>element</var> = <var>collection</var>[<var>name</var>]
 <dd><p>Returns the first <a href="#concept-element">element</a> with <a>ID</a> or name <var>name</var>from the collection.
</dl>

<div>

<p>The object's <a>supported property indices</a> are the numbers in the range zero to one less than the number of elements <a>represented by the collection</a>. If there are no such elements, then there are no <a>supported property indices</a>.

<p>The <dfn attribute id="htmlcollection-length" for=HTMLCollection>length</dfn> attribute's getter must return the number of nodes <a>represented by the collection</a>.

<p>The <dfn method id="htmlcollection-item-func" for=HTMLCollection>item(<var>index</var>)</dfn> method, when invoked, must return the <var>index</var>th <a href="#concept-element">element</a> in the <a>collection</a>. If there is no <var>index</var>th <a href="#concept-element">element</a> in the <a>collection</a>, then the method, when invoked, must return null.

<p>The <a>supported property names</a> are the values from the list returned by these steps:

<ol>
 <li><p>Let <var>result</var> be an empty list.
 <li>
  <p>For each <var>element</var> <a>represented by the collection</a>, in <a>tree order</a>, run these substeps:
  <ol>
   <li><p>If <var>element</var> has an <a>ID</a> which is not in <var>result</var>, append
   <var>element</var>'s <a>ID</a> to <var>result</var>.

   <li><p>If <var>element</var> is in the <a>HTML namespace</a> and <a>has</a> a <a href="#named-attribute"><code>name</code> attribute</a> whose <a href="#concept-attribute-value">value</a> is neither the empty string nor is in <var>result</var>, append <var>element</var>'s <a href="#named-attribute"><code>name</code> attribute</a> <a href="#concept-attribute-value">value</a> to <var>result</var>.
  </ol>
 <li><p>Return <var>result</var>.
</ol>

<p>The <dfn method for=HTMLCollection>namedItem(<var>key</var>)</dfn> method, when invoked, must run these steps:
<ol>
 <li>If <var>key</var> is the empty string, return null.</li>
 <li>
  <p>Return the first <a href="#concept-element">element</a> in the <a>collection</a> for which at least one of the following is true:
  <ul>
   <li>it has an <a>ID</a> which is <var>key</var>;
   <li>it is in the <a>HTML namespace</a> and <a>has</a> a
   <a href="#named-attribute"><code>name</code> attribute</a> whose <a href="#concept-attribute-value">value</a> is <var>key</var>;
  </ul>
  <p>or null if there is no such <a href="#concept-element">element</a>.
</ol>

</div>

<h3 id=mutation-observers>Mutation observers</h3>
<p>Each <a>unit of related similar-origin browsing contexts</a> has a <dfn>mutation observer compound microtask queued flag</dfn>, which is initially unset,
and an associated list of {{MutationObserver}} objects, which is initially empty.

<p>To <dfn>queue a mutation observer compound microtask</dfn>, run these steps:

<ol>
 <li><p>If <a>mutation observer compound microtask queued flag</a> is set, terminate these steps.

 <li><p>Set <a>mutation observer compound microtask queued flag</a>.

 <li><p><a>Queue</a> a <a>compound microtask</a> to <a>notify mutation observers</a>.
</ol>

<p>To <dfn>notify mutation observers</dfn>, run these steps:

<ol>
 <li><p>Unset <a>mutation observer compound microtask queued flag</a>.

 <li><p>Let <var>notify list</var> be a copy of <a>unit of related similar-origin browsing contexts</a>' list of <code>{{MutationObserver}}</code> objects.
 <li><p>Let <var>signalList</var> be a copy of
 <a>unit of related similar-origin browsing contexts</a>' <a>signal slot list</a>.

 <li><p>Empty <a>unit of related similar-origin browsing contexts</a>' <a>signal slot list</a>.
 <li>
  <p>For each {{MutationObserver}} object <var>mo</var> in <var>notify list</var>, <a>execute a compound microtask subtask</a> to run these steps:

  <ol>
   <li><p>Let <var>queue</var> be a copy of <var>mo</var>'s <a>record queue</a>.

   <li><p>Empty <var>mo</var>'s <a>record queue</a>.

   <li><p>Remove all <a>transient registered observers</a> whose <b>observer</b> is <var>mo</var>.

   <li><p>If <var>queue</var> is non-empty, call <var>mo</var>'s <a href="#concept-mo-callback">callback</a> with <var>queue</var> as first argument, and <var>mo</var> (itself) as second argument and <a>callback this value</a>. If this throws an exception, <a>report the exception</a>.
  </ol>
 <li><p>For each <a>slot</a> <var>slot</var> in <var>signalList</var>, in order,
 <a>fire an event</a> named <code>slotchange</code>, with its {{Event/bubbles}} attribute set to
 true, at <var>slot</var>.
</ol>

<hr>

<p>Each <a href="#concept-node">node</a> has an associated list of <a>registered observers</a>.

<p>A <dfn>registered observer</dfn> consists of an <b>observer</b> (a {{MutationObserver}} object) and <b>options</b> (a {{MutationObserverInit}} dictionary). A <dfn>transient registered observer</dfn> is a specific type of <a>registered observer</a> that has a <b>source</b> which is a <a>registered observer</a>.

<p class="note no-backref">Note: <a>Transient registered observers</a> are used to track
mutations within a given <a href="#concept-node">node</a>'s <a>descendants</a> after <a href="#concept-node">node</a> has been
removed so they do not get lost when <code>subtree</code> is set to true on <a href="#concept-node">node</a>'s
<a>parent</a>.

<h4 id="interface-mutationobserver">Interface {{MutationObserver}}</h4>

<pre class='idl'>
[Constructor(MutationCallback callback),
 Exposed=Window]
interface MutationObserver {
  void observe(Node target, optional MutationObserverInit options);
  void disconnect();
  sequence&lt;MutationRecord> takeRecords();
};

callback MutationCallback = void (sequence&lt;MutationRecord> mutations, MutationObserver observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};
</pre>

<p>A {{MutationObserver}} object can be used to observe mutations to the <a>tree</a> of <a>nodes</a>.

<p>Each {{MutationObserver}} object has these associated concepts:
<ul>
 <li><p>A <dfn id="concept-mo-callback">callback</dfn> set on creation.
 <li><p>A list of <a>nodes</a> on which it is a <a>registered observer</a>'s <b>observer</b> that is initially empty.
 <li><p>A list of {{MutationRecord}} objects called the <dfn>record queue</dfn> that is initially empty.
</ul>

<dl>
 <dt><var ignore>observer</var> = new {{MutationObserver(callback)}}
 <dd><p>Constructs a {{MutationObserver}} object and sets its <a href="#concept-mo-callback">callback</a> to <var>callback</var>. The <var>callback</var> is invoked with a list of {{MutationRecord}} objects as first argument and the constructed {{MutationObserver}} object as second argument. It is invoked after <a>nodes</a> registered with the <code><a>observe()</a></code> method, are mutated.

 <dt><code><var>observer</var> . {{MutationObserver/observe(target, options)}}</code>
 <dd><p>Instructs the user agent to observe a given <var>target</var> (a <a href="#concept-node">node</a>) and report any mutations based on the criteria given by <var>options</var> (an object).

  <p>The <var>options</var> argument allows for setting mutation observation options via object members. These are the object members that can be used:

  <dl>
   <dt>{{MutationObserverInit/childList}}
   <dd><p>Set to true if mutations to <var>target</var>'s <a>children</a> are to be observed.

   <dt>{{MutationObserverInit/attributes}}
   <dd><p>Set to true if mutations to <var>target</var>'s <a href="#concept-attribute">attributes</a> are to be observed. Can be omitted if {{MutationObserverInit/attributeOldValue}} and/or {{MutationObserverInit/attributeFilter}} is specified.

   <dt>{{MutationObserverInit/characterData}}
   <dd><p>Set to true if mutations to <var>target</var>'s <a href="#concept-cd-data">data</a> are to be observed. Can be omitted if {{MutationObserverInit/characterDataOldValue}} is specified.

   <dt>{{MutationObserverInit/subtree}}
   <dd><p>Set to true if mutations to not just <var>target</var>, but also <var>target</var>'s <a>descendants</a> are to be observed.

   <dt>{{MutationObserverInit/attributeOldValue}}
   <dd><p>Set to true if {{MutationObserverInit/attributes}} is true or omitted and <var>target</var>'s <a href="#concept-attribute">attribute</a> <a href="#concept-attribute-value">value</a> before the mutation needs to be recorded.

   <dt>{{MutationObserverInit/characterDataOldValue}}
   <dd><p>Set to true if {{MutationObserverInit/characterData}} is set to true or omitted and <var>target</var>'s <a href="#concept-cd-data">data</a> before the mutation needs to be recorded.

   <dt>{{MutationObserverInit/attributeFilter}}
   <dd><p>Set to a list of <a href="#concept-attribute">attribute</a> <a href="#concept-attribute-local-name">local names</a> (without <a href="#concept-attribute-namespace">namespace</a>) if not all <a href="#concept-attribute">attribute</a> mutations need to be observed and {{MutationObserverInit/attributes}} is true or omitted.
  </dl>

 <dt><var>observer</var> . {{MutationObserver/disconnect()}}
 <dd><p>Stops <var>observer</var> from observing any mutations. Until the <code><a>observe()</a></code> method is used again, <var>observer</var>'s <a href="#concept-mo-callback">callback</a> will not be invoked.

 <dt><var>observer</var> . {{MutationObserver/takeRecords()}}
 <dd><p>Empties the <a>record queue</a> and returns what was in there.
</dl>

<p>The <dfn constructor for=MutationObserver>MutationObserver(<var>callback</var>)</dfn> constructor must create a new {{MutationObserver}} object with <a href="#concept-mo-callback">callback</a> set to <var>callback</var>, append it to the <a>unit of related similar-origin browsing contexts</a>' list of {{MutationObserver}} objects, and then return it.

<p>The <dfn method for=MutationObserver>observe(<var>target</var>, <var>options</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If either <var>options</var>' {{MutationObserverInit/attributeOldValue}} or {{MutationObserverInit/attributeFilter}} is present and <var>options</var>' {{MutationObserverInit/attributes}} is omitted, set <var>options</var>' {{MutationObserverInit/attributes}} to true.

 <li><p>If <var>options</var>' {{MutationObserverInit/characterDataOldValue}} is present and <var>options</var>' {{MutationObserverInit/characterData}} is omitted, set <var>options</var>' {{MutationObserverInit/characterData}} to true.

 <li><p>If none of <var>options</var>' {{MutationObserverInit/childList}}, {{MutationObserverInit/attributes}}, and {{MutationObserverInit/characterData}} is true, <a>throw</a> a <code><a>TypeError</a></code>.

 <li><p>If <var>options</var>' {{MutationObserverInit/attributeOldValue}} is true and <var>options</var>' {{MutationObserverInit/attributes}} is false, <a>throw</a> a JavaScript <code><a>TypeError</a></code>.

 <li><p>If <var>options</var>' {{MutationObserverInit/attributeFilter}} is present and <var>options</var>' {{MutationObserverInit/attributes}} is false, <a>throw</a> a JavaScript <code><a>TypeError</a></code>.

 <li><p>If <var>options</var>' {{MutationObserverInit/characterDataOldValue}} is true and <var>options</var>' {{MutationObserverInit/characterData}} is false, <a>throw</a> a JavaScript <code><a>TypeError</a></code>.

 <li>
  <p>For each <a>registered observer</a> <var>registered</var> in <var>target</var>'s list of <a>registered observers</a> whose <b>observer</b> is the <a>context object</a>:

  <ol>
   <li><p>Remove all <a>transient registered observers</a> whose <b>source</b> is <var>registered</var>.

   <li><p>Replace <var>registered</var>'s <b>options</b> with <var>options</var>.
  </ol>

 <li><p>Otherwise, add a new <a>registered observer</a> to <var>target</var>'s list of <a>registered observers</a> with the <a>context object</a> as the <b>observer</b> and <var>options</var> as the <b>options</b>, and add <var>target</var> to <a>context object</a>'s list of <a>nodes</a> on which it is registered.
</ol>

<p>The <dfn method for=MutationObserver>disconnect()</dfn> method, when invoked, must, for each <a href="#concept-node">node</a> <var>node</var> in the <a>context object</a>'s list of <a>nodes</a>, remove any <a>registered observer</a> on <var>node</var> for which the <a>context object</a> is the <b>observer</b>, and also empty <a>context object</a>'s <a>record queue</a>.

<p>The <dfn method for=MutationObserver>takeRecords()</dfn> method, when invoked, must return a copy of the <a>record queue</a> and then empty the <a>record queue</a>.

<h4 id="queuing-a-mutation-record">Queuing a mutation record</h4>
<p>To <dfn>queue a mutation record</dfn> of <var>type</var> for <var>target</var> with one or more of (depends on <var>type</var>) name <var>name</var>, namespace <var>namespace</var>, oldValue <var>oldValue</var>, addedNodes <var>addedNodes</var>, removedNodes <var>removedNodes</var>, previousSibling <var>previousSibling</var>, and nextSibling <var>nextSibling</var>, run these steps:

<ol>
 <li><p>Let <var>interested observers</var> be an initially empty set of {{MutationObserver}} objects optionally paired with a string.

 <li><p>Let <var>nodes</var> be the <a>inclusive ancestors</a> of <var>target</var>.

 <li>
  <p>Then, for each <var>node</var> in <var>nodes</var>, and then for each <var>registered observer</var> (with <var>registered observer</var>'s <b>options</b> as <var>options</var>) in <var>node</var>'s list of <a>registered observers</a>, run these substeps:

  <ol>
   <li>
    <p>If none of the following are true

    <ul class=brief>
     <li><var>node</var> is not <var>target</var> and <var>options</var>' <code>subtree</code> is false

     <li><var>type</var> is "<code>attributes</code>" and <var>options</var>' <code>attributes</code> is false

     <li><var>type</var> is "<code>attributes</code>", <var>options</var>'
     <code>attributeFilter</code> is present, and <var>options</var>' <code>attributeFilter</code>
     does not contain <var>name</var> or <var>namespace</var> is non-null

     <li><var>type</var> is "<code>characterData</code>" and <var>options</var>' <code>characterData</code> is false

     <li><var>type</var> is "<code>childList</code>" and <var>options</var>' <code>childList</code> is false
    </ul>

    <p>then run these subsubsteps:
    <ol>
     <li><p>If <var>registered observer</var>'s <b>observer</b> is not in <var>interested observers</var>, append <var>registered observer</var>'s <b>observer</b> to <var>interested observers</var>.

     <li><p>If either <var>type</var> is "<code>attributes</code>" and <var>options</var>' <code>attributeOldValue</code> is true, or <var>type</var> is "<code>characterData</code>" and <var>options</var>' <code>characterDataOldValue</code> is true, set the paired string of <var>registered observer</var>'s <b>observer</b> in <var>interested observers</var> to <var>oldValue</var>.
    </ol>
  </ol>

 <li>
  <p>Then, for each <var>observer</var> in <var>interested observers</var>:

  <ol>
   <li><p>Let <var>record</var> be a new {{MutationRecord}} object with its <code><a href="#mutationrecord-type">type</a></code> set to <var>type</var> and <code><a href="#mutationrecord-target">target</a></code> set to <var>target</var>.

   <li><p>If <var>name</var> and <var>namespace</var> are given, set <var>record</var>'s {{MutationRecord/attributeName}} to <var>name</var>, and <var>record</var>'s {{MutationRecord/attributeNamespace}} to <var>namespace</var>.

   <li><p>If <var>addedNodes</var> is given, set <var>record</var>'s {{MutationRecord/addedNodes}} to <var>addedNodes</var>.

   <li><p>If <var>removedNodes</var> is given, set <var>record</var>'s {{MutationRecord/removedNodes}} to <var>removedNodes</var>,

   <li><p>If <var>previousSibling</var> is given, set <var>record</var>'s {{MutationRecord/previousSibling}} to <var>previousSibling</var>.

   <li><p>If <var>nextSibling</var> is given, set <var>record</var>'s {{MutationRecord/nextSibling}} to <var>nextSibling</var>.

   <li><p>If <var>observer</var> has a paired string, set <var>record</var>'s {{MutationRecord/oldValue}} to <var>observer</var>'s paired string.

   <li><p>Append <var>record</var> to <var>observer</var>'s <a>record queue</a>.
  </ol>

 <li><p><a>Queue a mutation observer compound microtask</a>.
</ol>

<h4 id="interface-mutationrecord">Interface {{MutationRecord}}</h4>

<pre class='idl'>
[Exposed=Window]
interface MutationRecord {
  readonly attribute DOMString type;
  [SameObject] readonly attribute Node target;
  [SameObject] readonly attribute NodeList addedNodes;
  [SameObject] readonly attribute NodeList removedNodes;

  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;

  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};
</pre>

<dl>
 <dt><var>record</var> . {{MutationRecord/type}}
 <dd><p>Returns "<code>attributes</code>" if it was an <a href="#concept-attribute">attribute</a> mutation. "<code>characterData</code>" if it was a mutation to a {{CharacterData}} <a href="#concept-node">node</a>. And "<code>childList</code>" if it was a mutation to the <a>tree</a> of <a>nodes</a>.

 <dt><var>record</var> . {{MutationRecord/target}}
 <dd><p>Returns the <a href="#concept-node">node</a> the mutation affected, depending on the <code><a href="#mutationrecord-type">type</a></code>. For "<code>attributes</code>", it is the <a href="#concept-element">element</a> whose <a href="#concept-attribute">attribute</a> changed. For "<code>characterData</code>", it is the {{CharacterData}} <a href="#concept-node">node</a>. For "<code>childList</code>", it is the  <a href="#concept-node">node</a> whose <a>children</a> changed.

 <dt><var>record</var> . {{MutationRecord/addedNodes}}
 <dt><var>record</var> . {{MutationRecord/removedNodes}}
 <dd><p>Return the <a>nodes</a> added and removed respectively.

 <dt><var>record</var> . {{MutationRecord/previousSibling}}
 <dt><var>record</var> . {{MutationRecord/nextSibling}}
 <dd><p>Return the <a href="#concept-tree-previous-sibling">previous</a> and <a href="#concept-tree-next-sibling">next sibling</a> respectively of the added or removed <a>nodes</a>, and null otherwise.

 <dt><var>record</var> . {{MutationRecord/attributeName}}
 <dd><p>Returns the <a href="#concept-attribute-local-name">local name</a> of the changed <a href="#concept-attribute">attribute</a>, and null otherwise.

 <dt><var>record</var> . {{MutationRecord/attributeNamespace}}
 <dd><p>Returns the <a href="#concept-attribute-namespace">namespace</a> of the changed <a href="#concept-attribute">attribute</a>, and null otherwise.

 <dt><var>record</var> . {{MutationRecord/oldValue}}
 <dd><p>The return value depends on <code><a href="#mutationrecord-type">type</a></code>. For "<code>attributes</code>", it is the <a href="#concept-attribute-value">value</a> of the changed <a href="#concept-attribute">attribute</a> before the change. For "<code>characterData</code>", it is the <a href="#concept-cd-data">data</a> of the changed <a href="#concept-node">node</a> before the change. For "<code>childList</code>", it is null.
</dl>

<p>The <dfn attribute id="mutationrecord-type" for=MutationRecord><code>type</code></dfn> attribute's getter and <dfn attribute id="mutationrecord-target" for=MutationRecord>target</dfn> attribute's getter must return the values they were initialized to.

<p>The <dfn attribute for=MutationRecord>addedNodes</dfn> attribute's getter and <dfn attribute for=MutationRecord>removedNodes</dfn> attribute's getter must return the values they were initialized to. Unless stated otherwise, when a {{MutationRecord}} object is created, they must both be initialized to an empty {{NodeList}}.

<p>The <dfn attribute id="mutationrecord-previoussibling" for=MutationRecord>previousSibling</dfn> attribute's getter, <dfn attribute id="mutationrecord-nextsibling" for=MutationRecord>nextSibling</dfn> attribute's getter, <dfn attribute for=MutationRecord>attributeName</dfn> attribute's gettr, <dfn attribute for=MutationRecord>attributeNamespace</dfn> attribute's getter, and <dfn attribute for=MutationRecord>oldValue</dfn> attribute's getter must return the values they were initialized to. Unless stated otherwise, when a {{MutationRecord}} object is created, they must be initialized to null.

<h4 id="garbage-collection">Garbage collection</h4>

<p><a>Nodes</a> have a strong reference to <a>registered observers</a> in their list of <a>registered observers</a>.

<p><a>Registered observers</a> in a <a href="#concept-node">node</a>'s list of <a>registered observers</a> have a weak reference to the <a href="#concept-node">node</a>.

<h3 id=interface-node>Interface {{Node}}</h3>

<pre class='idl'>
[Exposed=Window]
interface Node : EventTarget {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2;
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4;
  const unsigned short ENTITY_REFERENCE_NODE = 5; // historical
  const unsigned short ENTITY_NODE = 6; // historical
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; // historical
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute USVString baseURI;

  readonly attribute Document? ownerDocument;
  readonly attribute Node? parentNode;
  readonly attribute Element? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute NodeList childNodes;
  readonly attribute Node? firstChild;
  readonly attribute Node? lastChild;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;

  attribute DOMString? nodeValue;
  attribute DOMString? textContent;
  void normalize();

  [NewObject] Node cloneNode(optional boolean deep = false);
  boolean isEqualNode(Node? other);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(Node other);
  boolean contains(Node? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  Node insertBefore(Node node, Node? child);
  Node appendChild(Node node);
  Node replaceChild(Node node, Node child);
  Node removeChild(Node child);
};
</pre>

<p class="note">Note: {{Node}} is an abstract interface and does not exist as <a href="#concept-node">node</a>. It is used by all <a>nodes</a> ({{Document}}, {{DocumentFragment}}, {{DocumentType}}, {{Element}}, {{Text}}, {{ProcessingInstruction}}, and {{Comment}}).

Each <a>node</a> has an associated <dfn export for=Node id=concept-node-document>node document</dfn>, set upon creation, that is a <a>document</a>.

<p class="note">Note: A <a href="#concept-node">node</a>'s <a>node document</a> can be changed by the <a>adopt</a> algorithm.

<p>A <a>node</a>'s <a>get the parent</a> algorithm, given an <var>event</var>, returns the <a>node</a>'s <a>assigned slot</a>, if <a>node</a> is <a>assigned</a>, and <a>node</a>'s <a>parent</a> otherwise.

<hr>

<dl>
 <dt><var>node</var> . {{Node/nodeType}}
 <dd><p>Returns the type of <var>node</var>, represented by a number from the following list:</p>

  <dl>
   <dt>{{Node}} . {{Node/ELEMENT_NODE}} (1)
   <dd><var>node</var> is an <a href="#concept-element">element</a>.

   <dt>{{Node}} . {{Node/ATTRIBUTE_NODE}} (2)
   <dd><var>node</var> is an <a href="#concept-attribute">attribute</a>.

   <dt>{{Node}} . {{Node/TEXT_NODE}} (3)
   <dd><var>node</var> is a {{Text}} <a href="#concept-node">node</a>.

   <dt>{{Node}} . {{Node/CDATA_SECTION_NODE}} (4)
   <dd><var>node</var> is a {{CDATASection}} <a href="#concept-node">node</a>.

   <dt>{{Node}} . {{Node/PROCESSING_INSTRUCTION_NODE}} (7)
   <dd><var>node</var> is a {{ProcessingInstruction}} <a href="#concept-node">node</a>.

   <dt>{{Node}} . {{Node/COMMENT_NODE}} (8)
   <dd><var>node</var> is a {{Comment}} <a href="#concept-node">node</a>.

   <dt>{{Node}} . {{Node/DOCUMENT_NODE}} (9)
   <dd><var>node</var> is a <a href="#concept-document">document</a>.

   <dt>{{Node}} . {{Node/DOCUMENT_TYPE_NODE}} (10)
   <dd><var>node</var> is a <a href="#concept-doctype">doctype</a>.

   <dt>{{Node}} . {{Node/DOCUMENT_FRAGMENT_NODE}} (11)
   <dd><var>node</var> is a {{DocumentFragment}} <a href="#concept-node">node</a>.
  </dl>

 <dt><var>node</var> . {{Node/nodeName}}
 <dd>
  <p>Returns a string appropriate for the type of <var>node</var>, as
  follows:

  <dl>
   <dt>{{Element}}
   <dd>Its {{Element/tagName}} attribute value.

   <dt>{{Attr}}
   <dd>Its <code><a href="#attribute-qualified-name">qualified name</a></code>.

   <dt>{{Text}}
   <dd>"<code>#text</code>".

   <dt>{{CDATASection}}
   <dd>"<code>#cdata-section</code>".

   <dt>{{ProcessingInstruction}}
   <dd>Its <a href="#concept-pi-target">target</a>.

   <dt>{{Comment}}
   <dd>"<code>#comment</code>".

   <dt>{{Document}}
   <dd>"<code>#document</code>".

   <dt>{{DocumentType}}
   <dd>Its <a href="#doctype-name">name</a>.

   <dt>{{DocumentFragment}}
   <dd>"<code>#document-fragment</code>".
  </dl>
</dl>

<p>The <dfn attribute for=Node>nodeType</dfn> attribute's getter, when invoked, must return the first matching statement, switching on the <a>context object</a>:

<dl class="switch">
 <dt>{{Element}}
 <dd><dfn>ELEMENT_NODE</dfn> (1);

 <dt>{{Attr}}
 <dd><dfn>ATTRIBUTE_NODE</dfn> (2);

 <dt>{{Text}}
 <dd><dfn>TEXT_NODE</dfn> (3);

 <dt>{{CDATASection}}
 <dd><dfn>CDATA_SECTION_NODE</dfn> (4);

 <dt>{{ProcessingInstruction}}
 <dd><dfn>PROCESSING_INSTRUCTION_NODE</dfn> (7);

 <dt>{{Comment}}
 <dd><dfn>COMMENT_NODE</dfn> (8);

 <dt>{{Document}}
 <dd><dfn>DOCUMENT_NODE</dfn> (9);

 <dt>{{DocumentType}}
 <dd><dfn>DOCUMENT_TYPE_NODE</dfn> (10);

 <dt>{{DocumentFragment}}
 <dd><dfn>DOCUMENT_FRAGMENT_NODE</dfn> (11).
</dl>


<!-- NodeExodus
<hr>

<p>The <dfn>namespaceURI</dfn> attribute's getter must return the namespace that is associated with the node, if there is one and it's not the empty string, and null otherwise.

<p>The <dfn id="node-prefix" for="node">prefix</dfn> attribute's getter must return the prefix that is associated with the node, if there is one and it's not the empty string, and null otherwise.
<!- - support setting? - - On setting, it must run these steps:

<ol>
 <li><p>Let <var>prefix</var> be the value being assigned.
 <li>
  <p>If <var>prefix</var> is not null, run these substeps:
  <ol>
   <li><p>If <var title>prefix</var> does not match the <code>Name</code> production in XML, <span title=concept-throw>throw</span> an <code><a>InvalidCharacterError</a></code>.
   <li><p>If <var title>prefix</var> does not match the <code>NCName</code> production in Namespaces in XML, <span>throw</span> a <code><a>NamespaceError</a></code>.
  </ol>
 <li><p>Actually this does not match any browser. Let's try to drop it instead.
</ol>- ->

<p>The <dfn>localName</dfn> attribute's getter must return the local name that is associated with the node, if it has one, and null otherwise.-->

<p>The <dfn attribute for=Node>nodeName</dfn> attribute's getter must return the first matching statement, switching on the <a href="#context-object">context object</a>:

<dl class="switch">
 <dt>{{Element}}
 <dd><p>Its {{Element/tagName}} attribute value.

 <dt>{{Attr}}
 <dd>Its <code><a href="#attribute-qualified-name">qualified name</a></code>.

 <dt>{{Text}}
 <dd><p>"<code>#text</code>".

 <dt>{{CDATASection}}
 <dd>"<code>#cdata-section</code>".

 <dt>{{ProcessingInstruction}}
 <dd><p>Its <a href="#concept-pi-target">target</a>.

 <dt>{{Comment}}
 <dd><p>"<code>#comment</code>".

 <dt>{{Document}}
 <dd><p>"<code>#document</code>".

 <dt>{{DocumentType}}
 <dd><p>Its <a href="#doctype-name">name</a>.

 <dt>{{DocumentFragment}}
 <dd><p>"<code>#document-fragment</code>".
</dl>

<hr>

<dl>
 <dt><var>node</var> . {{Node/baseURI}}
 <dd><p>Returns <var>node</var>'s <a>node document</a>'s <a>document base URL</a>.
</dl>

The <dfn attribute for=Node>baseURI</dfn> attribute's getter must return <a>node document</a>'s <a>document base URL</a>.

<hr>

<dl>
 <dt><var>node</var> . {{Node/ownerDocument}}
 <dd>
  <p>Returns the <a>node document</a>.
  <p>Returns null for <a href="#concept-document">documents</a>.

 <dt><var>node</var> . {{Node/parentNode}}
 <dd><p>Returns the <a>parent</a>.

 <dt><var>node</var> . {{Node/parentElement}}
 <dd><p>Returns the <a>parent element</a>.

 <dt><var>node</var> . {{Node/hasChildNodes()}}
 <dd><p>Returns whether <var>node</var> has <a href="#tree-child">children</a>.

 <dt><var>node</var> . {{Node/childNodes}}
 <dd><p>Returns the <a href="#tree-child">children</a>.

 <dt><var>node</var> . {{Node/firstChild}}
 <dd><p>Returns the <a>first child</a>.

 <dt><var>node</var> . {{Node/lastChild}}
 <dd><p>Returns the <a>last child</a>.

 <dt><var>node</var> . {{Node/previousSibling}}
 <dd><p>Returns the <a href="#concept-tree-previous-sibling">previous sibling</a>.

 <dt><var>node</var> . {{Node/nextSibling}}
 <dd><p>Returns the <a href="#concept-tree-next-sibling">next sibling</a>.
</dl>

<div>

<p>The <dfn attribute for=Node>ownerDocument</dfn> attribute's getter must return null, if the <a>context object</a> is a <a href="#concept-document">document</a>, and the <a>context object</a>'s
<a>node document</a> otherwise.

<p class="note">Note: The <a>node document</a> of a <a href="#concept-document">document</a> is that <a href="#concept-document">document</a> itself. All <a>nodes</a> have a <a href="#concept-document">document</a> at all times.

<p>The <dfn attribute for=Node>parentNode</dfn> attribute's getter must return the <a>context object</a>'s <a>parent</a>.

<p class="note">Note: An {{Attr}} <a lt="nodes">node</a> has no <a>parent</a>.

<p>The <dfn attribute for=Node>parentElement</dfn> attribute's getter must return the <a>context object</a>'s <a>parent element</a>.

<p>The <dfn method for=Node>hasChildNodes()</dfn> method, when invoked, must return true if the <a>context object</a> has <a href="#tree-child">children</a>, and false otherwise.

<p>The <dfn attribute for=Node>childNodes</dfn> attribute's getter must return a {{NodeList}} rooted at the <a>context object</a> matching only <a>children</a>.

<p>The <dfn attribute for=Node>firstChild</dfn> attribute's getter must return the <a>context object</a>'s <a>first child</a>.

<p>The <dfn attribute for=Node>lastChild</dfn> attribute's getter must return the <a>context object</a>'s <a>last child</a>.

<p>The <dfn attribute for=Node id="node-previoussibling">previousSibling</dfn> attribute's getter must return the <a>context object</a>'s <a href="#concept-tree-previous-sibling">previous sibling</a>.

<p class="note">Note: An {{Attr}} <a lt="nodes">node</a> has no <a>siblings</a>.

<p>The <dfn attribute for=Node id="node-nextsibling">nextSibling</dfn> attribute's getter must return the <a>context object</a>'s <a href="#concept-tree-next-sibling">next sibling</a>.
</div>

<hr>

<!-- TODO: domintro -->

<p>The <dfn attribute for=Node>nodeValue</dfn> attribute's getter must return the following, depending on the <a>context object</a>:

<dl class="switch">
 <dt>{{Attr}}
 <dd><p><a>context object</a>'s <a href="#concept-attribute-value">value</a>.

 <dt>{{Text}}
 <dt>{{Comment}}
 <dt>{{ProcessingInstruction}}
 <dd><p>The <a>context object</a>'s <a href="#concept-cd-data">data</a>.

 <dt>Any other node
 <dd><p>Null.
</dl>

<p>The {{Node/nodeValue}} attribute's setter must, if the new value is null, act as if it was the empty string instead, and then do as described below, depending on the <a>context object</a>:

<dl class="switch">
 <dt>{{Attr}}
 <dd><p><a>Set an existing attribute value</a> with <a>context object</a> and new value.

 <dt>{{Text}}
 <dt>{{Comment}}
 <dt>{{ProcessingInstruction}}
 <dd><p><a>Replace data</a> with node <a>context object</a>, offset 0, count <a>context object</a>'s <a href="#node-length">length</a>, and data new value.

 <dt>Any other node
 <dd><p>Do nothing.
</dl>

<p>The <dfn attribute for=Node><code>textContent</code></dfn> attribute's getter must return the following, switching on <a>context object</a>:

<dl class="switch">
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <dd><p>The concatenation of <a href="#concept-cd-data">data</a> of all the {{Text}} <a href="#concept-node">node</a> <a>descendants</a> of the <a>context object</a>, in <a>tree order</a>.

 <dt>{{Attr}}
 <dd><p><a>context object</a>'s <a href="#concept-attribute-value">value</a>.

 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd><p>The <a>context object</a>'s <a href="#concept-cd-data">data</a>.

 <dt>Any other node
 <dd><p>Null.
</dl>

<p>The {{Node/textContent}} attribute's setter must, if the new value is null, act as if it was the empty string instead, and then do as described below, depending on the <a>context object</a>:

<dl class="switch">
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <dd>
  <ol>
   <li><p>Let <var>node</var> be null.

   <li><p>If new value is not the empty string, set <var>node</var> to a new {{Text}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is new value.

   <li><p><a>Replace all</a> with <var>node</var> within the <a>context object</a>.
  </ol>

 <dt>{{Attr}}
 <dd><p><a>Set an existing attribute value</a> with <a>context object</a> and new value.

 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd><p><a>Replace data</a> with node <a>context object</a>, offset 0, count <a>context object</a>'s <a href="#node-length">length</a>, and data new value.

 <dt>Any other node
 <dd><p>Do nothing.
</dl>

<hr>

<dl>
 <dt><code><var>node</var> . {{Node/normalize()}}</code>
 <dd><p>Removes <a>empty</a> <a>exclusive <code>Text</code> nodes</a> and concatenates the <a href="#concept-cd-data">data</a> of remaining <a>contiguous exclusive <code>Text</code> nodes</a> into the first of their <a>nodes</a>.
</dl>

<p>The <dfn method for=Node>normalize()</dfn> method, when invoked, must run these steps for each <a>descendant</a> <a>exclusive <code>Text</code> node</a> <var>node</var> of <a>context object</a>:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s <a href="#node-length">length</a>.

 <li>If <var>length</var> is zero, then <a href="#node-remove">remove</a> <var>node</var> and continue with the next <a>exclusive <code>Text</code> node</a>, if any.

 <li>Let <var>data</var> be the concatenation of the <a href="#concept-cd-data">data</a> of <var>node</var>'s <a>contiguous exclusive <code>Text</code> nodes</a> (excluding itself), in <a>tree order</a>.

 <li><a>Replace data</a> with node <var>node</var>, offset <var>length</var>, count 0, and data <var>data</var>.

 <li>Let <var>currentNode</var> be <var>node</var>'s <a for=tree>next sibling</a>.

 <li>
  <p>While <var>currentNode</var> is an <a>exclusive <code>Text</code> node</a>:

  <ol>
   <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is <var>currentNode</var>, add
   <var>length</var> to its <a>start offset</a> and set its <a>start node</a> to
   <var>node</var>.

   <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>currentNode</var>, add
   <var>length</var> to its <a>end offset</a> and set its <a>end node</a> to
   <var>node</var>.

   <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is <var>currentNode</var>'s
   <a>parent</a> and <a>start offset</a> is <var>currentNode</var>'s <a>index</a>,
   set its <a>start node</a> to <var>node</var> and its <a>start offset</a> to
   <var>length</var>.

   <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>currentNode</var>'s
   <a>parent</a> and <a>end offset</a> is <var>currentNode</var>'s <a>index</a>,
   set its <a>end node</a> to <var>node</var> and its <a>end offset</a> to
   <var>length</var>.

   <li><p>Add <var>currentNode</var>'s <a href="#node-length">length</a> to <var>length</var>.

   <li><p>Set <var>currentNode</var> to its <a for=tree>next sibling</a>.
  </ol>

 <li><a href="#node-remove">Remove</a> <var>node</var>'s <a>contiguous exclusive <code>Text</code> nodes</a> (excluding itself), in <a>tree order</a>.
</ol>
<hr>

<dl>
 <dt><var>node</var> . <a method for=Node lt=cloneNode()>cloneNode([<var>deep</var> = false])</a>
 <dd><p>Returns a copy of <var>node</var>. If <var>deep</var> is true, the copy also includes the <var>node</var>'s <a>descendants</a>.

 <dt><var>node</var> . {{Node/isEqualNode(other)}}
 <dd><p>Returns whether <var>node</var> and <var>other</var> have the same properties.
</dl>

<div>

<a lt="Other applicable specifications">Specifications</a> may define <dfn export id=concept-node-clone-ext>cloning steps</dfn> for all or some <a>nodes</a>. The algorithm is passed <var>copy</var>, <var>node</var>, <var>document</var>, and an optional <i>clone children flag</i>, as indicated in the <a lt="clone a node">clone</a> algorithm.

<p class="note">Note: HTML defines <a>cloning steps</a> for <code><a>script</a></code> and <code><a>input</a></code> elements. SVG ought to do the same for its <code>script</code> elements, but does not call this out at the moment.


<p>To <dfn export id=concept-node-clone lt="clone a node" local-lt="clone">clone</dfn> a <var>node</var>, with an optional <var>document</var> and <i>clone children flag</i>, run these steps:

<ol>
 <li><p>If <var>document</var> is not given, let <var>document</var> be <var>node</var>'s <a>node document</a>.

 <li>
  <p>If <var>node</var> is an <a href="#concept-element">element</a>, then:

  <ol>
   <li>let <var>copy</var> be a <a lt="nodes">node</a> that implements the same interfaces as <var>node</var>.
   <li><p>Set <var>copy</var>'s <a href="#concept-element-local-name">local name</a>, <a href="#concept-element-namespace">namespace</a>,
   <a href="#concept-element-namespace-prefix">namespace prefix</a>, to those of <var>node</var>.  The <var>synchronous custom elements flag</var> should be unset.
   <li>
    <p>For each <var>attribute</var> in <var>node</var>'s
    <a for=Element>attribute list</a>, in order, run these substeps:

    <ol>
     <li><p>Let <var>copyAttribute</var> be a <a>clone</a> of <var>attribute</var>.

     <li><p><a lt="append an attribute">Append</a> <var>copyAttribute</var> to <var>copy</var>.
    </ol>
   </li>
  </ol>
 </li>

 <li><p>Otherwise, let <var>copy</var> be a <a lt="nodes">node</a> that implements the same interfaces as <var>node</var>,
  and fulfills these additional requirements, switching on
  <var>node</var>:

  <dl>
   <dt>{{Document}}
   <dd><p>Set <var>copy</var>'s <a href="#concept-document-encoding">encoding</a>,
   <a href="#concept-document-content-type">content type</a>, <a href="#concept-document-url">URL</a>,
   <a href="#concept-document-origin">origin</a>,
   <a href="#concept-document-type">type</a>, and <a href="#dom-document-compatmode">mode</a>,
   to those of <var>node</var>.

   <dt>{{DocumentType}}
   <dd><p>Set <var>copy</var>'s <a href="#doctype-name">name</a>, <a>public ID</a>, and
   <a>system ID</a>, to those of <var>node</var>.

   <dt>{{Attr}}
   <dd><p>Set <var>copy</var>'s <a href="#concept-attribute-namespace">namespace</a>, <a href="#concept-attribute-namespace-prefix">namespace prefix</a>, <a href="#concept-attribute-local-name">local name</a>, and <a href="#concept-attribute-value">value</a>, to those of <var>node</var>.

   <dt>{{Text}}
   <dt>{{Comment}}
   <dd>Set <var>copy</var>'s <a href="#concept-cd-data">data</a>, to that of <var>node</var>.

   <dt>{{ProcessingInstruction}}
   <dd>Set <var>copy</var>'s<a href="#concept-pi-target">target</a> and <a href="#concept-cd-data">data</a> to
   those of <var>node</var>.

   <dt>Any other node
   <dd><p>—
  </dl>

 <li><p>Set <var>copy</var>'s <a>node document</a> and <var>document</var> to
 <var>copy</var>, if <var>copy</var> is a <a href="#concept-document">document</a>, and set <var>copy</var>'s
 <a>node document</a> to <var>document</var> otherwise.

 <li><p>Run any <a>cloning steps</a> defined for <var>node</var> in <a>other applicable specifications</a> and pass <var>copy</var>, <var>node</var>, <var>document</var> and the <i>clone children flag</i> if set, as parameters.

 <li><p>If the <i>clone children flag</i> is set, <a href="#concept-node-clone">clone</a> all the <a href="#tree-child">children</a> of <var>node</var> and append them to <var>copy</var>, with <var>document</var> as specified and the <i>clone children flag</i> being set.

 <li><p>Return <var>copy</var>.
</ol>

<p>The <dfn method for=Node><code>cloneNode(<var>deep</var>)</code></dfn> method, when
invoked, must run these steps:

<ol>
 <li><p>If <a>context object</a> is a <a href="#concept-shadow-root">shadow root</a>, then <a>throw</a> a
 <code><a>NotSupportedError</a></code>.

 <li><p>Return a <a href="#concept-node-clone">clone</a> of the <a>context object</a>, with the
 <i>clone children flag</i> set if <var>deep</var> is true.
</ol>

<p>A <a href="#concept-node">node</a> <var>A</var> <dfn>equals</dfn> a <a href="#concept-node">node</a> <var>B</var> if all of the following conditions are true:

<ul>
 <li><p><var>A</var> and <var>B</var>'s {{Node/nodeType}} attribute value is identical.
 <li>
  <p>The following are also equal, depending on <var>A</var>:
  <dl class="switch">
   <dt>{{DocumentType}}
   <dd><p>Its <a href="#doctype-name">name</a>, <a>public ID</a>, and <a>system ID</a>.

   <dt>{{Element}}
   <dd>
    <p>Its <a href="#concept-element-namespace">namespace</a>, <a href="#concept-element-namespace-prefix">namespace prefix</a>, <a href="#concept-element-local-name">local name</a>, and its number of <a href="#concept-attribute">attributes</a> in its <a for=Element>attribute list</a>.

   <dt>{{Attr}}
   <dd><p>Its <a href="#concept-attribute-namespace">namespace</a>, <a href="#concept-attribute-local-name">local name</a>, and <a href="#concept-attribute-value">value</a>.


   <dt>{{ProcessingInstruction}}
   <dd><p>Its <a href="#concept-pi-target">target</a> and <a href="#concept-cd-data">data</a>.

   <dt>{{Text}}
   <dt>{{Comment}}
   <dd><p>Its <a href="#concept-cd-data">data</a>.

   <dt>Any other node
   <dd><p>—
  </dl>
 <li><p>If <var>A</var> is an <a href="#concept-element">element</a>, each <a href="#concept-attribute">attribute</a> in its <a for=Element>attribute list</a> has an <a href="#concept-attribute">attribute</a> that <a>equals</a> in <var>B</var>'s <a for=Element>attribute list</a>.
 <li><p><var>A</var> and <var>B</var> have the same number of <a href="#tree-child">children</a>.
 <li><p>Each <a href="#tree-child">child</a> of <var>A</var> <a>equals</a> the <a href="#tree-child">child</a> of <var>B</var> at the identical <a>index</a>.
</ul>

<p>The <dfn method for=Node>isEqualNode(<var>other</var>)</dfn> method, when invoked, must return true if <var>other</var> is not null and <a>context object</a> <a>equals</a> <var>other</var>, and false otherwise.

</div>

<hr>

<dl>
 <dt><var>node</var> . {{Node/compareDocumentPosition(other)}}</dt>
 <dd>
  <p>Returns a bitmask indicating the position of <var>other</var> relative to <var>node</var>. These are the bits that can be set:

  <dl>
   <dt>{{Node}} . <a>DOCUMENT_POSITION_DISCONNECTED</a> (1)</dt>
   <dd>Set when <var>node</var> and <var>other</var> are not in the same <a>tree</a>.

   <dt>{{Node}} . <a>DOCUMENT_POSITION_PRECEDING</a></code> (2)</dt>
   <dd>Set when <var>other</var> is <a>preceding</a> <var>node</var>.

   <dt>{{Node}} . <a>DOCUMENT_POSITION_FOLLOWING</a></code> (4)</dt>
   <dd>Set when <var>other</var> is <a>following</a> <var>node</var>.

   <dt>{{Node}} . <a>DOCUMENT_POSITION_CONTAINS</a></code> (8)</dt>
   <dd>Set when <var>other</var> is an <a>ancestor</a> of <var>node</var>.

   <dt>{{Node}} . <a>DOCUMENT_POSITION_CONTAINED_BY</a></code> (16, 10 in hexadecimal)</dt>
   <dd>Set when <var>other</var> is a <a>descendant</a> of <var>node</var>.
  </dl>

 <dt><var>node</var> . <a>contains</a>(<var>other</var>)</dt>
 <dd><p>Returns true if <var>other</var> is an <a>inclusive descendant</a> of <var>node</var>, and false otherwise.
</dl>

<p>These are the constants <code><a>compareDocumentPosition()</a></code> returns as mask:

<ul>
 <li><dfn>DOCUMENT_POSITION_DISCONNECTED</dfn> (1);
 <li><dfn>DOCUMENT_POSITION_PRECEDING</dfn> (2);
 <li><dfn>DOCUMENT_POSITION_FOLLOWING</dfn> (4);
 <li><dfn>DOCUMENT_POSITION_CONTAINS</dfn> (8);
 <li><dfn>DOCUMENT_POSITION_CONTAINED_BY</dfn> (16, 10 in hexadecimal);
 <li><dfn>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</dfn> (32, 20 in hexadecimal).
</ul>

<p>The <dfn method for=Node>compareDocumentPosition(<var>other</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <a>context object</a> is <var>other</var>, then return zero.

 <li><p>Let <var>node1</var> be <var>other</var> and <var>node2</var> be <a>context object</a>.

 <li><p>Let <var>attr1</var> and <var>attr2</var> be null.

 <li><p>If <var>node1</var> is an <a href="#concept-attribute">attribute</a>, then set <var>attr1</var> to <var>node1</var>
 and <var>node1</var> to <var>attr1</var>'s <a href="#concept-attribute-element">element</a>.

 <li>
  <p>If <var>node2</var> is an <a href="#concept-attribute">attribute</a>, then:

  <ol>
   <li><p>Set <var>attr2</var> to <var>node2</var> and <var>node2</var> to <var>attr2</var>'s
   <a href="#concept-attribute-element">element</a>.

   <li>
    <p>If <var>attr1</var> and <var>node1</var> are non-null, and <var>node2</var> is
    <var>node1</var>, then:

    <ol>
     <li>
      <p>For each <a href="#concept-attribute">attribute</a> <var>attr</var> in <var>node2</var>'s
      <a for=Element>attribute list</a>:

      <ol>
       <li><p>If <var>attr</var> <a>equals</a> <var>attr1</var>, then return the result of
       adding {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}} and
       {{Node/DOCUMENT_POSITION_PRECEDING}}.

       <li><p>If <var>attr</var> <a>equals</a> <var>attr2</var>, then return the result of
       adding {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}} and
       {{Node/DOCUMENT_POSITION_FOLLOWING}}.
      </ol>
    </ol>
  </ol>

 <li>
  <p>If <var>node1</var> or <var>node2</var> is null, or <var>node1</var>'s <a href="#concept-tree-root">root</a> is
  not <var>node2</var>'s <a href="#concept-tree-root">root</a>, then return the result of adding
  {{Node/DOCUMENT_POSITION_DISCONNECTED}}, {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}}, and
  either {{Node/DOCUMENT_POSITION_PRECEDING}} or {{Node/DOCUMENT_POSITION_FOLLOWING}}, with the
  constraint that this is to be consistent, together.

  <p class="note no-backref">Note: Whether to return {{Node/DOCUMENT_POSITION_PRECEDING}} or
  {{Node/DOCUMENT_POSITION_FOLLOWING}} is typically implemented via pointer comparison. In
  JavaScript implementations a cached <code class='lang-javascript'>Math.random()</code> value can
  be used.

 <li><p>If <var>node1</var> is an <a>ancestor</a> of <var>node2</var> and <var>attr1</var> is null,
 or <var>node1</var> is <var>node2</var> and <var>attr2</var> is non-null, then return the result of
 adding {{Node/DOCUMENT_POSITION_CONTAINS}} to {{Node/DOCUMENT_POSITION_PRECEDING}}.

 <li><p>If <var>node1</var> is a <a>descendant</a> of <var>node2</var> and <var>attr2</var> is null,
 or <var>node1</var> is <var>node2</var> and <var>attr1</var> is non-null, then return the result of
 adding {{Node/DOCUMENT_POSITION_CONTAINED_BY}} to {{Node/DOCUMENT_POSITION_FOLLOWING}}.

 <li>
  <p>If <var>node1</var> is <a>preceding</a> <var>node2</var>, then return
  {{Node/DOCUMENT_POSITION_PRECEDING}}.

  <p class="note">Note: Due to the way <a href="#concept-attribute">attributes</a> are handled in this algorithm this results in a
  <a href="#concept-node">node</a>'s <a href="#concept-attribute">attributes</a> counting as <a>preceding</a> that <a href="#concept-node">node</a>'s <a>children</a>,
  despite <a href="#concept-attribute">attributes</a> not <a>participating</a> in a <a>tree</a>.

 <li><p>Return <code><a>DOCUMENT_POSITION_FOLLOWING</a></code>.
</ol>

<p>The <dfn method id="node-contains-func" for=Node>contains(<var>other</var>)</dfn> method, when invoked, must return true if <var>other</var> is an <a>inclusive descendant</a> of <a>context object</a>, and false otherwise (including when <var>other</var> is null).

<hr>

<!--
 XXX apparently these algorithms might not be quite correct
 https://bugzilla.mozilla.org/show_bug.cgi?id=312019
 https://bugzilla.mozilla.org/show_bug.cgi?id=505178
-->

<p>To <dfn>locate a namespace prefix</dfn> for an <var>element</var> using <var>namespace</var>, run these steps:

<ol>
 <li><p>If <var>element</var>'s <a href="#concept-element-namespace">namespace</a> is <var>namespace</var> and its <a href="#concept-element-namespace-prefix">namespace prefix</a> is not null, then return its <a href="#concept-element-namespace-prefix">namespace prefix</a>.

 <li><p>If <var>element</var> <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>" and <a href="#concept-attribute-value">value</a> is <var>namespace</var>, then return <var>element</var>'s first such <a href="#concept-attribute">attribute</a>'s <a href="#concept-attribute-local-name">local name</a>.

 <li><p>If <var>element</var>'s <a>parent element</a> is not null, then return the result of running <a>locate a namespace prefix</a> on that <a href="#concept-element">element</a> using <var>namespace</var>. <li><p>Return null.

</ol>

<p>To <dfn>locate a namespace</dfn> for a <var>node</var> using <var>prefix</var> switch on <var>node</var>:

<dl class="switch">
 <dt>{{Element}}
 <dd>
  <ol>
   <li><p>If its <a href="#concept-element-namespace">namespace</a> is not null and its <a href="#concept-element-namespace-prefix">namespace prefix</a> is <var>prefix</var>, then return <a href="#concept-element-namespace">namespace</a>.

   <li><p>If it <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-namespace">namespace</a>
   is the <a>XMLNS namespace</a>, <a href="#concept-attribute-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>", and
   <a href="#concept-attribute-local-name">local name</a> is <var>prefix</var>, or if <var>prefix</var> is null and it
   <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-namespace">namespace</a> is the
   <a>XMLNS namespace</a>, <a href="#concept-attribute-namespace-prefix">namespace prefix</a> is null, and <a href="#concept-attribute-local-name">
   local name</a> is "<code>xmlns</code>", then return its <a href="#concept-attribute-value">value</a> if it is not the empty string,
   and null otherwise.

   <li><p>If its <a>parent element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>parent element</a> using <var>prefix</var>.
  </ol>

 <dt>{{Document}}
 <dd>
  <ol>
   <li><p>If its <a>document element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>document element</a> using <var>prefix</var>.
  </ol>

 <dt>{{DocumentType}}
 <dt>{{DocumentFragment}}
 <dd><p>Return null.

 <dt>{{Attr}}
 <dd>
  <ol>
   <li><p>If its <a href="#concept-attribute-element">element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a href="#concept-attribute-element">element</a>
   using <var>prefix</var>.
  </ol>

 <dt>Any other node
 <dd>
  <ol>
   <li><p>If its <a>parent element</a> is null, then return null.

   <li><p>Return the result of running <a>locate a namespace</a> on its <a>parent element</a> using <var>prefix</var>.
  </ol>
</dl>

<p>The <dfn method for=Node>lookupPrefix(<var>namespace</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>namespace</var> is null or the empty string, then return null.

 <li>
  <p>Switch on the <a>context object</a>:

  <dl class="switch">
   <dt>{{Element}}
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for it using <var>namespace</var>.

   <dt>{{Document}}
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for its <a>document element</a>, if its <a>document element</a> is non-null, and null otherwise.

   <dt>{{DocumentType}}
   <dt>{{DocumentFragment}}
   <dd><p>Return null.

   <dt>{{Attr}}
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for its <a href="#concept-attribute-element">element</a>,
   if its <a href="#concept-attribute-element">element</a> is non-null, and null otherwise.

   <dt>Any other node
   <dd><p>Return the result of <a lt="locate a namespace prefix">locating a namespace prefix</a> for its <a>parent element</a>, if its <a>parent element</a> is non-null, and null otherwise.
   </dl>
</ol>

<p>The <dfn method for=Node>lookupNamespaceURI(<var>prefix</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>prefix</var> is the empty string, then set it to null.

 <li><p>Return the result of running <a>locate a namespace</a> for the <a>context object</a> using <var>prefix</var>.
</ol>

<p>The <dfn method for=Node>isDefaultNamespace(<var>namespace</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>namespace</var> is the empty string, then set it to null.

 <li><p>Let <var>defaultNamespace</var> be the result of running <a>locate a namespace</a> for <a>context object</a> using null.

 <li><p>Return true if <var>defaultNamespace</var> is the same as <var>namespace</var>, and false otherwise.
</ol>

<hr>

<p>The <dfn method for=Node>insertBefore(<var>node</var>, <var>child</var>)</dfn> method, when invoked, must return the result of <a>pre-inserting</a> <var>node</var> into <a>context object</a> before <var>child</var>.

<p>The <dfn method for=Node>appendChild(<var>node</var>)</dfn> method, when invoked, must return the result of <a href="#node-append">appending</a> <var>node</var> to <a>context object</a>.

<p>The <dfn method for=Node>replaceChild(<var>node</var>, <var>child</var>)</dfn> method, when invoked, must return the result of <a href="#node-replace">replacing</a> <var>child</var> with <var>node</var> within <a>context object</a>.

<p>The <dfn method for=Node>removeChild(<var>child</var>)</dfn> method, when invoked, must return the result of <a>pre-removing</a> <var>child</var> from <a>context object</a>.

<p>The <dfn>list of elements with local name <var>localName</var></dfn> for a <a href="#concept-node">node</a> <var>root</var> is the {{HTMLCollection}} returned by the following algorithm:
<ol>
 <li><p>If <var>localName</var> is "<code>*</code>" (U+002A), return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches only <a>elements</a>.

 <li>
  <p>Otherwise, if <var>root</var>'s <a>node document</a> is an <a>HTML document</a>, return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches the following <a>descendant</a> <a>elements</a>:

  <ul>
   <li>Whose <a href="#concept-element-namespace">namespace</a> is the <a>HTML namespace</a> and whose <a href="#concept-element-local-name">local name</a> is <var>localName</var> <a>converted to ASCII lowercase</a>.

   <li>Whose <a href="#concept-element-namespace">namespace</a> is <em>not</em> the <a>HTML namespace</a> and whose <a href="#concept-element-local-name">local name</a> is <var>localName</var>.
  </ul>

 <li><p>Otherwise, return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#concept-element-local-name">local name</a> is <var>localName</var>.
</ol>

<p>When invoked with the same argument, and as long as <var>root</var>'s <a>node document</a>'s <a for=Document>type</a> has not changed,
the same {{HTMLCollection}} object may be returned as returned by an earlier call.


<p>The <dfn>list of elements with namespace <var>namespace</var> and local name <var>localName</var></dfn> for a <a href="#concept-node">node</a> <var>root</var> is the {{HTMLCollection}} returned by the following algorithm:

<ol>
 <li><p>If <var>namespace</var> is the empty string, set it to null.

 <li><p>If both <var>namespace</var> and <var>localName</var> are "<code>*</code>" (U+002A), return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a>.

 <li><p>Otherwise, if <var>namespace</var> is "<code>*</code>" (U+002A), return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#concept-element-local-name">local name</a> is <var>localName</var>.

 <li><p>Otherwise, if <var>localName</var> is "<code>*</code>" (U+002A), return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#concept-element-namespace">namespace</a> is <var>namespace</var>.

 <li><p>Otherwise, return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> whose <a href="#concept-element-namespace">namespace</a> is <var>namespace</var> and <a href="#concept-element-local-name">local name</a> is <var>localName</var>.
</ol>

<p>When invoked with the same arguments, the same {{HTMLCollection}} object may be returned as returned by an earlier call.


<p>The <dfn>list of elements with class names <var>classNames</var></dfn> for a <a href="#concept-node">node</a> <var>root</var> is the {{HTMLCollection}} returned by the following algorithm:
<ol>
 <li>
  <p>Let <var>classes</var> be the result of running the <a>ordered set parser</a> on <var>classNames</var>.

 <li>
  <p>If <var>classes</var> is the empty set, return an empty {{HTMLCollection}}.

 <li>
  <p>Return a {{HTMLCollection}} rooted at <var>root</var>, whose filter matches <a>descendant</a> <a>elements</a> that have all their <a>classes</a> in <var>classes</var>.

  <p>The comparisons for the <a>classes</a> must be done in an <a>ASCII case-insensitive</a> manner if <var>root</var>'s <a>node document</a>'s <a for=Document>mode</a> is "<code>quirks</code>", and in a <a>case-sensitive</a> manner otherwise.
</ol>

<p>When invoked with the same argument, the same {{HTMLCollection}} object may be returned as returned by an earlier call.

<h3 id=interface-document>Interface {{Document}}</h3>

<pre class='idl'>
[Constructor,
 Exposed=Window]
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  readonly attribute USVString URL;
  readonly attribute USVString documentURI;
  readonly attribute USVString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString charset; // for legacy use, alias of .characterSet
  readonly attribute DOMString inputEncoding; // for legacy use, alias of .characterSet
  readonly attribute DOMString contentType;

  readonly attribute DocumentType? doctype;
  readonly attribute Element? documentElement;
  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  [NewObject] Element createElement(DOMString localName, optional ElementCreationOptions options);
  [NewObject] Element createElementNS(DOMString? namespace, DOMString qualifiedName, optional ElementCreationOptions options);
  [NewObject] DocumentFragment createDocumentFragment();
  [NewObject] Text createTextNode(DOMString data);
  [NewObject] CDATASection createCDATASection(DOMString data);
  [NewObject] Comment createComment(DOMString data);
  [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] Node importNode(Node node, optional boolean deep = false);
  Node adoptNode(Node node);

  [NewObject] Attr createAttribute(DOMString localName);
  [NewObject] Attr createAttributeNS(DOMString? namespace, DOMString qualifiedName);

  [NewObject] Event createEvent(DOMString interface);

  [NewObject] Range createRange();

  // NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
  [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
};

[Exposed=Window]
interface XMLDocument : Document {};

dictionary ElementCreationOptions {
  DOMString is;
};
</pre>

<p>{{Document}} <a>nodes</a> are simply known as <dfn id="concept-document" lt="document|documents">documents</dfn>.

<p>Each <a href="#concept-document">document</a> has an associated <dfn export id="concept-document-encoding" for=Document>encoding</dfn> (an <a spec=W3ENCODING>encoding</a>), <dfn export for=Document id=concept-document-content-type>content type</dfn> (a string), <dfn export for=Document id=concept-document-url>URL</dfn> (a <a spec=url>URL</a>), <dfn export for=Document id=concept-document-origin>origin</dfn> (an <a spec=HTML51>origin</a>),
<dfn export for=Document id=concept-document-type>type</dfn> ("<code>xml</code>" or "<code>html</code>"), and <dfn export for=Document id=concept-document-mode>mode</dfn> ("<code>no-quirks</code>", "<code>quirks</code>", or "<code>limited-quirks</code>"). [[!ENCODING]] [[!URL]] [[!HTML51]]

<p>Unless stated otherwise, a <a href="#concept-document">document</a>'s <a href="#concept-document-encoding">encoding</a> is the <a>utf-8</a> <a spec=W3ENCODING>encoding</a>, its <a for=Document>content type</a> is "<code>application/xml</code>", its <a href="#concept-document-url" for=Document>URL</a> is "<code>about:blank</code>", <a for=Document>origin</a> is an <code><a>opaque origin</a></code>, <a for=Document>type</a> is "<code>xml</code>", and its <a for=Document>mode</a> is "<code>no-quirks</code>".

<p>A <a href="#concept-document">document</a> is said to be an <dfn export>XML document</dfn> if its <a for=Document>type</a> is "<code>xml</code>", and an <dfn>HTML document</dfn> otherwise. Whether a <a href="#concept-document">document</a> is an <a>HTML document</a> or an <a>XML document</a> affects the behavior of certain APIs.

A <a href="#concept-document">document</a> is said to be in <dfn export id=concept-document-no-quirks>no-quirks mode</dfn> if its <a for=Document>mode</a> is "<code>no-quirks</code>", <dfn export id=concept-document-quirks>quirks mode</dfn> if its <a for=Document>mode</a> is "<code>quirks</code>", and <dfn export id=concept-document-limited-quirks>limited-quirks mode</dfn> if its <a for=Document>mode</a> is "<code>limited-quirks</code>".

<div class="note no-backref">Note:  <p>The <a for=Document>mode</a> is only ever changed from the default for <a href="#concept-document">documents</a> created by the <a>HTML parser</a> based on the presence, absence, or value of the DOCTYPE string, and by a new <a>browsing context</a> (initial "<code>about:blank</code>"). [[!HTML51]]

<p><a>No-quirks mode</a> was originally known as "standards mode" and <a>limited-quirks mode</a> was once known as "almost standards mode". They have been renamed because their details are now defined by standards. (And because Ian Hickson vetoed their original names on the basis that they are nonsensical.)</div>

<hr>

<dl>
 <dt><var ignore>document</var> = new {{Document()}}
 <dd><p>Returns a new <a href="#concept-document">document</a>.

 <dt><var ignore>document</var> . {{Document/implementation}}
 <dd><p>Returns <var>document</var>'s {{DOMImplementation}} object.

 <dt><var>document</var> . {{Document/URL}}
 <dt><var>document</var> . {{Document/documentURI}}
 <dd><p>Returns <var>document</var>'s <a href="#concept-document-url">URL</a>.

 <dt><var>document</var> . {{Document/origin}}
 <dd><p>Returns <var>document</var>'s <a href="#concept-document-origin">origin</a>.

 <dt><var>document</var> . {{Document/compatMode}}
 <dd>
  <p>Returns the string "<code>BackCompat</code>" if <var>document</var>'s <a for=Document>mode</a> is "<code>quirks mode</code>", and "<code>CSS1Compat</code>" otherwise.

 <dt><var>document</var> . {{Document/characterSet}}
 <dd><p>Returns <var>document</var>'s <a href="#concept-document-encoding">encoding</a>.

 <dt><var>document</var> . {{Document/contentType}}
 <dd><p>Returns <var>document</var>'s <a>content type</a>.
</dl>

<p>The <dfn constructor for=Document>Document()</dfn> constructor must return a new <a href="#concept-document">document</a> whose <a href="#concept-document-origin">origin</a> is the <a href="#concept-document-origin">origin</a> of the global object's associated <a href="#concept-document">document</a>. [[!HTML51]]

<p class="note">Note: Unlike {{DOMImplementation/createDocument()}}, this constructor does not return an {{XMLDocument}} object, but a <a href="#concept-document">document</a> ({{Document}} object).

<p>The <dfn attribute for=Document>implementation</dfn> attribute's getter must return the {{DOMImplementation}} object that is associated with the <a href="#concept-document">document</a>.

<p>The <dfn attribute for=Document id="document-url">URL</dfn>'s getter and <dfn attribute for=Document>documentURI</dfn> attribute's getter must return the <a href="#concept-document-url">URL</a>.

<p>The <dfn attribute for=Document id="document-origin">origin</dfn> attribute's getter must return the <a spec=HTML51>Unicode serialization</a> of <a>context object</a>'s <a href="#concept-document-origin">origin</a>.

<p>The <dfn attribute for=Document>compatMode</dfn> attribute's getter must return "<code>BackCompat</code>" if the <a>context object</a>'s <a for=Document>mode</a> is "<code>quirks</code>", and "<code>CSS1Compat</code>" otherwise.

<p>The <dfn attribute for=Document>characterSet</dfn> attribute's getter, <dfn>charSet</dfn> attribute's getter, and <dfn>inputEncoding</dfn> attribute's getter, must return <a>context object</a>'s <a href="#concept-document-encoding">encoding</a>'s <a href="https://www.w3.org/TR/encoding/#name">name</a>.

<p>The <dfn attribute for=Document>contentType</dfn> attribute's getter must return the <a>content type</a>.

<hr>

<dl>
 <dt><var>document</var> . {{Document/doctype}}
 <dd><p>Returns the <a href="#concept-doctype">doctype</a> or null if there is none.

 <dt><var>document</var> . {{Document/documentElement}}
 <dd><p>Returns the <a>document element</a>.

 <dt><var ignore>collection</var> = <var>document</var> . {{Document/getElementsByTagName(localName)}}

 <dd>
  <p>If <var>localName</var> is "<code>*</code>" returns a {{HTMLCollection}} of all <a>descendant</a> <a>elements</a>.

  <p>Otherwise, returns a {{HTMLCollection}} of all <a>descendant</a> <a>elements</a> whose <a href="#concept-element-local-name">local name</a> is <var>localName</var>. (Matches case-insensitively against <a>elements</a> in the <a>HTML namespace</a> within an <a>HTML document</a>.)

 <dt><var ignore>collection</var> = <var>document</var> . {{Document/getElementsByTagNameNS(namespace, localName)}}

 <dd>
  <p>If <var>namespace</var> and <var>localName</var> are "<code>*</code>" returns a {{HTMLCollection}} of all <a>descendant</a> <a>elements</a>.

  <p>If only <var>namespace</var> is "<code>*</code>" returns a {{HTMLCollection}} of all <a>descendant</a> <a>elements</a> whose <a href="#concept-element-local-name">local name</a> is <var>localName</var>.

  <p>If only <var>localName</var> is "<code>*</code>" returns a {{HTMLCollection}} of all <a>descendant</a> <a>elements</a> whose <a href="#concept-element-namespace">namespace</a> is <var>namespace</var>.

  <p>Otherwise, returns a {{HTMLCollection}} of all <a>descendant</a> <a>elements</a> whose <a href="#concept-element-namespace">namespace</a> is <var>namespace</var> and <a href="#concept-element-local-name">local name</a> is <var>localName</var>.

 <dt><var ignore>collection</var> = <var>document</var> . {{Document/getElementsByClassName(classNames)}}
 <dt><var ignore>collection</var> = <var>element</var> . {{Element/getElementsByClassName(classNames)}}
 <dd>
  <p>Returns a {{HTMLCollection}} of the <a>elements</a> in the object on which the method was invoked (a <a href="#concept-document">document</a> or an <a href="#concept-element">element</a>) that have all the classes given by <var>classes</var>.
  <p>The <var>classes</var> argument is interpreted as a space-separated list of classes.
</dl>

<p>The <dfn attribute for=Document><code>doctype</code></dfn> attribute's getter must return the
<a for=tree>child</a> of the <a>document</a> that is a <a>doctype</a>, and null otherwise.

<p>The <dfn attribute for=Document>documentElement</dfn> attribute's getter must return the <a>document element</a>.

<p>The <dfn method for=Document>getElementsByTagName(<var>localName</var>)</dfn> method, when invoked, must return the <a>list of elements with local name <var>localName</var></a> for the <a>context object</a>.

<p class="note">Note: Thus, in an <a>HTML document</a>, <code>document.getElementsByTagName("FOO")</code> will match <code>FOO</code> elements that are not in the <a>HTML namespace</a>, and <code>foo</code> elements that are in the <a>HTML namespace</a>, but not <code>FOO</code> elements that are in the <a>HTML namespace</a>.


<p>The <dfn method for=Document>getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</dfn> method, when invoked, must return the <a>list of elements with namespace <var>namespace</var> and local name <var>localName</var></a> for the <a>context object</a>.

<p>The <dfn method for=Document>getElementsByClassName(<var>classNames</var>)</dfn> method, when invoked, must return the <a>list of elements with class names <var>classNames</var></a> for the <a>context object</a>.

<div class="example">
 <p>Given the following XHTML fragment:

 <pre><code class="lang-html">
  &lt;div id="example"&gt;
   &lt;p id="p1" class="aaa bbb"/&gt;
   &lt;p id="p2" class="aaa ccc"/&gt;
   &lt;p id="p3" class="bbb ccc"/&gt;
  &lt;/div&gt;
 </code></pre>

 <p>A call to <code>document.getElementById("example").getElementsByClassName("aaa")</code> would return a {{HTMLCollection}} with the two paragraphs <code>p1</code> and <code>p2</code> in it.

 <p>A call to <code>getElementsByClassName('ccc bbb')</code> would only return one node, however, namely <code>p3</code>. A call to <code>document.getElementById("example").getElementsByClassName('bbb  ccc ')</code> would return the same thing.
<p>A call to <code>getElementsByClassName('aaa,bbb')</code> would return no nodes; none of the elements above are in the <code>aaa,bbb</code> class.  </div> <hr>

<dl>
 <dt><code><var>element</var> = <var>document</var> . <a method for=Document lt=createElement()>createElement(localName [, options])</a></code>

 <dd>
  <p>Returns an <a href="#concept-element">element</a> in the <a>HTML namespace</a> [see <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=19431'>bug 19431</a>] with <var>localName</var> as <a href="#concept-element-local-name">local name</a>. (In an <a>HTML document</a> <var>localName</var> is lowercased.)

  <p>When supplied, <var>options</var>' <code>is</code> member can be used to create a <a>customized built-in element</a>.

 <dt><code><var>element</var> = <var>document</var> . <a method for=Document lt=createElementNS()>createElementNS(namespace, qualifiedName [, options])</a></code>

 <dd>
  <p>Returns an <a href="#concept-element">element</a> with <a href="#concept-element-namespace">namespace</a> <var>namespace</var>. Its <a href="#concept-element-namespace-prefix">namespace prefix</a> will be everything before "<code>:</code>" (U+003E) in <var>qualifiedName</var> or null. Its <a href="#concept-element-local-name">local name</a> will be everything after "<code>:</code>" (U+003E) in <var>qualifiedName</var> or <var>qualifiedName</var>.

  <p>If <var>localName</var> does not match the <code><a type>Name</a></code> production an <code><a>InvalidCharacterError</a></code> will be thrown.

  <p>If one of the following conditions is true a <code><a>NamespaceError</a></code> will be thrown:

  <ul>
   <li><var>localName</var> does not match the <code><a type>QName</a></code> production.
   <li><a href="#concept-element-namespace-prefix">Namespace prefix</a> is not null and <var>namespace</var> is the empty string.
   <li><a href="#concept-element-namespace-prefix">Namespace prefix</a> is "<code>xml</code>" and <var>namespace</var> is not the <a>XML namespace</a>.
   <li><var>qualifiedName</var> or <a href="#concept-element-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>" and <var>namespace</var> is not the <a>XMLNS namespace</a>.
   <li><var>namespace</var> is the <a>XMLNS namespace</a> and neither <var>qualifiedName</var> nor <a href="#concept-element-namespace-prefix">namespace prefix</a> is "<code>xmlns</code>".
  </ul>

  <p>When supplied, <var>options</var>' <code>is</code> member can be used to create a <a>customized built-in element</a>.

 <dt><var ignore>documentFragment</var> = <var>document</var> . {{Document/createDocumentFragment()}}
 <dd><p>Returns a {{DocumentFragment}} <a href="#concept-node">node</a>.

 <dt><var ignore>text</var> = <var>document</var> . {{Document/createTextNode(data)}}
 <dd><p>Returns a {{Text}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is <var>data</var>.

 <dt><var ignore>cdataSection</var> = <var>document</var> . {{Document/createCDATASection(data)}}
 <dd><p>Returns a {{CDATASection}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is <var>data</var>.

 <dt><var ignore>comment</var> = <var>document</var> . {{Document/createComment(data)}}
 <dd><p>Returns a {{Comment}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is <var>data</var>.

 <dt><var ignore>processingInstruction</var> = <var>document</var> . {{Document/createProcessingInstruction(target, data)}}
 <dd>
  <p>Returns a {{ProcessingInstruction}} <a href="#concept-node">node</a> whose <a href="#concept-pi-target">target</a> is <var>target</var> and <a href="#concept-cd-data">data</a> is <var>data</var>.
  <p>If <var>target</var> does not match the <code><a type>Name</a></code> production an <code><a>InvalidCharacterError</a></code> will be thrown.
  <p>If <var>data</var> contains "<code>?&gt;</code>" an <code><a>InvalidCharacterError</a></code> will be thrown.
</dl>

<p>The <dfn export id=concept-element-interface>element interface</dfn> for any <var>name</var> and <var>namespace</var> is {{Element}}, unless stated otherwise.

<p class="note">Note: The HTML Standard will e.g. define that for <code>html</code> and the <a>HTML namespace</a>, the <code>HTMLHtmlElement</code> interface is used. [[!HTML5]

<p>The <dfn method for=Document>createElement(<var>localName</var>, <var>options</var>)</dfn> method, when invoked, must run the these steps:

<ol>
 <li><p>If <var>localName</var> does not match the <code><a type>Name</a></code> production, <a>throw</a> an <code><a>InvalidCharacterError</a></code>.

 <li><p>If the <a>context object</a> is an <a>HTML document</a>, let <var>localName</var> be <a>converted to ASCII lowercase</a>.

 <li><p>Let <var>is</var> be the value of <code>is</code> member of <var>options</var>, or null if no such member exists.

 <li><p>Let <var>element</var> be the result of <a>creating an element</a> given the <a>context object</a>, <var>localName</var>, the <a>HTML namespace</a>, null, <var>is</var>, and with the <var>synchronous custom elements</var> flag set. Rethrow any exceptions.

 <li>If <var>is</var> is non-null, then <a>set an attribute</a> for <var>element</var> using "<code>is</code>" and <var>is</var>.

 <li><p>Return <var>element</var>.
</ol>

<p>The <dfn method for=Document>createElementNS(<var>namespace</var>, <var>qualifiedName</var>)</dfn> method, when invoked, must run these steps:
<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>. Rethrow
 any exceptions.

 <li><p>Let <var>is</var> be the value of <code>is</code> member of <var>options</var>, or null if no such member exists.

 <li><p>Let <var>element</var> be the result of <a>creating an element</a> given the <a>context object</a>, <var>localName</var>, the <a>HTML namespace</a>, <var>is</var>, <var>prefix</var> and with the <var>synchronous custom elements</var> flag set. Rethrow any exceptions.

 <li><p>Return a new <a href="#concept-element" title="concept-element">element</a> that implements <var>interface</var>,
 with no attributes,
 <a href="#concept-element-namespace" title="element-namespace">namespace</a> set to <var>namespace</var>,
 <a href="#concept-element-namespace-prefix" title="element-namespace-prefix">namespace prefix</a> set to <var>prefix</var>,
 <a href="#concept-element-local-name" title="element-local-name">local name</a> set to <var>localName</var>, and
 <a href="#concept-node-document" title="node-document">node document</a> set to the <a href="#context-object">context object</a>.

 <li>If <var>is</var> is non-null, then <a>set an attribute</a> for <var>element</var> using "<code>is</code>" and <var>is</var>.

 <li><p>Return <var>element</var>.
</ol>

<p>The <dfn method for=Document>createDocumentFragment()</dfn> method, when invoked, must return a new {{DocumentFragment}} <a href="#concept-node">node</a> with its <a>node document</a> set to the <a href="#context-object">context object</a>.

<p>The <dfn method for=Document>createTextNode(<var>data</var>)</dfn> method, when invoked, must return a new {{Text}} <a href="#concept-node">node</a> with its <a href="#concept-cd-data">data</a> set to <var>data</var> and <a>node document</a> set to the <a>context object</a>.

<p class="note">Note: No check is performed that <var>data</var> consists of characters that match the <code><a type>Char</a></code> production.

<p>The <dfn method for=Document>createCDATASection(<var>data</var>)</dfn> method, when
invoked, must run these steps:

<ol>
 <li><p>If <a>context object</a> is an <a>HTML document</a>, then <a>throw</a> a
 <code><a>NotSupportedError</a></code>.

 <li><p>If <var>data</var> contains the string "<code>]]></code>", then <a>throw</a> an
 <code><a>InvalidCharacterError</a></code>.

 <li><p>Return a new {{CDATASection}} <a href="#concept-node">node</a> with its <a href="#concept-cd-data">data</a> set to <var>data</var> and
 <a href="#concept-node-document">node document</a> set to the <a>context object</a>.
</ol>

<p>The <dfn method for=Document>createComment(<var>data</var>)</dfn> method, when invoked, must return a new {{Comment}} <a href="#concept-node">node</a> with its <a href="#concept-cd-data">data</a> set to <var>data</var> and <a>node document</a> set to the <a>context object</a>.
<p class="note">Note: No check is performed that <var>data</var> consists of characters that match the <code><a type>Char</a></code> production or that it contains two adjacent hyphens or ends with a hyphen.

<p>The <dfn method for=Document>createProcessingInstruction(<var>target</var>, <var>data</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>target</var> does not match the <code><a type>Name</a></code> production, <a>throw</a> an <code><a>InvalidCharacterError</a></code>. <!-- DOM3 does not check for "xml" -->

 <li><p>If <var>data</var> contains the string "<code>?&gt;</code>", <a>throw</a> an <code><a>InvalidCharacterError</a></code>. <!-- Gecko does this. -->

 <li><p>Return a new {{ProcessingInstruction}} <a href="#concept-node">node</a>, with <a href="#concept-pi-target">target</a> set to <var>target</var>, <a href="#concept-cd-data">data</a> set to <var>data</var>, and <a>node document</a> set to the <a>context object</a>.
</ol>

<p class="note">Note: No check is performed that <var>target</var> contains "<code>xml</code>" or "<code>:</code>", or that <var>data</var> contains characters that match the <code><a type>Char</a></code> production.

<hr>

<dl>
 <dt><var ignore>clone</var> = <var>document</var> . <a method for=Document lt=importNode()>importNode(<var>node</var> [, <var>deep</var> = false])</a>
 <dd>
 <dd>
  <p>Returns a copy of <var>node</var>. If <var>deep</var> is true, the copy also includes the <var>node</var>'s <a>descendants</a>.

  <p>If <var>node</var> is a <a href="#concept-document">document</a> or a <a href="#concept-shadow-root">shadow root</a>, throws a <code><a>NotSupportedError</a></code>.

 <dt><var ignore>node</var> = <var>document</var> . <code><a>adoptNode(<var>node</var>)</a></code>

 <dd>
  <p>Moves <var>node</var> from another <a href="#concept-document">document</a> and returns it.

  <p>If <var>node</var> is a <a href="#concept-document">document</a> throws a <code><a>NotSupportedError</a></code> or, if <var>node</var> is a <a href="#concept-shadow-root">shadow root</a>, throws a <code><a>HierarchyRequestError</a></code>.
</dl>

<p>The <dfn method for=Document>importNode(<var>node</var>, <var>deep</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>node</var> is a <a href="#concept-document">document</a> or <a href="#concept-shadow-root">shadow root</a>, <a>throw</a> a <code><a>NotSupportedError</a></code>.

 <li><p>Return a <a href="#concept-node-clone">clone</a> of <var>node</var>, with <a>context object</a> and the <i>clone children flag</i> set if <var>deep</var> is true.
</ol>

<a lt="Other applicable specifications">Specifications</a> may define
<dfn export id=concept-node-adopt-ext>adopting steps</dfn> for all or some
<a>nodes</a>. The algorithm is passed <var>node</var> and
<var>oldDocument</var>, as indicated in the
<a>adopt</a> algorithm.

<p>To <dfn>adopt</dfn> a <var>node</var> into a <var>document</var>, run these steps:

<ol>
 <li><p>Let <var>oldDocument</var> be <var>node</var>'s <a>node document</a>.

 <li><p>If <var>node</var>'s <a>parent</a> is not null, <a href="#node-remove">remove</a> <var>node</var> from its <a>parent</a>.

 <li>
  <p>If <var>document</var> is not the same as <var>oldDocument</var>, run these substeps:

  <ol>
   <li>
    <p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
    <a>inclusive descendants</a>, run these subsubsteps:
    <ol>
     <li><p>Set <var>inclusiveDescendant</var>'s <a>node document</a> to <var>document</var>.

     <li><p>If <var>inclusiveDescendant</var> is an <a href="#concept-element">element</a>, then set the
     <a>node document</a> of each <a href="#concept-attribute">attribute</a> in <var>inclusiveDescendant</var>'s
     <a for=Element>attribute list</a> to <var>document</var>.
    </ol>

    <li><p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
    <a>shadow-including inclusive descendants</a> that is a <a>custom</a> <a for=/>element</a>,
    <a>enqueue a custom element callback reaction</a> with <var>inclusiveDescendant</var>, callback
    name "<code>adoptedCallback</code>", and an empty argument list.

   <li><p>For each <var>inclusiveDescendant</var> in <var>node</var>'s
   <a>inclusive descendants</a>, in <a>tree order</a>, run the
   <a>adopting steps</a> with <var>inclusiveDescendant</var> and <var>oldDocument</var>.
  </ol>
</ol>

<p>The <dfn method for=Document>adoptNode(<var>node</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>node</var> is a <a href="#concept-document">document</a>, <a>throw</a> a <code><a>NotSupportedError</a></code>.
 <li><p>If <var>node</var> is a <a href="#concept-shadow-root">shadow root</a>, <a>throw</a> a <code><a>HierarchyRequestError</a></code>.
 <li><p><a>Adopt</a> <var>node</var> into the <a>context object</a>.

 <li><p>Return <var>node</var>.
</ol>

<hr>

The <dfn method for=Document>createAttribute(<var>localName</var>)</dfn> method, when
invoked, must run these steps:

<ol>
 <li><p>If <var>localName</var> does not match the <code><a type>Name</a></code> production in XML,
 then <a>throw</a> an <code><a>InvalidCharacterError</a></code>.

 <li>If the <a>context object</a> is an <a>HTML document</a>, then set <var>localName</var> to
 <var>localName</var> in <a>ASCII lowercase</a>.

 <li>Return a new <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-local-name">local name</a> is <var>localName</var> and
 <a>node document</a> is <a>context object</a>.
</ol>

The <dfn method for=Document>createAttributeNS(<var>namespace</var>, <var>qualifiedName</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>.

 <li><p>Return a new <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-namespace">namespace</a> is <var>namespace</var>,
 <a href="#concept-attribute-namespace-prefix">namespace prefix</a> is <var>prefix</var>, <a href="#concept-attribute-local-name">local name</a> is
 <var>localName</var>, and <a>node document</a> is <a>context object</a>.
</ol>

<hr>

<p>The <dfn method for=Document>createEvent(<var>interface</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>constructor</var> be null.

 <li>
  <p>If <var>interface</var> is an <a>ASCII case-insensitive</a> match for any of the strings in the first column in the following table, then set <var>constructor</var> to the interface in the second column on the same row as the matching string:</p>

  <table>
   <thead>
    <tr><th>String<th>Interface<td>Notes
   <tbody>
    <tr><td>"<code>compositionevent</code>"<td><code><a>CompositionEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>customevent</code>"<td>{{CustomEvent}}<td>
    <tr><td>"<code>event</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>event</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>events</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>hashchangeevent</code>"<td><code><a>HashChangeEvent</a></code><td> [[HTML51]]
    <tr><td>"<code>htmlevents</code>"<td><code><a>Event</a></code><td>
    <tr><td>"<code>keyboardevent</code>"<td><code><a>KeyboardEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>messageevent</code>"<td><code><a>MessageEvent</a></code><td> [[WEBMESSAGING]]
    <tr><td>"<code>mouseevent</code>"<td><code><a>MouseEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>mouseevents</code>"<td><code><a>MouseEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>storageevent</code>"<td><code><a>StorageEvent</a></code><td> [[WEBSTORAGE]]
    <tr><td>"<code>uievent</code>"<td><code><a>UIEvent</a></code><td> [[UIEVENTS]]
    <tr><td>"<code>uievents</code>"<td><code><a>UIEvent</a></code><td> [[UIEVENTS]]
  </table></li>

 <li><p>If <var>constructor</var> is null, <a>throw</a> a <code><a>NotSupportedError</a></code>.

 <li>
  <p>If the interface indicated by <var>constructor</var> is not exposed on the <a>relevant global
  object</a> of the <a>context object</a>, then <a>throw</a> a <code><a>NotSupportedError</a></code>.

  <p class=note>Typically user agents disable support for touch events in some configurations, in
  which case this clause would be triggered for the interface <a>TouchEvent</a>.

 <li><p>Let <var>event</var> be the result of <a lt="creating an event">creating an event</a> given <var>constructor</var>.

 <li><p>Initialize <var>event</var>'s {{Event/type}} attribute to the empty string.

 <li><p>Initialize <var>event</var>'s {{Event/timeStamp}} attribute to a {{DOMHighResTimeStamp}} representing the high resolution time from the <a>time origin</a> to now.

 <li><p>Initialize <var>event</var>'s {{Event/isTrusted}} attribute to false.

 <li><p>Unset <var>event</var>'s <a>initialized flag</a>.

 <li><p>Return <var>event</var>.
</ol>

<p class="note">Note: <a>Event</a> constructors ought to be used instead.

<hr>

<p>The <dfn method for=Document>createRange()</dfn> method, when invoked, must return a new <a href="#concept-range">range</a> with (<a>context object</a>, 0) as its <a>start</a> and <a>end</a>.

<p class="note">Note: The <code><a>Range()</a></code> constructor ought to be used instead.

<hr>

<p>The <dfn method for=Document>createNodeIterator(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Create a {{NodeIterator}} object.
 <li><p>Set <a href="#traversal-root">root</a> to <var>root</var> and initialize the {{NodeIterator/referenceNode}} attribute to the <var>root</var> argument.
 <li><p>Initialize the {{NodeIterator/pointerBeforeReferenceNode}} attribute to true.
 <li><p>Set <a href="#traversal-whattoshow">whatToShow</a> to the <var>whatToShow</var> argument.
 <li><p>Set <a href="#traversal-filter" title="traversal-filter">filter</a> to <var>filter</var>.
 <li><p>Return the newly created {{NodeIterator}} object.
</ol>

<p>The <dfn method for=Document>createTreeWalker(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Create a {{TreeWalker}} object.
 <li><p>Set <a href="#traversal-root" title="traversal-root">root</a> to <var>root</var> and initialize the {{TreeWalker/currentNode}} attribute to the <var>root</var> argument.
 <li><p>Set <a href="#traversal-whattoshow">whatToShow</a> to the <var>whatToShow</var> argument.
 <li><p>Set <a href="#traversal-filter" title="traversal-filter">filter</a> to <var>filter</var>.
 <li><p>Return the newly created {{TreeWalker}} object.
</ol>

<h4 id="interface-domimplementation">Interface {{DOMImplementation}}</h4>

<p>User agents must create a {{DOMImplementation}} object whenever a <a href="#concept-document">document</a> is created and associate it with that <a href="#concept-document">document</a>.

<pre class='idl'>
[Exposed=Window]
interface DOMImplementation {
  [NewObject] DocumentType createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] XMLDocument createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional DocumentType? doctype = null);
  [NewObject] Document createHTMLDocument(optional DOMString title);

  boolean hasFeature(); // useless; always returns true
};
</pre>

<dl>
 <dt><var ignore>doctype</var> = <var>document</var> . {{Document/implementation}} . {{DOMImplementation/createDocumentType(qualifiedName, publicId, systemId)}}

 <dd>
  <p>Returns a <a href="#concept-doctype">doctype</a>, with the given <var>qualifiedName</var>, <var>publicId</var>, and <var>systemId</var>. If <var>qualifiedName</var> does not match the <code><a type>Name</a></code> production, an <code><a>InvalidCharacterError</a></code> is thrown, and if it does not match the <code><a type>QName</a></code> production, a <code><a>NamespaceError</a></code> is thrown.

 <dt><var ignore>doc</var> = <var>document</var> . {{Document/implementation}} . <a method for=DOMImplementation lt=createDocument()>createDocument(<var>namespace</var>, <var>qualifiedName</var> [, <var>doctype</var> = null])</a></code>

 <dd>
  <p>Returns an {{XMLDocument}} [see <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22960">bug 22960</a>], with a <a>document element</a> whose <a href="#concept-element-local-name">local name</a> is <var>qualifiedName</var> and whose <a href="#concept-element-namespace">namespace</a> is <var>namespace</var> (unless <var>qualifiedName</var> is the empty string), and with <var>doctype</var>, if it is given, as its <a href="#concept-doctype">doctype</a>.

  <p>This method throws the same exceptions as the {{Document/createElementNS()}} method, when invoked with the same arguments.

 <dt><var ignore>doc</var> = <var>document</var> . {{Document/implementation}} . {{DOMImplementation/createHTMLDocument(title)}}

 <dd>
  <p>Returns a <a href="#concept-document">document</a>, with a basic <a>tree</a> already constructed including a <code>title</code> element, unless the <var>title</var> argument is omitted.
</dl>

<div>

<p>The <dfn method for=DOMImplementation>createDocumentType(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p><a>Validate</a> <var>qualifiedName</var>.

 <li><p>Return a new <a href="#concept-doctype">doctype</a>, with <var>qualifiedName</var> as its <a href="#doctype-name">name</a>, <var>publicId</var> as its <a>public ID</a>, and <var>systemId</var> as its <a>system ID</a>, and with its <a>node document</a> set to the associated <a href="#concept-document">document</a> of the <a>context object</a>.
</ol>
<p class="note">Note: No check is performed that <var>publicId</var> matches the <code>PublicChar</code> production or that <var>systemId</var> does not contain both a '<code>"</code>' and "<code>'</code>".

<p>The <dfn method for=DOMImplementation>createDocument(<var>namespace</var>, <var>qualifiedName</var>, <var>doctype</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li>
  <p>Let <var>document</var> be a new {{XMLDocument}} [see <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22960">bug 22960</a>].

 <li><p>Let <var>element</var> be null.

 <li><p>If <var>qualifiedName</var> is not the empty string, set <var>element</var> to the result of invoking the {{Document/createElementNS()}} method with the arguments <var>namespace</var> and <var>qualifiedName</var> on <var>document</var>. Rethrow any exceptions.

 <li><p>If <var>doctype</var> is not null, <a href="#node-append">append</a> <var>doctype</var> to <var>document</var>.

 <li><p>If <var>element</var> is not null, <a href="#node-append">append</a> <var>element</var> to <var>document</var>.

 <li><p><var>document</var>'s <a href="#concept-document-origin">origin</a> is <a>context object</a>'s associated <a href="#concept-document">document</a>'s <a href="#concept-document-origin">origin</a>.

 <li>
  <p><var>document</var>'s <a>content type</a> is determined by <var>namespace</var>:

    <dl class=switch>
      <dt><a>HTML namespace</a>
      <dd><code>application/xhtml+xml</code>

      <dt><a>SVG namespace</a>
      <dd><code>image/svg+xml</code>

      <dt>Any other namespace
      <dd><code>application/xml</code>
    </dl>

 <li><p>Return <var>document</var>.
</ol>

<p>The <dfn method for=DOMImplementation>createHTMLDocument(<var>title</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>doc</var> be a new <a href="#concept-document">document</a> that is an <a>HTML document</a>.

 <li><p>Set <var>doc</var>'s <a>content type</a> to "<code>text/html</code>".

 <li><p>Create a <a href="#concept-doctype">doctype</a>, with "<code>html</code>" as its <a href="#doctype-name">name</a> and with its <a>node document</a> set to <var>doc</var>. <a href="#node-append">append</a> the newly created node to <var>doc</var>.

 <li><p>Create a <code>html</code> element in the <a>HTML namespace</a>, and <a href="#node-append">append</a> it to <var>doc</var>.

 <li><p>Create a <code>head</code> element in the <a>HTML namespace</a>, and <a href="#node-append">append</a> it to the <code>html</code> element created in the previous step.

 <li>
  <p>If the <var>title</var> argument is not omitted:

  <ol>
   <li><p>Create a <code>title</code> element in the <a>HTML namespace</a>, and <a href="#node-append">append</a> it to the <code>head</code> element created in the previous step.

   <li><p>Create a {{Text}} <a href="#concept-node">node</a>, set its <a href="#concept-cd-data">data</a> to <var>title</var> (which could be the empty string), and <a href="#node-append">append</a> it to the <code>title</code> element created in the previous step.
  </ol>

 <li><p>Create a <code>body</code> element in the <a>HTML namespace</a>, and <a href="#node-append">append</a> it to the <code>html</code> element created in the earlier step.

 <li><p><var>document</var>'s <a href="#concept-document-origin">origin</a> is <a>context object</a>'s associated <a href="#concept-document">document</a>'s <a href="#concept-document-origin">origin</a>.

 <li><p>Return <var>doc</var>.
</ol>

<p>The <dfn method for=DOMImplementation>hasFeature()</dfn> method, when invoked, must return true.

<p class="note">Note: <code><a for=DOMImplementation>hasFeature()</a></code> originally would report whether the user agent claimed to support a given DOM feature, but experience proved it was not nearly as reliable or granular as simply checking whether the desired objects, attributes, or methods existed. As such, it should no longer be used, but continues to exist (and simply returns true) so that old pages don't stop working.

</div>

<h3 id=interface-documentfragment>Interface {{DocumentFragment}}</h3>

<pre class='idl'>
[Constructor,
 Exposed=Window]
interface DocumentFragment : Node {
};
</pre>

<p>A {{DocumentFragment}} <a href="#concept-node">node</a> can have an associated <a href="#concept-element">element</a> named <dfn>host</dfn>.

<p>An object <var>A</var> is a <dfn>host-including inclusive ancestor</dfn> of an object <var>B</var>, if either <var>A</var> is an <a>inclusive ancestor</a> of <var>B</var>, or if <var>B</var>'s <a href="#concept-tree-root">root</a> has an associated <a>host</a> and <var>A</var> is a <a>host-including inclusive ancestor</a> of <var>B</var>'s <a href="#concept-tree-root">root</a>'s <a>host</a>.

<p class="note">Note: The <code>{{DocumentFragment}}</code> <a href="#concept-node">node</a>'s <a>host</a> concept is useful for HTML's <a>template</a> element and for <a href="#concept-shadow-root">shadow root</a>, and impacts the <a>pre-insert</a> and <a href="#node-replace">replace</a> algorithms.

<dl>
 <dt><var ignore>tree</var> = new {{DocumentFragment}}()
 <dd><p>Returns a new {{DocumentFragment}} <a href="#concept-node">node</a>.
</dl>

<p>The <dfn constructor for=DocumentFragment>DocumentFragment()</dfn> constructor must return a new {{DocumentFragment}} <a href="#concept-node">node</a> whose <a>node document</a> is <a>current global object</a>'s <a>associated <code>Document</code></a>.

<h3 id=interface-documenttype>Interface {{DocumentType}}</h3>

<pre class='idl'>
[Exposed=Window]
interface DocumentType : Node {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};
</pre>

<p>{{DocumentType}} <a>nodes</a> are simply known as <dfn id="concept-doctype">doctypes</dfn>.

<p><a href="#concept-doctype">Doctypes</a> have an associated <dfn id="doctype-name">name</dfn>, <dfn>public ID</dfn>, and <dfn>system ID</dfn>.

<p>When a <a href="#concept-doctype">doctype</a> is created, its <a href="#doctype-name">name</a> is always given. Unless explicitly given when a <a href="#concept-doctype">doctype</a> is created, its <a>public ID</a> and <a>system ID</a> are the empty string.

<p>The <dfn attribute for=DocumentType><code>name</code></dfn> attribute's getter must return the <a>context object</a>'s <a for=DocumentType>name</a>.

<p>The <dfn attribute for=DocumentType><code>publicId</code></dfn> attribute's getter must return the <a>context object</a>'s <a>public ID</a>.

<p>The <dfn attribute for=DocumentType><code>systemId</code></dfn> attribute's getter must return the <a>context object</a>'s <a>system ID</a>.

<h3 id=interface-shadowroot>Interface {{ShadowRoot}}</h3>

<pre class=idl>
[Exposed=Window]
interface ShadowRoot : DocumentFragment {
  readonly attribute ShadowRootMode mode;
  readonly attribute Element host;
};

enum ShadowRootMode { "open", "closed" };
</pre>

<p>{{ShadowRoot}} <a>nodes</a> are simply known as
<dfn export id="concept-shadow-root" lt="shadow root">shadow roots</dfn>.

<p><a for=/>Shadow roots</a> have an associated <dfn for=ShadowRoot>mode</dfn> ("<code>open</code>"
or "<code>closed</code>").</p>

<p><a for=/>Shadow roots</a>'s associated <a>host</a> is never null.</p>
<!-- If we ever change this, e.g., add a ShadowRoot object constructor, that would have serious
     consequences for innerHTML. -->

<p>A <a href="#concept-shadow-root">shadow root</a>'s <a>get the parent</a> algorithm, given an <var>event</var>, returns
null if <var>event</var>'s <a>composed flag</a> is unset and <a href="#concept-shadow-root">shadow root</a> is the
<a for=tree>root</a> of <var>event</var>'s <a for=Event>path</a>'s first tuple's <b>item</b>, and
<a href="#concept-shadow-root">shadow root</a>'s <a>host</a> otherwise.

<p>The <dfn attribute for=ShadowRoot><code>mode</code></dfn> attribute's getter must return the
<a>context object</a>'s <a for=ShadowRoot>mode</a>.</p>

<p>The <dfn attribute for=ShadowRoot><code>host</code></dfn> attribute's getter must return the
<a>context object</a>'s <a>host</a>.

<hr>

<p>In <dfn export id=concept-shadow-including-tree-order>shadow-including tree order</dfn>, is
<a>shadow-including preorder, depth-first traversal</a> of a <a>node tree</a>.
<dfn noexport>shadow-including preorder, depth-first traversal</dfn> of a <a>node tree</a>
<var>tree</var> is preorder, depth-first traversal of <var>tree</var>, with for each
<a href="#element-shadow-root">shadow host</a> encountered in <var>tree</var>,
<a>shadow-including preorder, depth-first traversal</a> of that <a for=/>element</a>'s
<a href="#concept-shadow-root">shadow root</a>'s <a>node tree</a> just after it is encountered.

<p>The <dfn export id=concept-shadow-including-root>shadow-including root</dfn> of an object is its
<a for=tree>root</a>'s <a>host</a>'s <a>shadow-including root</a>, if the
object's <a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a>, and its <a for=tree>root</a>
otherwise.</p>

<p>An object <var>A</var> is a
<dfn export id=concept-shadow-including-descendant>shadow-including descendant</dfn> of an object
<var>B</var>, if <var>A</var> is a <a>descendant</a> of <var>B</var>, or <var>A</var>'s
<a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a> and <var>A</var>'s <a for=tree>root</a>'s
<a>host</a> is a <a>shadow-including inclusive descendant</a> of <var>B</var>.

<p>A
<dfn export id=concept-shadow-including-inclusive-descendant>shadow-including inclusive descendant</dfn>
is an object or one of its <a>shadow-including descendants</a>.

<p>An object <var>A</var> is a
<dfn export id=concept-shadow-including-ancestor>shadow-including ancestor</dfn> of an object
<var>B</var>, if and only if <var>B</var> is a <a>shadow-including descendant</a> of <var>A</var>.

<p>A
<dfn export id=concept-shadow-including-inclusive-ancestor>shadow-including inclusive ancestor</dfn>
is an object or one of its <a>shadow-including ancestors</a>.

<p>A <a>node</a> <var>A</var> is
<dfn export id=concept-closed-shadow-hidden>closed-shadow-hidden</dfn> from a <a>node</a>
<var>B</var> if all of the following conditions are true:

<ul>
 <li><p><var>A</var>'s <a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a>.

 <li><p><var>A</var>'s <a for=tree>root</a> is not a <a>shadow-including inclusive ancestor</a> of
 <var>B</var>.

 <li><p><var>A</var>'s <a for=tree>root</a> is a <a href="#concept-shadow-root">shadow root</a> whose
 <a for=ShadowRoot>mode</a> is "<code>closed</code>" or <var>A</var>'s <a for=tree>root</a>'s
 <a>host</a> is <a>closed-shadow-hidden</a> from <var>B</var>.
</ul>

<p>To <dfn export lt="retarget|retargeting">retarget</dfn> an object <var>A</var> against an object
<var>B</var>, repeat these steps until they return an object:</p>

<ol>
 <li><p>If <var>A</var>'s <a for=tree>root</a> is not a <a href="#concept-shadow-root">shadow root</a>, or <var>A</var>'s
 <a for=tree>root</a> is a <a>shadow-including inclusive ancestor</a> of <var>B</var>, then return
 <var>A</var>.

 <li><p>Set <var>A</var> to <var>A</var>'s <a for=tree>root</a>'s <a>host</a>.
</ol>

<hr>

<h3 id=interface-element>Interface {{Element}}</h3>

<pre class='idl'>
[Exposed=Window]
interface Element : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject] readonly attribute DOMTokenList classList;
           attribute DOMString slot;

  boolean hasAttributes();
  [SameObject] readonly attribute NamedNodeMap attributes;
  DOMString? getAttribute(DOMString qualifiedName);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString qualifiedName, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString qualifiedName, DOMString value);
  void removeAttribute(DOMString qualifiedName);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString qualifiedName);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  Attr? getAttributeNode(DOMString qualifiedName);
  Attr? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  Attr? setAttributeNode(Attr attr);
  Attr? setAttributeNodeNS(Attr attr);
  Attr removeAttributeNode(Attr attr);

  ShadowRoot attachShadow(ShadowRootInit init);
  readonly attribute ShadowRoot? shadowRoot;

  Element? closest(DOMString selectors);
  boolean matches(DOMString selectors);
  boolean webkitMatchesSelector(DOMString selectors); // historical alias of .matches

  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  Element? insertAdjacentElement(DOMString where, Element element); // historical
  void insertAdjacentText(DOMString where, DOMString data); // historical
};

dictionary ShadowRootInit {
  required ShadowRootMode mode;
};
</pre>

<p>{{Element}} <a>nodes</a> are simply known as <dfn id="concept-element" lt="element|elements">elements</dfn>.</p>

<p><a href="#concept-element">Elements</a> have an associated <dfn id="concept-element-namespace" for="element">namespace</dfn>, <dfn id="concept-element-namespace-prefix" for="element">namespace prefix</dfn>, <dfn id="concept-element-local-name" for="element">local name</dfn>, <dfn export id=concept-element-custom-element-state for=Element>custom element state</dfn>, <dfn export id=concept-element-custom-element-definition for=Element>custom element definition</dfn>, and <dfn id=concept-element-is-value for=Element><code>is</code> value</dfn>. When an <a href="#concept-element">element</a> is <a lt="create an element">created</a>, all of these values are initialized.

<p>An <a for=/>element</a>'s <a>custom element state</a> is one of "<code>undefined</code>", "<code>failed</code>", "<code>uncustomized</code>", or "<code>custom</code>". An <a for=/>element</a> whose <a>custom element state</a> is "<code>uncustomized</code>" or "<code>custom</code>" is said to be <dfn export id=concept-element-defined for=Element>defined</dfn>. An <a for=/>element</a> whose <a>custom element state</a> is "<code>custom</code>" is said to be <dfn export id=concept-element-custom for=Element>custom</dfn>.

<p class=note>Whether or not an element is <a>defined</a> is used to determine the behavior of the '':defined'' pseudo-class. Whether or not an element is <a>custom</a> is used to determine the behavior of the <a href=#mutation-algorithms>mutation algorithms</a>. The "<code>failed</code>" state is used to ensure that if a <a>custom element constructor</a> fails to execute correctly the first time, it is not executed again by an <a lt="upgrade an element">upgrade</a>.

<div class=example>
 <p>The following code illustrates elements in each of these four states:</p>

 <pre><code class="lang-html">
  &lt;!DOCTYPE html>
  &lt;script>
    window.customElements.define("sw-rey", class extends HTMLElement {})
    window.customElements.define("sw-finn", class extends HTMLElement {}, { extends: "p" })
    window.customElements.define("sw-kylo", class extends HTMLElement {
      constructor() {
        // super() intentionally omitted for this example
      }
    })
  &lt;/script>

  &lt;!-- "undefined" (not defined, not custom) -->
  &lt;sw-han>&lt;/sw-han>
  &lt;p is="sw-luke">&lt;/p>
  &lt;p is="asdf">&lt;/p>

  &lt;!-- "failed" (not defined, not custom) -->
  &lt;sw-kylo>&lt;/sw-kylo>

  &lt;!-- "uncustomized" (defined, not custom) -->
  &lt;p>&lt;/p>
  &lt;asdf>&lt;/asdf>

  &lt;!-- "custom" (defined, custom) -->
  &lt;sw-rey>&lt;/sw-rey>
  &lt;p is="sw-finn">&lt;/p>
 </code></pre>
</div>

<p><a href="#concept-element">Elements</a> also have an associated
<dfn id="element-shadow-root" for="element">shadow root</dfn> (null or a
<a href="#concept-shadow-root">shadow root</a>). Null unless otherwise stated.

<p>An <a href="#concept-element">element</a>'s <dfn id="element-qualified-name" for=Element>qualified name</dfn> is its <a href="#concept-element-local-name">local name</a> if its <a href="#concept-element-namespace-prefix">namespace prefix</a> is null, or its
<a href="#concept-element-namespace-prefix">namespace prefix</a>, followed by "<code>:</code>", followed by its <a href="#concept-element-local-name">local name</a>.

<p><a href="#concept-element">Elements</a> also have an <dfn export id="concept-element-attribute-list" for=Element>attribute list</dfn>, which is a list exposed through a {{NamedNodeMap}}. Unless explicitly given when an <a href="#concept-element">element</a> is created, its <a for=Element>attribute list</a> is empty. An <a href="#concept-element">element</a> <dfn>has</dfn> an <a href="#concept-attribute">attribute</a> <var>A</var> if <var>A</var> is in its <a
for=Element>attribute list</a>.

This and <a lt="other applicable specifications">other specifications</a> may define
<dfn>attribute change steps</dfn> for <a href="#concept-element">elements</a>. The algorithm is passed <var>element</var>, <var>localName</var>,
<var>oldValue</var>, <var>value</var>, and <var>namespace</var>.

<hr>

<p>To
<dfn export id=concept-create-element lt="create an element|creating an element">create an element</dfn>,
given a <var>document</var>, <var>prefix</var>, <var>localName</var>, <var>namespace</var>,
<var>is</var>, and optional <var>synchronous custom elements flag</var>, run these steps:

<ol>
 <li><p>Let <var>result</var> be null.

 <li><p>Let <var>definition</var> be the result of
 <a lt="look up a custom element definition">looking up a custom element definition</a> given
 <var>document</var>, <var>namespace</var>, <var>localName</var>, and <var>is</var>.

 <li>
  <p>If <var>definition</var> is non-null, and <var>definition</var>'s
  <a for="custom element definition">name</a> is not equal to its
  <a for="custom element definition">local name</a> (i.e., <var>definition</var> represents a
  <a>customized built-in element</a>), then:

  <ol>
   <li><p>Let <var>interface</var> be the <a>element interface</a> for <var>localName</var> and the
   <a>HTML namespace</a>.

   <li><p>Set <var>result</var> to a new <a for=/>element</a> that implements <var>interface</var>,
   with no attributes, <a href="#concept-element-namespace">namespace</a> set to the <a>HTML namespace</a>,
   <a href="#concept-element-namespace-prefix">namespace prefix</a> set to <var>prefix</var>, <a href="#concept-element-local-name">local name</a> set
   to <var>localName</var>, <a>custom element state</a> set to "<code>undefined</code>",
   <a>custom element definition</a> set to null, <a><code>is</code> value</a> set to <var>is</var>,
   and <a>node document</a> set to <var>document</var>.

   <li><p>If the <var>synchronous custom elements flag</var> is set,
   <a lt="upgrade an element">upgrade</a> <var>element</var> using <var>definition</var>.

   <li><p>Otherwise, <a>enqueue a custom element upgrade reaction</a> given <var>result</var> and
   <var>definition</var>.
  </ol>
 </li>

 <li>
  <p>Otherwise, if <var>definition</var> is non-null, then:

  <ol>
   <li>
    <p>If the <var>synchronous custom elements flag</var> is set:

    <ol>
     <li><p>Let <var>C</var> be <var>definition</var>'s
     <a for="custom element definition">constructor</a>.

     <li><p>Set <var>result</var> to <a href="https://heycam.github.io/webidl/#construct-a-callback-function">Construct</a>(<var>C</var>). Rethrow any
     exceptions.

     <li>
      <p>If <var>result</var> does not implement the {{HTMLElement}} interface, <a>throw</a> a
      {{TypeError}} exception.

      <div class=note>
       <p>This is meant to be a brand check to ensure that the object was allocated by the
       a HTML element constructor. See
       <a href="https://github.com/heycam/webidl/issues/97">webidl #97</a> about making this more
       precise.

       <p>If this check passes, then <var>result</var> will already have its <a>custom element
       state</a> and <a>custom element definition</a> initialized.
      </div>
     </li>

     <li><p>If <var>result</var>'s <a for=Element>attribute list</a> is not empty, <a>throw</a> a
     {{NotSupportedError}} exception.

     <li><p>If <var>result</var> has <a>children</a>, <a>throw</a> a {{NotSupportedError}}
     exception.

     <li><p>If <var>result</var>'s <a>parent</a> is not null, <a>throw</a> a {{NotSupportedError}}
     exception.

     <li><p>If <var>result</var>'s <a>node document</a> is not <var>document</var>, <a>throw</a> a
     {{NotSupportedError}} exception.

     <li><p>If <var>result</var>'s <a href="#concept-element-namespace">namespace</a> is not the <a>HTML namespace</a>,
     <a>throw</a> a {{NotSupportedError}} exception.

     <li><p>If <var>result</var>'s <a href="#concept-element-local-name">local name</a> is not equal to
     <var>localName</var>, <a>throw</a> a {{NotSupportedError}} exception.

     <li><p>Set <var>result</var>'s <a href="#concept-element-namespace-prefix">namespace prefix</a> to <var>prefix</var>.
    </ol>
   </li>

   <li>
    <p>Otherwise:

    <ol>
     <li><p>Set <var>result</var> to a new <a for=/>element</a> that implements the {{HTMLElement}}
     interface, with no attributes, <a href="#concept-element-namespace">namespace</a> set to the <a>HTML namespace</a>,
     <a href="#concept-element-namespace-prefix">namespace prefix</a> set to <var>prefix</var>, <a href="#concept-element-local-name">local name</a> set
     to <var>localName</var>, <a>custom element state</a> set to "<code>undefined</code>",
     <a>custom element definition</a> set to null, <a><code>is</code> value</a> set to null, and
     <a>node document</a> set to <var>document</var>.

     <li><p><a>Enqueue a custom element upgrade reaction</a> given <var>result</var> and
     <var>definition</var>.
    </ol>
   </li>
  </ol>
 </li>

 <li>
  <p>Otherwise:

  <ol>
   <li><p>Let <var>interface</var> be the <a>element interface</a> for <var>localName</var> and
   <var>namespace</var>.

   <li><p>Set <var>result</var> to a new <a for=/>element</a> that implements <var>interface</var>,
   with no attributes, <a href="#concept-element-namespace">namespace</a> set to <var>namespace</var>,
   <a href="#concept-element-namespace-prefix">namespace prefix</a> set to <var>prefix</var>, <a href="#concept-element-local-name">local name</a> set
   to <var>localName</var>, <a>custom element state</a> set to "<code>uncustomized</code>",
   <a>custom element definition</a> set to null, <a><code>is</code> value</a> set to <var>is</var>,
   and <a>node document</a> set to <var>document</var>.

   <li><p>If <var>document</var> has a <a>browsing context</a>, and
   <var>namespace</var> is the <a>HTML namespace</a>, and either <var>localName</var> is a
   <a>valid custom element name</a> or <var>is</var> is is non-null, set <var>result</var>'s
   <a>custom element state</a> to "<code>undefined</code>".
  </ol>
 </li>

 <li><p>Return <var>result</var>.
</ol>

To <dfn export id=concept-element-attributes-replace lt="replace an attribute">replace</dfn> an
<a href="#concept-attribute">attribute</a> <var>oldAttr</var> by an <a href="#concept-attribute">attribute</a> <var>newAttr</var>
in an <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var>
 with name <var>oldAttr</var>'s <a href="#concept-attribute-local-name">local name</a>,
 namespace <var>oldAttr</var>'s <a href="#concept-attribute-namespace">namespace</a>,
 and oldValue <var>oldAttr</var>'s <a href="#concept-attribute-value">value</a>.

 <li><p>Run the <a>attribute change steps</a> with <var>element</var>, <var>oldAttr</var>'s
 <a href="#concept-attribute-local-name">local name</a>, <var>oldAttr</var>'s <a href="#concept-attribute-value">value</a>, <var>newAttr</var>'s
 <a href="#concept-attribute-value">value</a>, and <var>oldAttr</var>'s <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>If <var>element</var> is <a>custom</a>, then <a>enqueue a custom element callback reaction</a> with <var>element</var>,
 callback name "<code>attributeChangedCallback</code>", and an argument list containing <var>oldAttr</var>'s
 <a href="#concept-attribute-local-name">local name</a>, <var>oldAttr</var>'s <a href="#concept-attribute-value">value</a>, <var>newAttr</var>'s <a href="#concept-attribute-value">value</a>,
 and <var>oldAttr</var>'s <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>Replace <var>oldAttr</var> by <var>newAttr</var> in the <var>element</var>'s <a for=Element>attribute list</a>.

 <li><p>Set <var>oldAttr</var>'s <a href="#concept-attribute-element">element</a> to null.

 <li><p>Set <var>newAttr</var>'s <a href="#concept-attribute-element">element</a> to <var>element</var>.
</ol>

To <dfn id="element-attributes-get-by-name">get an attribute by name</dfn> given a
<var>qualifiedName</var> and <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p>If <var>element</var> is in the <a>HTML namespace</a> and its <a>node document</a>
 is an <a>HTML document</a>, then set <var>qualifiedName</var> to <var>qualifiedName</var> in
 <a>ASCII lowercase</a>.

 <li><p>Return the first <a href="#concept-attribute">attribute</a> in <var>element</var>'s <a for=Element>attribute list</a>
 whose <a href="#attribute-qualified-name">qualified name</a> is <var>qualifiedName</var>, and null otherwise.
</ol>

<p>To <dfn id="element-attributes-get-by-namespace">get an attribute by namespace and local name</dfn>
given a <var>namespace</var>, <var>localName</var>, and <a href="#concept-element">element</a> <var>element</var>,
run these steps:

<ol>
 <li>If <var>namespace</var> is the empty string, set it to null.

 <li>Return the <a href="#concept-attribute">attribute</a> in
 <var>element</var>'s <a for=Element>attribute list</a>
 whose <a href="#concept-attribute-namespace">namespace</a> is
 <var>namespace</var> and
 <a href="#concept-attribute-local-name">local name</a> is
 <var>localName</var>, if any, and null otherwise.
</ol>

<p>To <dfn>get an attribute value</dfn> given <a href="#concept-element">element</a> <var>element</var>,
<var>localName</var>, and an optional <var>namespace</var> (null unless stated otherwise), run these steps:</p>

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-namespace">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.</p></li>

 <li><p>If <var>attr</var> is null, then return the empty string.</p></li>

 <li><p>Return <var>attr</var>'s <a href="#concept-attribute-value">value</a>.</p></li>
</ol>

To <dfn id="element-attributes-set-by-attr">set an attribute</dfn> given an
<var>attr</var> and <var>element</var>, run these steps:

<ol>
 <li><p>If <var>attr</var>'s <a href="#concept-attribute-element">element</a> is neither null nor <var>element</var>,
 <a>throw</a> an <code><a>InUseAttributeError</a></code>.

 <li><p>Let <var>oldAttr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>attr</var>'s <a href="#concept-attribute-namespace">namespace</a>, <var>attr</var>'s <a href="#concept-attribute-local-name">local name</a>, and
 <var>element</var>.

 <li><p>If <var>oldAttr</var> is <var>attr</var>, return <var>attr</var>.

 <li><p>If <var>oldAttr</var> is non-null, <a lt="replace an attribute">replace</a> it
  by <var>attr</var> in <var>element</var>.

 <li><p>Otherwise, <a href="#element-append">append</a> <var>attr</var> to <var>element</var>.

 <li><p>Return <var>oldAttr</var>.
</ol>

<p>To <dfn export id=concept-element-attributes-set-value>set an attribute value</dfn> for
an <a for="/">element</a> <var>element</var>
using a <var>localName</var> and <var>value</var>, and an optional <var>prefix</var>, and
an optional <var>namespace</var>, run these steps:

<ol>
 <li>If <var>prefix</var> is not given, set it to null.

 <li>If <var>namespace</var> is not given, set it to null.

 <li>Let <var>attribute</var> be the result of
 <a href="#element-attributes-get-by-namespace">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li>If <var>attribute</var> is null, create an <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-namespace">namespace</a> is
 <var>namespace</var>, <a href="#concept-attribute-namespace-prefix">namespace prefix</a> is <var>prefix</var>,
 <a href="#concept-attribute-local-name">local name</a> is <var>localName</var>, <a href="#concept-attribute-value">value</a> is <var>value</var>, and
 <a href="#concept-node-document">node document</a> is <var>element</var>'s <a href="#concept-node-document">node document</a>, then
 <a href="#element-append">append</a> this <a href="#concept-attribute">attribute</a> to <var>element</var>, and then
 terminate these steps.

 <li><a>Change</a>
 <var>attribute</var> from <var>element</var> to
 <var>value</var>.
</ol>

<p>To <dfn>change</dfn> an <a href="#concept-attribute">attribute</a> <var>attribute</var> from an <a href="#concept-element">element</a> <var>element</var> to <var>value</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var> with name <var>attribute</var>'s <a href="#concept-attribute-local-name">local name</a>, namespace <var>attribute</var>'s <a href="#concept-attribute-namespace">namespace</a>, and oldValue <var>attribute</var>'s <a href="#concept-attribute-value">value</a>.

 <li><p>If <var>element</var> is <a>custom</a>, then <a>enqueue a custom element callback reaction</a> with <var>element</var>,
 callback name "<code>attributeChangedCallback</code>", and an argument list containing <var>attribute</var>'s
 <a href="#concept-attribute-local-name">local name</a>, <var>attribute</var>'s <a href="#concept-attribute-value">value</a>, <var>value</var>, and <var>attribute</var>'s
 <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>Run the <a>attribute change steps</a> with <var>element</var>, <var>attribute</var>'s
 <a href="#concept-attribute-local-name">local name</a>, <var>attribute</var>'s <a href="#concept-attribute-value">value</a>, <var>value</var>, and
 <var>attribute</var>'s <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>Set <var>attribute</var>'s <a href="#concept-attribute-value">value</a> to <var>value</var>.
</ol>

<p>To <dfn id="element-append" lt="append an attribute">append</dfn> an <a href="#concept-attribute">attribute</a> <var>attribute</var> to an <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var> with name <var>attribute</var>'s <a href="#concept-attribute-local-name">local name</a>, namespace <var>attribute</var>'s <a href="#concept-attribute-namespace">namespace</a>, and oldValue null.

 <li><p>If <var>element</var> is <a>custom</a>, then <a>enqueue a custom element callback reaction</a> with <var>element</var>,
 callback name "<code>attributeChangedCallback</code>", and an argument list containing <var>attribute</var>'s
 <a href="#concept-attribute-local-name">local name</a>, null, <var>attribute</var>'s <a href="#concept-attribute-value">value</a>, and <var>attribute</var>'s
 <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>Run the <a>attribute change steps</a> with <var>element</var>, <var>attribute</var>'s
 <a href="#concept-attribute-local-name">local name</a>, <var>attribute</var>'s <a href="#concept-attribute-value">value</a>, <var>value</var>, and
 <var>attribute</var>'s <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>Append the <var>attribute</var> to the <var>element</var>'s <a for=Element>attribute list</a>.

 <li>Set <var>attribute</var>'s <a href="#concept-attribute-element">element</a> to <var>element</var>.
</ol>

<p>To <dfn id="element-attributes-remove" for="element-attributes">remove</dfn> an <a href="#concept-attribute">attribute</a> <var>attribute</var> from an <a href="#concept-element">element</a> <var>element</var>, run these steps:

<ol>
 <li><p><a>Queue a mutation record</a> of "<code>attributes</code>" for <var>element</var> with name <var>attribute</var>'s <a href="#concept-attribute-local-name">local name</a>, namespace <var>attribute</var>'s <a href="#concept-attribute-namespace">namespace</a>, and oldValue <var>attribute</var>'s <a href="#concept-attribute-value">value</a>.

 <li><p>Run the <a>attribute change steps</a> with <var>element</var>, <var>attribute</var>'s
 <a href="#concept-attribute-local-name">local name</a>, <var>attribute</var>'s <a href="#concept-attribute-value">value</a>, <var>value</var>, and
 <var>attribute</var>'s <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>If <var>element</var> is <a>custom</a>, then <a>enqueue a custom element callback reaction</a> with <var>element</var>,
 callback name "<code>attributeChangedCallback</code>", and an argument list containing <var>attribute</var>'s
 <a href="#concept-attribute-local-name">local name</a>, <var>attribute</var>'s <a href="#concept-attribute-value">value</a>, null, and <var>attribute</var>'s
 <a href="#concept-attribute-namespace">namespace</a>.

 <li><p>Remove <var>attribute</var> from the <var>element</var>'s <a for=Element>attribute list</a>.

 <li>Set <var>attribute</var>'s <a href="#concept-attribute-element">element</a> to null.
</ol>

<p>To <dfn export id=concept-element-attributes-remove-by-name>remove an attribute by name</dfn>
given a <var>qualifiedName</var> and <a for="/">element</a> <var>element</var>, run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-name">getting an attribute</a> given
 <var>qualifiedName</var> and <var>element</var>.

 <li><p>If <var>attr</var> is non-null, <a href="#element-attributes-remove">remove</a> it from
 <var>element</var>.

 <li><p>Return <var>attr</var>.
</ol>

<p>To
<dfn export id=concept-element-attributes-remove-by-namespace>remove an attribute by namespace and local name</dfn>
given a <var>namespace</var>, <var>localName</var>, and
<a for="/">element</a> <var>element</var>, run these steps:

<ol>
 <li>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-namespace">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li><p>If <var>attr</var> is non-null, <a href="#element-attributes-remove">remove</a> it from
 <var>element</var>.

 <li><p>Return <var>attr</var>.
</ol>

<hr>

An <a href="#concept-element">element</a> can have an associated <dfn export for=Element id=concept-id lt="ID">unique identifier (ID)</dfn>.

<p class=note>Historically <a href="#concept-element">elements</a> could have multiple identifiers e.g., by using
the HTML <code>id</code> <a href="#named-attribute">attribute</a> and a DTD. This specification makes <a for=Element>ID</a>
a concept of the DOM and allows for only one per <a href="#concept-element">element</a>, given by an
<a href="#named-attribute"><code>id</code> attribute</a>.

<p>Use these <a>attribute change steps</a> to update an <a href="#concept-element">element</a>'s
<a for=Element>ID</a>:

<ol>
 <li><p>If the given attribute's <var>localName</var> is <code>id</code>, <var>namespace</var> is null, and
 <var>value</var> is null or the empty string, then unset <var>element</var>'s
 <a for=Element>ID</a>.

 <li><p>Otherwise, if <var>localName</var> is <code>id</code>, <var>namespace</var> is null, then
 set <var>element</var>'s <a for=Element>ID</a> to <var>value</var>.
</ol>

<p class="note no-backref">Note: While this specification defines requirements for <code>class</code> and
 <code>id</code> <a href="#named-attribute">attributes</a> on any <a href="#concept-element">element</a>, it makes no
claims as to whether using them is conforming or not.

<hr>

<p>A <a href="#concept-node">node</a>'s <a>parent</a> of type {{Element}} is known as a <dfn>parent element</dfn>. If the <a href="#concept-node">node</a> has a <a>parent</a> of a different type, its <a>parent element</a> is null.</p>

<hr>

<dl>
 <dt><var ignore>namespace</var> = <var>element</var> . {{Element/namespaceURI}}
 <dd><p>Returns the <a href="#concept-element-namespace">namespace</a>.

 <dt><var ignore>prefix</var> = <var>element</var> . {{Element/prefix}}
 <dd><p>Returns the <a href="#concept-element-namespace-prefix">namespace prefix</a>.

 <dt><var ignore>localName</var> = <var>element</var> . {{Element/localName}}
 <dd><p>Returns the <a href="#concept-element-local-name">local name</a>.

 <dt><var ignore>qualifiedName</var> = <var>element</var> . {{Element/tagName}}
 <dd>Returns the <a href="#element-qualified-name" for=Element>qualified name</a>. (The return value is uppercased in an
 <a>HTML document</a>.)
</dl>

<p>The <dfn attribute for=Element id="element-namespaceuri">namespaceURI</dfn> attribute's getter must return the <a>context object</a>'s <a href="#concept-element-namespace">namespace</a>.

<p>The <dfn attribute for=Element id="element-prefix">prefix</dfn> attribute's getter must return the <a>context object</a>'s <a href="#concept-element-namespace-prefix">namespace prefix</a>.

<p>The <dfn attribute for=Element id="element-localname">localName</dfn> attribute's getter must return the <a>context object</a>'s <a href="#concept-element-local-name">local name</a>.

<p>The <dfn attribute for=Element>tagName</dfn> attribute's getter must run these steps:
<ol>
 <li><p>Let <var>qualifiedName</var> be <a>context object</a>'s <a for=Element>qualified name</a>.

 <li><p>If the <a>context object</a> is in the <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, let <var>qualifiedName</var> be <a>converted to ASCII uppercase</a>.

 <li><p>Return <var>qualifiedName</var>.
</ol>

<hr>

<p>IDL attributes that are defined to <dfn export id="concept-reflect">reflect</dfn> a content <a href="#concept-attribute">attribute</a> of a given <var>name</var>, must have a getter and setter that follow these steps:

<dl>
  <dt>getter
  <dd>
    <p>Return the result of running <a>get an attribute value</a> given <a>context object</a> and <var>name</var>.

  <dt>setter
  <dd>
    <p><a>Set an attribute value</a> for the <a>context object</a> using <var>name</var> and the given value.
</dl>

<p>The <dfn attribute for=Element><code>id</code></dfn> attribute must <a for=Attr>reflect</a> the "<code>id</code>" content attribute.

<p>The <dfn attribute for=Element><code>className</code></dfn> attribute must <a for=Attr>reflect</a> the "<code>class</code>" content attribute.

<p>The <dfn attribute for=Element><code>classList</code></dfn> attribute's getter must return the associated <code>{{DOMTokenList}}</code> object representing the <a>context object</a>'s <a>classes</a>.
The <a>token set</a>of this particular {{DOMTokenList}} object are also known as the <a for="/">element</a>'s <dfn export for=Element id="concept-class" lt="class">classes</dfn>.

<p>The <dfn attribute for=Element><code>slot</code></dfn> attribute must <a>reflect</a> the
 "<code>slot</code>" content attribute.

<p class="note"><code>id</code>, <code>class</code>, and <code>slot</code> are effectively
 superglobal attributes as they can appear on any element, regardless of that element's namespace.</p>

<hr>

<p>The <dfn method for=Element>hasAttributes()</dfn> method, when invoked, must return
false if <a>context object</a>'s <a for=Element>attribute list</a> is empty, and
true otherwise.

<p>The <dfn attribute for=Element id="element-attributes">attributes</dfn> attribute's getter must return a {{NamedNodeMap}}.

<p>The <dfn method for=Element>getAttribute(<var>qualifiedName</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a href="#element-attributes-get-by-name" title="#element-attributes-get-by-name">
 getting an attribute</a> given <var>qualifiedName</var> and the <a>context object</a>.

 <li><p>If <var>attr</var> is null, return null.

 <li><p>Return <var>attr</var>'s <a href="#concept-attribute-value">value</a>.
</ol>

<p>The <dfn method for=Element>getAttributeNS(<var>namespace</var>, <var>localName</var>)</dfn> method, when invoked, must return the following steps:
<ol>
  <li><p>If <var>namespace</var> is the empty string, set it to null.

  <li><p>Return <a href="#element-attributes-get-by-name">getting an attribute</a> for the <a>context object</a> using <var>localName</var> and <var>namespace</var>.
</ol>

<p>The <dfn method for=Element>setAttribute(<var>qualifiedName</var>, <var>value</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>name</var> does not match the <code><a type>QName</a></code> production in XML, <a>throw</a> an <code><a>InvalidCharacterError</a></code>.

 <li><p>If the <a>context object</a> is in the <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, let <var>qualifiedName</var> be <a>converted to ASCII lowercase</a>.

 <li><p>Let <var>attribute</var> be the first <a href="#concept-attribute">attribute</a> in the <a>context object</a>'s <a for=Element>attribute list</a> whose <a href="#attribute-name">name</a> is <var>qualifiedName</var>, or null if there is no such <a href="#concept-attribute">attribute</a>.

 <li><p>If <var>attribute</var> is null, create an <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-local-name">local name</a> is <var>qualifiedName</var>, <a href="#concept-attribute-value">value</a> is <var>value</var>,
and <a href="#concept-node-document">node document</a> is <a>context object</a>'s <a href="#concept-node-document">node document</a>,
 and then <a href="#element-append">append</a> this <a href="#concept-attribute">attribute</a> to the <a>context object</a> and terminate these steps.

 <li><p><a>Change</a> <var>attribute</var> from <a>context object</a> to <var>value</var>.
</ol>

<p>The <dfn method for=Element>setAttributeNS(<var>namespace</var>, <var>qualifiedName</var>, <var>value</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>namespace</var>, <var>prefix</var>, and <var>localName</var> be the result of
 passing <var>namespace</var> and <var>qualifiedName</var> to <a>validate and extract</a>. Rethrow
 any exceptions.

 <li><p><a>Set an attribute value</a> for the <a>context object</a> using <var>localName</var>,
 <var>value</var>, and also <var>prefix</var> and <var>namespace</var>.
</ol>

<p>The <dfn method for=Element>removeAttribute(<var>qualifiedName</var>)</dfn>
method, when invoked, must <a lt="remove an attribute by name">remove an attribute</a> given
<var>qualifiedName</var> and the <a>context object</a>, and then return undefined.

<p>The <dfn method for=Element>removeAttributeNS(<var>namespace</var>, <var>localName</var>)</dfn> method, when invoked, must
<a href="#concept-element-attributes-remove-by-namespace">remove an attribute</a> given <var>namespace</var>,
<var>localName</var>, and <a>context object</a>, and then return undefined.

<p>The <dfn method for=Element>hasAttribute(<var>name</var>)</dfn> method, when invoked, must run these steps:
<ol>
 <li><p>If the <a>context object</a> is in the <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, let <var>name</var> be <a>converted to ASCII lowercase</a>.

 <li><p>Return true if the <a>context object</a> <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#attribute-qualified-name">qualifiedName</a> is <var>qualifiedName</var>, and false otherwise.
</ol>

<p>The <dfn method for=Element>hasAttributeNS(<var>namespace</var>, <var>localName</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <var>namespace</var> is the empty string, set it to null.

 <li><p>Return true if the <a>context object</a> <a>has</a> an <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-namespace">namespace</a> is <var>namespace</var> and <a href="#concept-attribute-local-name">local name</a> is <var>localName</var>, and false otherwise.
</ol>

<hr>

<dl>
 <dt><code>var shadow = <var>element</var> . {{Element/attachShadow(init)}}</code>
 <dd><p>Creates a <a href="#concept-shadow-root">shadow root</a> for <var>element</var> and returns it.

 <dt><code>var shadow = <var>element</var> . {{Element/shadowRoot}}</code>
 <dd><p>Returns <var>element</var>'s <a href="#concept-shadow-root">shadow root</a>, if any, and if
 <a href="#concept-shadow-root">shadow root</a>'s <a for=ShadowRoot>mode</a> is "<code>open</code>", and null otherwise.
</dl>

<p>The <dfn method for=Element><code>attachShadow(<var>init</var>)</code></dfn> method, when
invoked, must run these steps:

<ol>
 <li><p>If <a>context object</a>'s <a href="#concept-element-namespace">namespace</a> is <em>not</em> the
 <a>HTML namespace</a>, then <a>throw</a> a <code><a>NotSupportedError</a></code>.

 <li><p>If <a>context object</a>'s <a href="#concept-element-local-name">local name</a> is <em>not</em> a
 <a>valid custom element name</a>,
 "<code>article</code>",
 "<code>aside</code>",
 "<code>blockquote</code>",
 "<code>body</code>",
 "<code>div</code>",
 "<code>footer</code>",
 "<code>h1</code>",
 "<code>h2</code>",
 "<code>h3</code>",
 "<code>h4</code>",
 "<code>h5</code>",
 "<code>h6</code>",
 "<code>header</code>",
 "<code>main</code>"
 "<code>nav</code>",
 "<code>p</code>",
 "<code>section</code>", or
 "<code>span</code>", then <a>throw</a> a <code><a>NotSupportedError</a></code>.

 <li><p>If <a>context object</a> is a <a href="#element-shadow-root">shadow host</a>, then <a>throw</a> an
 <code><a>InvalidStateError</a></code>.

 <li><p>Let <var>shadow</var> be a new <a href="#concept-shadow-root">shadow root</a> whose <a>node document</a>
 is <a>context object</a>'s <a>node document</a>, <a>host</a> is
 <a>context object</a>, and <a for=ShadowRoot>mode</a> is <var>init</var>'s {{ShadowRootInit/mode}}.

 <li><p>Set <a>context object</a>'s <a href="#concept-shadow-root">shadow root</a> to <var>shadow</var>.

 <li><p>Return <var>shadow</var>.
</ol>

<p>The <dfn attribute for=Element><code>shadowRoot</code></dfn> attribute's getter must run these
steps:

<ol>
 <li><p>Let <var>shadow</var> be <a>context object</a>'s <a href="#concept-shadow-root">shadow root</a>.

 <li><p>If <var>shadow</var> is null or its <a for=ShadowRoot>mode</a> is "<code>closed</code>",
 then return null.</p></li>

 <li><p>Return <var>shadow</var>.
</ol>

<hr>

<dl>
 <dt><code><var>element</var> . {{Element/closest(selectors)}}</code>
 <dd>Returns the first (starting at <var>element</var>) <a>inclusive ancestor</a> that matches <var>selectors</var>, and null otherwise.

 <dt><var>element</var> . {{Element/matches(selectors)}}
 <dd>Returns true if matching <var>selectors</var> against <var>element</var>'s <a href="#concept-tree-root">root</a> yields <var>element</var>, and false otherwise.
</dl>

The <dfn method for=Element>closest(<var>selectors</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>Let <var>s</var> be the result of <a>parse a selector</a> from <var>selectors</var>. [[!SELECTORS4]]

 <li>If <var>s</var> is failure, <a>throw</a> a <code><a>SyntaxError</a></code>.

 <li>Let <var>elements</var> be <a>context object</a>'s <a>inclusive ancestors</a> that are <a href="#concept-element">elements</a>, in reverse <a>tree order</a>.

 <li>For each <var>element</var> in <var>elements</var>, if <a>match a selector against an element</a>, using <var>s</var>, <var>element</var>, and <a>:scope element</a> <a>context object</a>, returns success, return <var>element</var>. [[!SELECTORS4]]

 <li>Return null.
</ol>

The <dfn method for=Element>matches(<var>selectors</var>)</dfn> and
<dfn method for=Element>webkitMatchesSelector(<var>selectors</var>)</dfn> methods, when invoked, must run these steps:

<ol>
 <li>Let <var>s</var> be the result of <a>parse a selector</a> from <var>selectors</var>. [[!SELECTORS4]]

 <li>If <var>s</var> is failure, <a>throw</a> a <code><a>SyntaxError</a></code>.

 <li>Return true if the result of <a>match a selector against an element</a>, using <var>s</var>, <var>element</var>, and <a>:scope element</a> <a>context object</a>, returns success, and false otherwise. [[!SELECTORS4]]
</ol>

<hr>
<p>The <dfn method for=Element>getAttributeNode(<var>name</var>)</dfn> method, when invoked, must return the result of
<a href="#element-attributes-get-by-name">getting an attribute</a> given <var>qualifiedName</var> and the <a>context object</a>.

<p>The <dfn method for=Element>getAttributeNodeNS(<var>namespace</var>, <var>localName</var>)</dfn> method, when invoked,
must return the result of <a href="#element-attributes-get-by-namespace">getting an attribute</a> given
<var>namespace</var>, <var>localName</var>, and the <a>context object</a>.

<p>The <dfn method for=Element>setAttributeNode(<var>attr</var>)</dfn> and <dfn>settAttributeNodeNS(<var>attr</var>)</dfn> method,
when invoked, must return the result of <a href="#element-attributes-set-by-attr">setting an attribute</a> given
<var>attr</var> and the <a>context object</a>.

<p>The <dfn method for=Element>removeAttributeNode(<var>attr</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>If <a>context object</a>'s <a for=Element>attribute list</a> doesn't contain <var>attr</var>,
 <a for=Element>attribute list</a>, <a>throw</a> a <code><a>NotFoundError</a></code>.

 <li><p><a href="#concept-element-attributes-remove-by-name">Remove</a> <var>attr</var> from <a>context object</a>.

 <li> Return <var>attr</var>.
</ol>

<hr>

<p>The <dfn method for=Element id="element-getelementsbytagname-func">getElementsByTagName(<var>localName</var>)</dfn> method, when invoked, must return the <a>list of elements with local name <var>localName</var></a> for the <a>context object</a>.

<p>The <dfn method for=Element id="element-getelementsbytagnamens-func">getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</dfn> method, when invoked, must return the <a>list of elements with namespace <var>namespace</var> and local name <var>localName</var></a> for the <a>context object</a>.

<p>The <dfn method for=Element><code>getElementsByClassName(<var>classNames</var>)</code></dfn> method, when invoked, must return the <a>list of elements with class names <var>classNames</var></a> for <a>context object</a>.

<hr>

<p>To <dfn>insert adjacent</dfn>, given an <a for=/>element</a> <var>element</var>, string
<var>where</var>, and a <a href="#concept-node">node</a> <var>node</var>, run the steps associated with the first
<a>ASCII case-insensitive</a> match for <var>where</var>:

<dl class=switch>
 <dt>"<code>beforebegin</code>"
 <dd>
  <p>If <var>element</var>'s <a>parent</a> is null, return null.

  <p>Return the result of <a>pre-inserting</a></a> <var>node</var> into <var>element</var>'s <a>parent</a> before
  <var>element</var>. Rethrow any exceptions.

 <dt>"<code>afterbegin</code>"
 <dd><p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var> before
 <var>element</var>'s <a href="#concept-tree-first-child">first child</a>. Rethrow any exceptions.

 <dt>"<code>beforeend</code>"
 <dd><p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var> before null.
 Rethrow any exceptions.

 <dt>"<code>afterend</code>"
 <dd>
  <p>If <var>element</var>'s <a>parent</a> is null, return null.

  <p>Return the result of <a>pre-inserting</a> <var>node</var> into <var>element</var>'s <a>parent</a> before
  <var>element</var>'s <a for=tree>next sibling</a>. Rethrow any exceptions.

 <dt>Otherwise</dt>
 <dd><p>Throw a <code><a>SyntaxError</a></code>.
</dl>

<p>The
<dfn method for=Element>insertAdjacentElement(<var>where</var>, <var>element</var>)</dfn>
method, when invoked, must return the result of running <a>insert adjacent</a>, given
<a>context object</a>, <var>where</var>, and <var>element</var>. Rethrow any exceptions.

<p>The
<dfn method for=Element>insertAdjacentText(<var>where</var>, <var>data</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>text</var> be a new <code>Text</code> object whose <a>data</a> is <var>data</var>.

 <li><p>Run <a>insert adjacent</a>, given <a>context object</a>, <var>where</var>, and
 <var>text</var>. Rethrow any exceptions.
</ol>

<p class="note">Note: This method returns nothing because it existed before we had a chance to design it.

<h4 id=interface-namednodemap>Interface {{NamedNodeMap}}</h4>

<pre class=idl>
[Exposed=Window, LegacyUnenumerableNamedProperties]
interface NamedNodeMap {
  readonly attribute unsigned long length;

  getter Attr? item(unsigned long index);
  getter Attr? getNamedItem(DOMString qualifiedName);
  Attr? getNamedItemNS(DOMString? namespace, DOMString localName);

  Attr? setNamedItem(Attr attr);
  Attr? setNamedItemNS(Attr attr);

  Attr removeNamedItem(DOMString qualifiedName);
  Attr removeNamedItemNS(DOMString? namespace, DOMString localName);
};
</pre>

A {{NamedNodeMap}} has an associated <dfn export id=concept-namednodemap-element for=NamedNodeMap>element</dfn> (an
<a href="#concept-element">element</a>).

A {{NamedNodeMap}} object's <dfn export id=concept-namednodemap-attribute for=NamedNodeMap>attribute list</dfn> is its
<a href="#concept-namednodemap-element">element</a>'s <a for=Element>attribute list</a>.

A {{NamedNodeMap}} object's <a>supported property indices</a> are the numbers in the range zero to the number of <a href="#concept-attribute">attributes</a> in its
<a href="#concept-namednodemap-attribute">attribute list</a> map minus one, unless the <a href="#concept-namednodemap-attribute">attribute list</a> is empty, in which case
there are no <a>supported property indices</a>.

<hr>

<p>The <dfn attribute for=NamedNodeMap>length</dfn> attribute's getter must return
the number of <a href="#concept-attribute">attributes</a> in the <a for=NamedNodeMap>attribute list</a>.

<p>The <dfn method for=NamedNodeMap>item(<var>index</var>)</dfn> method, when
invoked, must run these steps:

<ol>
 <li><p>If <var>index</var> is equal to or greater than the number of <a href="#concept-attribute">attributes</a> in the
 <a for=NamedNodeMap>attribute list</a>, return null.

 <li><p>Otherwise, return the <var>index</var>th <a href="#concept-attribute">attribute</a> in the
 <a for=NamedNodeMap>attribute list</a>.
</ol>

<p>A {{NamedNodeMap}} object's <a>supported property names</a> are the return value of running these
steps:

<ol>
 <li><p>Let <var>names</var> be the <a href="#attribute-qualified-name">qualified names</a> of the <a href="#concept-attribute">attributes</a> in this
 {{NamedNodeMap}} object's <a for=NamedNodeMap>attribute list</a>, with duplicates omitted, in
 order.
 <!-- Even though not all names that map to an attribute are listed, due to lowercasing, ECMAScript
      invariants are not violated. https://github.com/whatwg/dom/issues/141#issuecomment-168753410
      has details. -->

 <li>
  <p>If this {{NamedNodeMap}} object's <a for=NamedNodeMap>element</a> is in the
  <a>HTML namespace</a> and its <a>node document</a> is an <a>HTML document</a>, then for
  each <var>name</var> in <var>names</var>, run these substeps:

  <ol>
   <li><p>Let <var>lowercaseName</var> be <var>name</var>, in <a href="#converted-to-ascii-lowercase">ASCII lowercase</a>.

   <li><p>If <var>lowercaseName</var> is not equal to <var>name</var>, remove <var>name</var> from
   <var>names</var>.
  </ol>

 <li><p>Return <var>names</var>.
</ol>

<p>The <dfn method for=NamedNodeMap>getNamedItem(<var>qualifiedName</var>)</dfn>
method, when invoked, must return the result of
<a lt="get an attribute by name">getting an attribute</a> given <var>qualifiedName</var> and
<a for=NamedNodeMap>element</a>.

<p>The <dfn method for=NamedNodeMap>getNamedItemNS(<var>namespace</var>, <var>localName</var>)</dfn>
method, when invoked, must return the result of <a lt="get an attribute by namespace and local name">getting an attribute</a> given
<var>namespace</var>, <var>localName</var>, and <a for=NamedNodeMap>element</a>.

<p>The <dfn method for=NamedNodeMap>setNamedItem(<var>attr</var>)</dfn> and <dfn method for="NamedNodeMap">setNamedItemNS(<var>attr</var>)</dfn>
methods, when invoked, must return the result of <a lt="set an attribute">setting an attribute</a> given <var>attr</var> and <a for=NamedNodeMap>element</a>. Rethrow any exceptions.

<p>The <dfn method for=NamedNodeMap>removeNamedItem(<var>qualifiedName</var>)</dfn> method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of  <a lt="remove an attribute by name">removing an attribute</a> given
 <var>qualifiedName</var> and <a for=NamedNodeMap>element</a>.

 <li><p>If <var>attr</var> is null, then <a>throw</a> a <code><a>NotFoundError</a></code>.

 <li><p>Return <var>attr</var>.
</ol>

<p>The <dfn method for=NamedNodeMap>removeNamedItemNS(<var>namespace</var>, <var>localName</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>attr</var> be the result of
 <a lt="remove an attribute by namespace and local name">removing an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <a for=NamedNodeMap>element</a>.

 <li><p>If <var>attr</var> is null, then <a>throw</a> a <code><a>NotFoundError</a></code>.

 <li><p>Return <var>attr</var>.
</ol>

<h4 id="interface-attr">Interface {{Attr}}</h4>
<pre class='idl'>
[Exposed=Window]
interface Attr : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
  readonly attribute DOMString nodeName; // for legacy use, alias of .name
           attribute DOMString value;

  readonly attribute Element? ownerElement;

  readonly attribute boolean specified; // useless; always returns true
};
</pre>

<p>{{Attr}} <a href="#concept-node">nodes</a> are simply known as <dfn id="concept-attribute">attributes</dfn>. They are sometimes referred to as <em>content attributes</em> to avoid confusion with IDL attributes.

<a>Attributes</a> have a <dfn export id=concept-attribute-namespace for=Attr>namespace</dfn> (null or a non-empty string), <dfn export id=concept-attribute-namespace-prefix for=Attr>namespace prefix</dfn> (null or a non-empty string), <dfn export id=concept-attribute-local-name for=Attr>local name</dfn> (a non-empty string), <dfn id="attribute-name" for="attribute">name</dfn> (a non-empty string), <dfn export id=concept-attribute-value for=Attr>value</dfn> (a string), and <dfn export id=concept-attribute-element for=Attr>element</dfn> (null or an <a for="/">element</a>).

<p class="note">Note: If designed today they would just have a name and value.

<p>An <a href="#concept-attribute">attribute</a>'s
<dfn id="attribute-qualified-name">qualified name</dfn> is its
<a href="#concept-attribute-local-name">local name</a> if its <a href="#concept-attribute-namespace-prefix">namespace prefix</a> is null, and its
<a href="#concept-attribute-namespace-prefix">namespace prefix</a>, followed by "<code>:</code>", followed by its
<a href="#concept-attribute-local-name">local name</a>, otherwise.

<p>When an <a href="#concept-attribute">attribute</a> is created, its <a href="#concept-attribute-local-name">local name</a> and <a href="#concept-attribute-value">value</a> are always given. Unless explicitly given when an <a href="#concept-attribute">attribute</a> is created, its <a href="#attribute-name">name</a> is identical to its <a href="#concept-attribute-local-name">local name</a>, and its <a href="#concept-attribute-namespace">namespace</a> and <a href="#concept-attribute-namespace-prefix">namespace prefix</a> are null.

<p>An <dfn id="named-attribute"><var>A</var> attribute</dfn> is an <a href="#concept-attribute">attribute</a> whose <a href="#concept-attribute-local-name">local name</a> is <var>A</var> and whose <a href="#concept-attribute-namespace">namespace</a> and <a href="#concept-attribute-namespace-prefix">namespace prefix</a> are null.

<p>The <dfn attribute for=Attr>namespaceURI</dfn> attribute's getter must return the <a href="#concept-attribute-namespace">namespace</a>.

<p>The <dfn attribute for=Attr>prefix</dfn> attribute's getter must return the <a href="#concept-attribute-namespace-prefix">namespace prefix</a>.

<p>The <dfn attribute for=Attr>localName</dfn> attribute's getter must return the <a href="#concept-attribute-local-name">local name</a>.

<p>The <dfn attribute for=Attr>name</dfn> attribute's getter and <dfn attribute id="attr-nodename" for=Attr><code>nodeName</code></dfn> attribute's getter must return the <a href="#attribute-name">name</a>.

<p>The <dfn attribute for=Attr>value</dfn> attribute's getter must both return the <a href="#concept-attribute-value">value</a>.

<p>To <dfn>set an existing attribute value</dfn>, given an <a href="#concept-attribute">attribute</a> <var>attribute</var> and
string <var>value</var>, run these steps:

<ol>
 <li>If <var>attribute</var>'s <a href="#concept-attribute-element">element</a> is null, then set <var>attribute</var>'s
 <a href="#concept-attribute-value">value</a> to <var>value</var>.

 <li>Otherwise, <a>change</a> <var>attribute</var> from
 <var>attribute</var>'s <a href="#concept-attribute-element">element</a> to <var>value</var>.
</ol>

<p>The {{Attr/value}} attribute's setter must <a>set an existing attribute value</a> with
<a>context object</a> and the given value.

<p>The <dfn attribute for="Attr">ownerElement</dfn> attribute's getter must return
<a>context object</a>'s <a href="#concept-attribute-element">element</a>.

<p>The <dfn attribute for="Attr">specified</dfn> attribute's getter must return true.

<h3 id=interface-characterdata>Interface {{CharacterData}}</h3>

<pre class='idl'>
[Exposed=Window]
interface CharacterData : Node {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;

  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};
</pre>

<p class="note">Note: {{CharacterData}} is an abstract interface and does not exist as <a href="#concept-node">node</a>. It is used by {{Text}}, {{Comment}}, and {{ProcessingInstruction}} <a>nodes</a>.

<p>Each <a>node</a> inheriting from the {{CharacterData}} interface has an associated mutable string called <dfn export id=concept-cd-data for=CharacterData>data</dfn>.

<p>To <dfn>replace data</dfn> of node <var>node</var> with offset <var>offset</var>, count <var>count</var>, and data <var>data</var>, run these steps:</p>

<ol>
 <li><p>Let <var>length</var> be <var>node</var>'s <code><a href="#dom-characterdata-length">length</a></code> attribute value.

 <li><p>If <var>offset</var> is greater than <var>length</var>, <a>throw</a> an <code><a>IndexSizeError</a></code>.

 <li><p>If <var>offset</var> plus <var>count</var> is greater than <var>length</var> let <var>count</var> be <var>length</var> minus <var>offset</var>.

 <li><p><a>Queue a mutation record</a> of "<code>characterData</code>" for <var>node</var> with oldValue <var>node</var>'s <a href="#concept-cd-data">data</a>.

 <li><p>Insert <var>data</var> into <var>node</var>'s <a href="#concept-cd-data">data</a> after <var>offset</var> <a>code units</a>.

 <li><p>Let <var>delete offset</var> be <var>offset</var> plus the number of <a>code units</a> in <var>data</var>.

 <li><p>Starting from <var>delete offset</var> <a>code units</a>, remove <var>count</var> <a>code units</a> from <var>node</var>'s <a href="#concept-cd-data">data</a>.

 <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is <var>node</var> and <a>start offset</a> is greater than <var>offset</var> but less than or equal to <var>offset</var> plus <var>count</var>, set its <a>start offset</a> to <var>offset</var>.

 <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>node</var> and <a>end offset</a> is greater than <var>offset</var> but less than or equal to <var>offset</var> plus <var>count</var>, set its <a>end offset</a> to <var>offset</var>.

 <li><p>For each <a href="#concept-range">range</a> whos <a>start node</a> is <var>node</var> and <a>start offset</a> is greater than <var>offset</var> plus <var>count</var>, increase its <a>start offset</a> by the number of <a>code units</a> in <var>data</var>, then decrease it by <var>count</var>.

 <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>node</var> and <a>end offset</a> is greater than <var>offset</var> plus <var>count</var>, increase its <a>end offset</a> by the number of <a>code units</a> in <var>data</var>, then decrease it by <var>count</var>.
</ol>

<p>To <dfn lt="substringing data | substring data">substring data</dfn> with node <var>node</var>, offset <var>offset</var>, and count <var>count</var>, run these steps:

<ol>
 <li><p>Let <var>length</var> be <var>node</var>'s <a href="#node-length">length</a>.

 <li><p>If <var>offset</var> is greater than <var>length</var>, <a>throw</a> an <code><a>IndexSizeError</a></code>.

 <li><p>If <var>offset</var> plus <var>count</var> is greater than <var>length</var>, return a string whose value is the <a>code units</a> from the <var>offset</var><sup>th</sup> <a>code unit</a> to the end of <var>node</var>'s <a href="#concept-cd-data">data</a>, and then terminate these steps.

 <li><p>Return a string whose value is the <a>code units</a> from the <var>offset</var><sup>th</sup> <a>code unit</a> to the <var>offset</var>+<var>count</var><sup>th</sup> <a>code unit</a> in <var>node</var>'s <a href="#concept-cd-data">data</a>.
</ol>

<hr>

<p>The <dfn attribute for=CharacterData><code>data</code></dfn> attribute's getter must return <a>context object</a>'s <a for=CharacterData>data</a>, and on setting, must <a>replace data</a> with node <a>context object</a> offset 0, count <a>context object</a>'s <a href="#node-length">length</a>, and data new value.

<p>The <dfn attribute for=CharacterData><code>length</code></dfn> attribute's getter must return <a>context object</a>'s <a href="#node-length">length</a>.

<p>The <dfn method for=CharacterData><code>substringData(<var>offset</var>, <var>count</var>)</code></dfn> method, when invoked, must <a>substring data</a> with node <a>context object</a>, offset <var>offset</var>, and count <var>count</var>.

<p>The <dfn method for=CharacterData><code>appendData(<var>data</var>)</code></dfn> method, when invoked, must <a>replace data</a> with node <a>context object</a>, offset <a>context object</a>'s <a href="#node-length">length</a>, count 0, and data <var>data</var>.

<p>The <dfn method for=CharacterData><code>insertData(<var>offset</var>, <var>data</var>)</code></dfn> method, when invoked, must <a>replace data</a> with node <a>context object</a>, offset <var>offset</var>, count 0, and data <var>data</var>.

<p>The <dfn method for=CharacterData><code>deleteData(<var>offset</var>, <var>count</var>)</code></dfn> method, when invoked, must <a>replace data</a> with node <a>context object</a>, offset <var>offset</var>, count <var>count</var>, and data the empty string.

<p>The <dfn method for=CharacterData><code>replaceData(<var>offset</var>, <var>count</var>, <var>data</var>)</code></dfn> method, when invoked, must <a>replace data</a> with node <a>context object</a>, offset <var>offset</var>, count <var>count</var>, and data <var>data</var>.

<h3 id=interface-text>Interface {{Text}}</h3>

<pre class='idl'>
[Constructor(optional DOMString data = ""),
 Exposed=Window]
interface Text : CharacterData {
  [NewObject] Text splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};
</pre>

<p>An <dfn export>exclusive {{Text}} node</dfn> is a {{Text}} <a href="#concept-node">node</a> that is not a {{CDATASection}} <a href="#concept-node">node</a>.

<p>The <dfn export>contiguous {{Text}} nodes</dfn> of a <a href="#concept-node">node</a> <var>node</var> are <var>node</var>, <var>node</var>'s <a>previous sibling</a> {{Text}} <a href="#concept-node">node</a>, if any, and its <a>contiguous <code>Text</code> nodes</a>, and <var>node</var>'s <a for=tree>next sibling</a> {{Text}} <a href="#concept-node">node</a>, if any, and its <a>contiguous <code>Text</code> nodes</a>, avoiding any duplicates.

<p>The <dfn export>contiguous exclusive {{Text}} nodes</dfn> of a <a href="#concept-node">node</a> <var>node</var> are
<var>node</var>, <var>node</var>'s <a>previous sibling</a> <a>exclusive <code>Text</code> node</a>,
if any, and its <a>contiguous exclusive <code>Text</code> nodes</a>, and <var>node</var>'s
<a for=tree>next sibling</a> <a>exclusive <code>Text</code> node</a>, if any, and its
<a>contiguous exclusive <code>Text</code> nodes</a>, avoiding any duplicates.

<hr>

<dl>
 <dt><var ignore>text</var> = new <a href="#documentfragment">Text</a>([<var>data</var> = ""])
 <dd><p>Returns a new {{Text}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is <var>data</var>.

 <dt><var>text</var> . {{Text/splitText(offset)}}
 <dd><p>Splits <a href="#concept-cd-data">data</a> at the given <var>offset</var> and returns the remainder as {{Text}} <a href="#concept-node">node</a>.

 <dt><var>text</var> . {{Text/wholeText}}
 <dd><p>Returns the combined <a href="#concept-cd-data">data</a> of all direct {{Text}} <a href="#concept-node">node</a> <a>siblings</a>.
</dl>

<p>The <dfn constructor for=Text>Text(<var>data</var>)</dfn> constructor, when invoked, must return a new {{Text}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is <var>data</var> and <a>node document</a> is the global object's associated <a href="#concept-document">document</a>.

<hr>

<p>To <dfn>split</dfn> a {{Text}} <a href="#concept-node">node</a> <var>node</var> with offset <var>offset</var>, run these steps:

<ol>
 <li><p>Let <var>length</var> be <var>node</var>'s <a href="#node-length">length</a>.

 <li><p>If <var>offset</var> is greater than <var>length</var>, <a>throw</a> an <code><a>IndexSizeError</a></code>.

 <li><p>Let <var>count</var> be <var>length</var> minus <var>offset</var>.

 <li><p>Let <var>new data</var> be the result of <a>substringing data</a> with node <var>node</var>, offset <var>offset</var>, and count <var>count</var>.

 <li><p>Let <var>new node</var> be a new {{Text}} <a href="#concept-node">node</a>, with the same <a>node document</a> as <var>node</var>. Set <var>new node</var>'s <a href="#concept-cd-data">data</a> to <var>new data</var>.

 <li><p>Let <var>parent</var> be <var>node</var>'s <a>parent</a>.

 <li>
  <p>If <var>parent</var> is not null, run these substeps:

  <ol>
   <li><p><a href="#node-insert">Insert</a> <var>new node</var> into <var>parent</var> before
   <var>node</var>'s <a href="#concept-tree-next-sibling">next sibling</a>.
   <!-- Do this before we replace data, so that the data replacement won't
   mutate ranges prematurely:
   https://www.w3.org/Bugs/Public/show_bug.cgi?id=15325 -->

   <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is <var>node</var> and <a>start offset</a> is greater than <var>offset</var>, set its <a>start node</a> to <var>new node</var> and decrease its <a>start offset</a> by <var>offset</var>.

   <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>node</var> and <a>end offset</a> is greater than <var>offset</var>, set its <a>end node</a> to <var>new node</var> and decrease its <a>end offset</a> by <var>offset</var>.

   <!-- This shit is complicated:
        https://www.w3.org/Bugs/Public/show_bug.cgi?id=19968 -->
   <li><p>For each <a href="#concept-range">range</a> whose <a>start node</a> is <var>parent</var> and <a>start offset</a> is equal to the <a>index</a> of <var>node</var> + 1, increase its <a>start offset</a> by one.

   <li><p>For each <a href="#concept-range">range</a> whose <a>end node</a> is <var>parent</var> and <a>end offset</a> is equal to the <a>index</a> of <var>node</var> + 1, increase its <a>end offset</a> by one.
  </ol>

 <li><p><a>Replace data</a> with node <var>node</var>, offset <var>offset</var>, count <var>count</var>, and data the empty string.

 <li><p>Return <var>new node</var>.
</ol>

<p>The <dfn method for=Text>splitText(<var>offset</var>)</dfn> method, when invoked, must <a>split</a> the <a>context object</a> with offset <var>offset</var>.



<p>The <dfn attribute for=Text>wholeText</dfn> attribute's getter must return a concatenation of the <a href="#concept-cd-data">data</a> of the <a>contiguous <code>Text</code> nodes</a> of the <a>context object</a>, in <a>tree order</a>.

<h3 id=interface-cdatasection>Interface {{CDATASection}}</h3>

<pre class='idl'>
[Exposed=Window]
interface CDATASection : Text {
};</pre>

<h3 id=interface-processinginstruction>Interface {{ProcessingInstruction}}</h3>

<pre class='idl'>
[Exposed=Window]
interface ProcessingInstruction : CharacterData {
  readonly attribute DOMString target;
};
</pre>


{{ProcessingInstruction}} <a>nodes</a>
have an associated <dfn export id=concept-pi-target for=ProcessingInstruction>target</dfn>.

The <dfn attribute for=ProcessingInstruction>target</dfn> attribute must return the <a for=ProcessingInstruction>target</a>.

<h3 id=interface-comment>Interface {{Comment}}</h3>

<pre class='idl'>
[Constructor(optional DOMString data = ""),
 Exposed=Window]
interface Comment : CharacterData {
};
</pre>

<dl>
 <dt><var ignore>comment</var> = new {{Comment}}([<var>data</var> = ""])
 <dd><p>Returns a new {{Comment}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is <var>data</var>.
</dl>

<p>The <dfn constructor for=Comment>Comment(<var>data</var>)</dfn> constructor, when invoked, must return a new {{Comment}} <a href="#concept-node">node</a> whose <a href="#concept-cd-data">data</a> is <var>data</var> and <a>node document</a> is <a>current global object</a>'s <a>associated <code>Document</code></a>.
</section>
